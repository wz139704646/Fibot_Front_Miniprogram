!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.echarts = {}) }(this, function (t) {
  "use strict"; function e(t) { var e = {}, i = {}, n = t.match(/Firefox\/([\d.]+)/), r = t.match(/MSIE\s([\d.]+)/) || t.match(/Trident\/.+?rv:(([\d.]+))/), a = t.match(/Edge\/([\d.]+)/), o = /micromessenger/i.test(t); return n && (i.firefox = !0, i.version = n[1]), r && (i.ie = !0, i.version = r[1]), a && (i.edge = !0, i.version = a[1]), o && (i.weChat = !0), { browser: i, os: e, node: !1, canvasSupported: !!document.createElement("canvas").getContext, svgSupported: "undefined" != typeof SVGRect, touchEventsSupported: "ontouchstart" in window && !i.ie && !i.edge, pointerEventsSupported: "onpointerdown" in window && (i.edge || i.ie && i.version >= 11), domSupported: "undefined" != typeof document } } function i(t, e) { "createCanvas" === t && (Jp = null), $p[t] = e } function n(t) { if (null == t || "object" != typeof t) return t; var e = t, i = Xp.call(t); if ("[object Array]" === i) { if (!B(t)) { e = []; for (var r = 0, a = t.length; a > r; r++)e[r] = n(t[r]) } } else if (Wp[i]) { if (!B(t)) { var o = t.constructor; if (t.constructor.from) e = o.from(t); else { e = new o(t.length); for (var r = 0, a = t.length; a > r; r++)e[r] = n(t[r]) } } } else if (!Hp[i] && !B(t) && !D(t)) { e = {}; for (var s in t) t.hasOwnProperty(s) && (e[s] = n(t[s])) } return e } function r(t, e, i) { if (!S(e) || !S(t)) return i ? n(e) : t; for (var a in e) if (e.hasOwnProperty(a)) { var o = t[a], s = e[a]; !S(s) || !S(o) || _(s) || _(o) || D(s) || D(o) || M(s) || M(o) || B(s) || B(o) ? !i && a in t || (t[a] = n(e[a], !0)) : r(o, s, i) } return t } function a(t, e) { for (var i = t[0], n = 1, a = t.length; a > n; n++)i = r(i, t[n], e); return i } function o(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]); return t } function s(t, e, i) { for (var n in e) e.hasOwnProperty(n) && (i ? null != e[n] : null == t[n]) && (t[n] = e[n]); return t } function l() { return Jp || (Jp = Qp().getContext("2d")), Jp } function u(t, e) { if (t) { if (t.indexOf) return t.indexOf(e); for (var i = 0, n = t.length; n > i; i++)if (t[i] === e) return i } return -1 } function h(t, e) { function i() { } var n = t.prototype; i.prototype = e.prototype, t.prototype = new i; for (var r in n) t.prototype[r] = n[r]; t.prototype.constructor = t, t.superClass = e } function c(t, e, i) { t = "prototype" in t ? t.prototype : t, e = "prototype" in e ? e.prototype : e, s(t, e, i) } function d(t) { return t ? "string" == typeof t ? !1 : "number" == typeof t.length : void 0 } function f(t, e, i) { if (t && e) if (t.forEach && t.forEach === jp) t.forEach(e, i); else if (t.length === +t.length) for (var n = 0, r = t.length; r > n; n++)e.call(i, t[n], n, t); else for (var a in t) t.hasOwnProperty(a) && e.call(i, t[a], a, t) } function p(t, e, i) { if (t && e) { if (t.map && t.map === Zp) return t.map(e, i); for (var n = [], r = 0, a = t.length; a > r; r++)n.push(e.call(i, t[r], r, t)); return n } } function g(t, e, i, n) { if (t && e) { if (t.reduce && t.reduce === Kp) return t.reduce(e, i, n); for (var r = 0, a = t.length; a > r; r++)i = e.call(n, i, t[r], r, t); return i } } function m(t, e, i) { if (t && e) { if (t.filter && t.filter === Yp) return t.filter(e, i); for (var n = [], r = 0, a = t.length; a > r; r++)e.call(i, t[r], r, t) && n.push(t[r]); return n } } function v(t, e, i) { if (t && e) for (var n = 0, r = t.length; r > n; n++)if (e.call(i, t[n], n, t)) return t[n] } function y(t, e) { var i = qp.call(arguments, 2); return function () { return t.apply(e, i.concat(qp.call(arguments))) } } function x(t) { var e = qp.call(arguments, 1); return function () { return t.apply(this, e.concat(qp.call(arguments))) } } function _(t) { return "[object Array]" === Xp.call(t) } function b(t) { return "function" == typeof t } function w(t) { return "[object String]" === Xp.call(t) } function S(t) { var e = typeof t; return "function" === e || !!t && "object" === e } function M(t) { return !!Hp[Xp.call(t)] } function I(t) { return !!Wp[Xp.call(t)] } function D(t) { return "object" == typeof t && "number" == typeof t.nodeType && "object" == typeof t.ownerDocument } function T(t) { return t !== t } function A() { for (var t = 0, e = arguments.length; e > t; t++)if (null != arguments[t]) return arguments[t] } function C(t, e) { return null != t ? t : e } function k(t, e, i) { return null != t ? t : null != e ? e : i } function P() { return Function.call.apply(qp, arguments) } function L(t) { if ("number" == typeof t) return [t, t, t, t]; var e = t.length; return 2 === e ? [t[0], t[1], t[0], t[1]] : 3 === e ? [t[0], t[1], t[2], t[1]] : t } function O(t, e) { if (!t) throw new Error(e) } function z(t) { return null == t ? null : "function" == typeof t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "") } function E(t) { t[tg] = !0 } function B(t) { return t[tg] } function R(t) { function e(t, e) { i ? n.set(t, e) : n.set(e, t) } var i = _(t); this.data = {}; var n = this; t instanceof R ? t.each(e) : t && f(t, e) } function N(t) { return new R(t) } function F(t, e) { for (var i = new t.constructor(t.length + e.length), n = 0; n < t.length; n++)i[n] = t[n]; var r = t.length; for (n = 0; n < e.length; n++)i[n + r] = e[n]; return i } function V() { } function G(t, e) { var i = new ig(2); return null == t && (t = 0), null == e && (e = 0), i[0] = t, i[1] = e, i } function H(t, e) { return t[0] = e[0], t[1] = e[1], t } function W(t) { var e = new ig(2); return e[0] = t[0], e[1] = t[1], e } function X(t, e, i) { return t[0] = e, t[1] = i, t } function U(t, e, i) { return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t } function j(t, e, i, n) { return t[0] = e[0] + i[0] * n, t[1] = e[1] + i[1] * n, t } function Y(t, e, i) { return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t } function q(t) { return Math.sqrt(Z(t)) } function Z(t) { return t[0] * t[0] + t[1] * t[1] } function K(t, e, i) { return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t } function $(t, e, i) { return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t } function Q(t, e) { return t[0] * e[0] + t[1] * e[1] } function J(t, e, i) { return t[0] = e[0] * i, t[1] = e[1] * i, t } function te(t, e) { var i = q(e); return 0 === i ? (t[0] = 0, t[1] = 0) : (t[0] = e[0] / i, t[1] = e[1] / i), t } function ee(t, e) { return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])) } function ie(t, e) { return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]) } function ne(t, e) { return t[0] = -e[0], t[1] = -e[1], t } function re(t, e, i, n) { return t[0] = e[0] + n * (i[0] - e[0]), t[1] = e[1] + n * (i[1] - e[1]), t } function ae(t, e, i) { var n = e[0], r = e[1]; return t[0] = i[0] * n + i[2] * r + i[4], t[1] = i[1] * n + i[3] * r + i[5], t } function oe(t, e, i) { return t[0] = Math.min(e[0], i[0]), t[1] = Math.min(e[1], i[1]), t } function se(t, e, i) { return t[0] = Math.max(e[0], i[0]), t[1] = Math.max(e[1], i[1]), t } function le() { this.on("mousedown", this._dragStart, this), this.on("mousemove", this._drag, this), this.on("mouseup", this._dragEnd, this), this.on("globalout", this._dragEnd, this) } function ue(t, e) { return { target: t, topTarget: e && e.topTarget } } function he(t, e) { var i = t._$eventProcessor; return null != e && i && i.normalizeQuery && (e = i.normalizeQuery(e)), e } function ce(t, e, i, n, r, a) { var o = t._$handlers; if ("function" == typeof i && (r = n, n = i, i = null), !n || !e) return t; i = he(t, i), o[e] || (o[e] = []); for (var s = 0; s < o[e].length; s++)if (o[e][s].h === n) return t; var l = { h: n, one: a, query: i, ctx: r || t, callAtLast: n.zrEventfulCallAtLast }, u = o[e].length - 1, h = o[e][u]; return h && h.callAtLast ? o[e].splice(u, 0, l) : o[e].push(l), t } function de(t) { return t.getBoundingClientRect ? t.getBoundingClientRect() : { left: 0, top: 0 } } function fe(t, e, i, n) { return i = i || {}, n || !Gp.canvasSupported ? pe(t, e, i) : Gp.browser.firefox && null != e.layerX && e.layerX !== e.offsetX ? (i.zrX = e.layerX, i.zrY = e.layerY) : null != e.offsetX ? (i.zrX = e.offsetX, i.zrY = e.offsetY) : pe(t, e, i), i } function pe(t, e, i) { var n = de(t); i.zrX = e.clientX - n.left, i.zrY = e.clientY - n.top } function ge(t, e, i) { if (e = e || window.event, null != e.zrX) return e; var n = e.type, r = n && n.indexOf("touch") >= 0; if (r) { var a = "touchend" !== n ? e.targetTouches[0] : e.changedTouches[0]; a && fe(t, a, e, i) } else fe(t, e, e, i), e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3; var o = e.button; return null == e.which && void 0 !== o && cg.test(e.type) && (e.which = 1 & o ? 1 : 2 & o ? 3 : 4 & o ? 2 : 0), e } function me(t, e, i) { hg ? t.addEventListener(e, i) : t.attachEvent("on" + e, i) } function ve(t, e, i) { hg ? t.removeEventListener(e, i) : t.detachEvent("on" + e, i) } function ye(t) { var e = t[1][0] - t[0][0], i = t[1][1] - t[0][1]; return Math.sqrt(e * e + i * i) } function xe(t) { return [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2] } function _e(t, e, i) { return { type: t, event: i, target: e.target, topTarget: e.topTarget, cancelBubble: !1, offsetX: i.zrX, offsetY: i.zrY, gestureEvent: i.gestureEvent, pinchX: i.pinchX, pinchY: i.pinchY, pinchScale: i.pinchScale, wheelDelta: i.zrDelta, zrByTouch: i.zrByTouch, which: i.which, stop: be } } function be() { dg(this.event) } function we() { } function Se(t, e, i) { if (t[t.rectHover ? "rectContain" : "contain"](e, i)) { for (var n, r = t; r;) { if (r.clipPath && !r.clipPath.contain(e, i)) return !1; r.silent && (n = !0), r = r.parent } return n ? gg : !0 } return !1 } function Me() { var t = new yg(6); return Ie(t), t } function Ie(t) { return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t } function De(t, e) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t } function Te(t, e, i) { var n = e[0] * i[0] + e[2] * i[1], r = e[1] * i[0] + e[3] * i[1], a = e[0] * i[2] + e[2] * i[3], o = e[1] * i[2] + e[3] * i[3], s = e[0] * i[4] + e[2] * i[5] + e[4], l = e[1] * i[4] + e[3] * i[5] + e[5]; return t[0] = n, t[1] = r, t[2] = a, t[3] = o, t[4] = s, t[5] = l, t } function Ae(t, e, i) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4] + i[0], t[5] = e[5] + i[1], t } function Ce(t, e, i) { var n = e[0], r = e[2], a = e[4], o = e[1], s = e[3], l = e[5], u = Math.sin(i), h = Math.cos(i); return t[0] = n * h + o * u, t[1] = -n * u + o * h, t[2] = r * h + s * u, t[3] = -r * u + h * s, t[4] = h * a + u * l, t[5] = h * l - u * a, t } function ke(t, e, i) { var n = i[0], r = i[1]; return t[0] = e[0] * n, t[1] = e[1] * r, t[2] = e[2] * n, t[3] = e[3] * r, t[4] = e[4] * n, t[5] = e[5] * r, t } function Pe(t, e) { var i = e[0], n = e[2], r = e[4], a = e[1], o = e[3], s = e[5], l = i * o - a * n; return l ? (l = 1 / l, t[0] = o * l, t[1] = -a * l, t[2] = -n * l, t[3] = i * l, t[4] = (n * s - o * r) * l, t[5] = (a * r - i * s) * l, t) : null } function Le(t) { var e = Me(); return De(e, t), e } function Oe(t) { return t > bg || -bg > t } function ze(t) { this._target = t.target, this._life = t.life || 1e3, this._delay = t.delay || 0, this._initialized = !1, this.loop = null == t.loop ? !1 : t.loop, this.gap = t.gap || 0, this.easing = t.easing || "Linear", this.onframe = t.onframe, this.ondestroy = t.ondestroy, this.onrestart = t.onrestart, this._pausedTime = 0, this._paused = !1 } function Ee(t) { return t = Math.round(t), 0 > t ? 0 : t > 255 ? 255 : t } function Be(t) { return t = Math.round(t), 0 > t ? 0 : t > 360 ? 360 : t } function Re(t) { return 0 > t ? 0 : t > 1 ? 1 : t } function Ne(t) { return Ee(t.length && "%" === t.charAt(t.length - 1) ? parseFloat(t) / 100 * 255 : parseInt(t, 10)) } function Fe(t) { return Re(t.length && "%" === t.charAt(t.length - 1) ? parseFloat(t) / 100 : parseFloat(t)) } function Ve(t, e, i) { return 0 > i ? i += 1 : i > 1 && (i -= 1), 1 > 6 * i ? t + (e - t) * i * 6 : 1 > 2 * i ? e : 2 > 3 * i ? t + (e - t) * (2 / 3 - i) * 6 : t } function Ge(t, e, i) { return t + (e - t) * i } function He(t, e, i, n, r) { return t[0] = e, t[1] = i, t[2] = n, t[3] = r, t } function We(t, e) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t } function Xe(t, e) { Eg && We(Eg, e), Eg = zg.put(t, Eg || e.slice()) } function Ue(t, e) { if (t) { e = e || []; var i = zg.get(t); if (i) return We(e, i); t += ""; var n = t.replace(/ /g, "").toLowerCase(); if (n in Og) return We(e, Og[n]), Xe(t, e), e; if ("#" !== n.charAt(0)) { var r = n.indexOf("("), a = n.indexOf(")"); if (-1 !== r && a + 1 === n.length) { var o = n.substr(0, r), s = n.substr(r + 1, a - (r + 1)).split(","), l = 1; switch (o) { case "rgba": if (4 !== s.length) return void He(e, 0, 0, 0, 1); l = Fe(s.pop()); case "rgb": return 3 !== s.length ? void He(e, 0, 0, 0, 1) : (He(e, Ne(s[0]), Ne(s[1]), Ne(s[2]), l), Xe(t, e), e); case "hsla": return 4 !== s.length ? void He(e, 0, 0, 0, 1) : (s[3] = Fe(s[3]), je(s, e), Xe(t, e), e); case "hsl": return 3 !== s.length ? void He(e, 0, 0, 0, 1) : (je(s, e), Xe(t, e), e); default: return } } He(e, 0, 0, 0, 1) } else { if (4 === n.length) { var u = parseInt(n.substr(1), 16); return u >= 0 && 4095 >= u ? (He(e, (3840 & u) >> 4 | (3840 & u) >> 8, 240 & u | (240 & u) >> 4, 15 & u | (15 & u) << 4, 1), Xe(t, e), e) : void He(e, 0, 0, 0, 1) } if (7 === n.length) { var u = parseInt(n.substr(1), 16); return u >= 0 && 16777215 >= u ? (He(e, (16711680 & u) >> 16, (65280 & u) >> 8, 255 & u, 1), Xe(t, e), e) : void He(e, 0, 0, 0, 1) } } } } function je(t, e) { var i = (parseFloat(t[0]) % 360 + 360) % 360 / 360, n = Fe(t[1]), r = Fe(t[2]), a = .5 >= r ? r * (n + 1) : r + n - r * n, o = 2 * r - a; return e = e || [], He(e, Ee(255 * Ve(o, a, i + 1 / 3)), Ee(255 * Ve(o, a, i)), Ee(255 * Ve(o, a, i - 1 / 3)), 1), 4 === t.length && (e[3] = t[3]), e } function Ye(t) { if (t) { var e, i, n = t[0] / 255, r = t[1] / 255, a = t[2] / 255, o = Math.min(n, r, a), s = Math.max(n, r, a), l = s - o, u = (s + o) / 2; if (0 === l) e = 0, i = 0; else { i = .5 > u ? l / (s + o) : l / (2 - s - o); var h = ((s - n) / 6 + l / 2) / l, c = ((s - r) / 6 + l / 2) / l, d = ((s - a) / 6 + l / 2) / l; n === s ? e = d - c : r === s ? e = 1 / 3 + h - d : a === s && (e = 2 / 3 + c - h), 0 > e && (e += 1), e > 1 && (e -= 1) } var f = [360 * e, i, u]; return null != t[3] && f.push(t[3]), f } } function qe(t, e) { var i = Ue(t); if (i) { for (var n = 0; 3 > n; n++)i[n] = 0 > e ? i[n] * (1 - e) | 0 : (255 - i[n]) * e + i[n] | 0, i[n] > 255 ? i[n] = 255 : t[n] < 0 && (i[n] = 0); return ti(i, 4 === i.length ? "rgba" : "rgb") } } function Ze(t) { var e = Ue(t); return e ? ((1 << 24) + (e[0] << 16) + (e[1] << 8) + +e[2]).toString(16).slice(1) : void 0 } function Ke(t, e, i) { if (e && e.length && t >= 0 && 1 >= t) { i = i || []; var n = t * (e.length - 1), r = Math.floor(n), a = Math.ceil(n), o = e[r], s = e[a], l = n - r; return i[0] = Ee(Ge(o[0], s[0], l)), i[1] = Ee(Ge(o[1], s[1], l)), i[2] = Ee(Ge(o[2], s[2], l)), i[3] = Re(Ge(o[3], s[3], l)), i } } function $e(t, e, i) { if (e && e.length && t >= 0 && 1 >= t) { var n = t * (e.length - 1), r = Math.floor(n), a = Math.ceil(n), o = Ue(e[r]), s = Ue(e[a]), l = n - r, u = ti([Ee(Ge(o[0], s[0], l)), Ee(Ge(o[1], s[1], l)), Ee(Ge(o[2], s[2], l)), Re(Ge(o[3], s[3], l))], "rgba"); return i ? { color: u, leftIndex: r, rightIndex: a, value: n } : u } } function Qe(t, e, i, n) { return t = Ue(t), t ? (t = Ye(t), null != e && (t[0] = Be(e)), null != i && (t[1] = Fe(i)), null != n && (t[2] = Fe(n)), ti(je(t), "rgba")) : void 0 } function Je(t, e) { return t = Ue(t), t && null != e ? (t[3] = Re(e), ti(t, "rgba")) : void 0 } function ti(t, e) { if (t && t.length) { var i = t[0] + "," + t[1] + "," + t[2]; return ("rgba" === e || "hsva" === e || "hsla" === e) && (i += "," + t[3]), e + "(" + i + ")" } } function ei(t, e) { return t[e] } function ii(t, e, i) { t[e] = i } function ni(t, e, i) { return (e - t) * i + t } function ri(t, e, i) { return i > .5 ? e : t } function ai(t, e, i, n, r) { var a = t.length; if (1 === r) for (var o = 0; a > o; o++)n[o] = ni(t[o], e[o], i); else for (var s = a && t[0].length, o = 0; a > o; o++)for (var l = 0; s > l; l++)n[o][l] = ni(t[o][l], e[o][l], i) } function oi(t, e, i) { var n = t.length, r = e.length; if (n !== r) { var a = n > r; if (a) t.length = r; else for (var o = n; r > o; o++)t.push(1 === i ? e[o] : Fg.call(e[o])) } for (var s = t[0] && t[0].length, o = 0; o < t.length; o++)if (1 === i) isNaN(t[o]) && (t[o] = e[o]); else for (var l = 0; s > l; l++)isNaN(t[o][l]) && (t[o][l] = e[o][l]) } function si(t, e, i) { if (t === e) return !0; var n = t.length; if (n !== e.length) return !1; if (1 === i) { for (var r = 0; n > r; r++)if (t[r] !== e[r]) return !1 } else for (var a = t[0].length, r = 0; n > r; r++)for (var o = 0; a > o; o++)if (t[r][o] !== e[r][o]) return !1; return !0 } function li(t, e, i, n, r, a, o, s, l) { var u = t.length; if (1 === l) for (var h = 0; u > h; h++)s[h] = ui(t[h], e[h], i[h], n[h], r, a, o); else for (var c = t[0].length, h = 0; u > h; h++)for (var d = 0; c > d; d++)s[h][d] = ui(t[h][d], e[h][d], i[h][d], n[h][d], r, a, o) } function ui(t, e, i, n, r, a, o) { var s = .5 * (i - t), l = .5 * (n - e); return (2 * (e - i) + s + l) * o + (-3 * (e - i) - 2 * s - l) * a + s * r + e } function hi(t) { if (d(t)) { var e = t.length; if (d(t[0])) { for (var i = [], n = 0; e > n; n++)i.push(Fg.call(t[n])); return i } return Fg.call(t) } return t } function ci(t) { return t[0] = Math.floor(t[0]), t[1] = Math.floor(t[1]), t[2] = Math.floor(t[2]), "rgba(" + t.join(",") + ")" } function di(t) { var e = t[t.length - 1].value; return d(e && e[0]) ? 2 : 1 } function fi(t, e, i, n, r, a) { var o = t._getter, s = t._setter, l = "spline" === e, u = n.length; if (u) { var h, c = n[0].value, f = d(c), p = !1, g = !1, m = f ? di(n) : 0; n.sort(function (t, e) { return t.time - e.time }), h = n[u - 1].time; for (var v = [], y = [], x = n[0].value, _ = !0, b = 0; u > b; b++) { v.push(n[b].time / h); var w = n[b].value; if (f && si(w, x, m) || !f && w === x || (_ = !1), x = w, "string" == typeof w) { var S = Ue(w); S ? (w = S, p = !0) : g = !0 } y.push(w) } if (a || !_) { for (var M = y[u - 1], b = 0; u - 1 > b; b++)f ? oi(y[b], M, m) : !isNaN(y[b]) || isNaN(M) || g || p || (y[b] = M); f && oi(o(t._target, r), M, m); var I, D, T, A, C, k, P = 0, L = 0; if (p) var O = [0, 0, 0, 0]; var z = function (t, e) { var i; if (0 > e) i = 0; else if (L > e) { for (I = Math.min(P + 1, u - 1), i = I; i >= 0 && !(v[i] <= e); i--); i = Math.min(i, u - 2) } else { for (i = P; u > i && !(v[i] > e); i++); i = Math.min(i - 1, u - 2) } P = i, L = e; var n = v[i + 1] - v[i]; if (0 !== n) if (D = (e - v[i]) / n, l) if (A = y[i], T = y[0 === i ? i : i - 1], C = y[i > u - 2 ? u - 1 : i + 1], k = y[i > u - 3 ? u - 1 : i + 2], f) li(T, A, C, k, D, D * D, D * D * D, o(t, r), m); else { var a; if (p) a = li(T, A, C, k, D, D * D, D * D * D, O, 1), a = ci(O); else { if (g) return ri(A, C, D); a = ui(T, A, C, k, D, D * D, D * D * D) } s(t, r, a) } else if (f) ai(y[i], y[i + 1], D, o(t, r), m); else { var a; if (p) ai(y[i], y[i + 1], D, O, 1), a = ci(O); else { if (g) return ri(y[i], y[i + 1], D); a = ni(y[i], y[i + 1], D) } s(t, r, a) } }, E = new ze({ target: t._target, life: h, loop: t._loop, delay: t._delay, onframe: z, ondestroy: i }); return e && "spline" !== e && (E.easing = e), E } } } function pi(t, e, i, n, r, a, o, s) { function l() { h-- , h || a && a() } w(n) ? (a = r, r = n, n = 0) : b(r) ? (a = r, r = "linear", n = 0) : b(n) ? (a = n, n = 0) : b(i) ? (a = i, i = 500) : i || (i = 500), t.stopAnimation(), gi(t, "", t, e, i, n, s); var u = t.animators.slice(), h = u.length; h || a && a(); for (var c = 0; c < u.length; c++)u[c].done(l).start(r, o) } function gi(t, e, i, n, r, a, o) { var s = {}, l = 0; for (var u in n) n.hasOwnProperty(u) && (null != i[u] ? S(n[u]) && !d(n[u]) ? gi(t, e ? e + "." + u : u, i[u], n[u], r, a, o) : (o ? (s[u] = i[u], mi(t, e, u, n[u])) : s[u] = n[u], l++) : null == n[u] || o || mi(t, e, u, n[u])); l > 0 && t.animate(e, !1).when(null == r ? 500 : r, s).delay(a || 0) } function mi(t, e, i, n) { if (e) { var r = {}; r[e] = {}, r[e][i] = n, t.attr(r) } else t.attr(i, n) } function vi(t, e, i, n) { 0 > i && (t += i, i = -i), 0 > n && (e += n, n = -n), this.x = t, this.y = e, this.width = i, this.height = n } function yi(t) { for (var e = 0; t >= Qg;)e |= 1 & t, t >>= 1; return t + e } function xi(t, e, i, n) { var r = e + 1; if (r === i) return 1; if (n(t[r++], t[e]) < 0) { for (; i > r && n(t[r], t[r - 1]) < 0;)r++; _i(t, e, r) } else for (; i > r && n(t[r], t[r - 1]) >= 0;)r++; return r - e } function _i(t, e, i) { for (i--; i > e;) { var n = t[e]; t[e++] = t[i], t[i--] = n } } function bi(t, e, i, n, r) { for (n === e && n++; i > n; n++) { for (var a, o = t[n], s = e, l = n; l > s;)a = s + l >>> 1, r(o, t[a]) < 0 ? l = a : s = a + 1; var u = n - s; switch (u) { case 3: t[s + 3] = t[s + 2]; case 2: t[s + 2] = t[s + 1]; case 1: t[s + 1] = t[s]; break; default: for (; u > 0;)t[s + u] = t[s + u - 1], u-- }t[s] = o } } function wi(t, e, i, n, r, a) { var o = 0, s = 0, l = 1; if (a(t, e[i + r]) > 0) { for (s = n - r; s > l && a(t, e[i + r + l]) > 0;)o = l, l = (l << 1) + 1, 0 >= l && (l = s); l > s && (l = s), o += r, l += r } else { for (s = r + 1; s > l && a(t, e[i + r - l]) <= 0;)o = l, l = (l << 1) + 1, 0 >= l && (l = s); l > s && (l = s); var u = o; o = r - l, l = r - u } for (o++; l > o;) { var h = o + (l - o >>> 1); a(t, e[i + h]) > 0 ? o = h + 1 : l = h } return l } function Si(t, e, i, n, r, a) { var o = 0, s = 0, l = 1; if (a(t, e[i + r]) < 0) { for (s = r + 1; s > l && a(t, e[i + r - l]) < 0;)o = l, l = (l << 1) + 1, 0 >= l && (l = s); l > s && (l = s); var u = o; o = r - l, l = r - u } else { for (s = n - r; s > l && a(t, e[i + r + l]) >= 0;)o = l, l = (l << 1) + 1, 0 >= l && (l = s); l > s && (l = s), o += r, l += r } for (o++; l > o;) { var h = o + (l - o >>> 1); a(t, e[i + h]) < 0 ? l = h : o = h + 1 } return l } function Mi(t, e) { function i(t, e) { l[c] = t, u[c] = e, c += 1 } function n() { for (; c > 1;) { var t = c - 2; if (t >= 1 && u[t - 1] <= u[t] + u[t + 1] || t >= 2 && u[t - 2] <= u[t] + u[t - 1]) u[t - 1] < u[t + 1] && t--; else if (u[t] > u[t + 1]) break; a(t) } } function r() { for (; c > 1;) { var t = c - 2; t > 0 && u[t - 1] < u[t + 1] && t-- , a(t) } } function a(i) { var n = l[i], r = u[i], a = l[i + 1], h = u[i + 1]; u[i] = r + h, i === c - 3 && (l[i + 1] = l[i + 2], u[i + 1] = u[i + 2]), c--; var d = Si(t[a], t, n, r, 0, e); n += d, r -= d, 0 !== r && (h = wi(t[n + r - 1], t, a, h, h - 1, e), 0 !== h && (h >= r ? o(n, r, a, h) : s(n, r, a, h))) } function o(i, n, r, a) { var o = 0; for (o = 0; n > o; o++)d[o] = t[i + o]; var s = 0, l = r, u = i; if (t[u++] = t[l++], 0 !== --a) { if (1 === n) { for (o = 0; a > o; o++)t[u + o] = t[l + o]; return void (t[u + a] = d[s]) } for (var c, f, p, g = h; ;) { c = 0, f = 0, p = !1; do if (e(t[l], d[s]) < 0) { if (t[u++] = t[l++], f++ , c = 0, 0 === --a) { p = !0; break } } else if (t[u++] = d[s++], c++ , f = 0, 1 === --n) { p = !0; break } while (g > (c | f)); if (p) break; do { if (c = Si(t[l], d, s, n, 0, e), 0 !== c) { for (o = 0; c > o; o++)t[u + o] = d[s + o]; if (u += c, s += c, n -= c, 1 >= n) { p = !0; break } } if (t[u++] = t[l++], 0 === --a) { p = !0; break } if (f = wi(d[s], t, l, a, 0, e), 0 !== f) { for (o = 0; f > o; o++)t[u + o] = t[l + o]; if (u += f, l += f, a -= f, 0 === a) { p = !0; break } } if (t[u++] = d[s++], 1 === --n) { p = !0; break } g-- } while (c >= Jg || f >= Jg); if (p) break; 0 > g && (g = 0), g += 2 } if (h = g, 1 > h && (h = 1), 1 === n) { for (o = 0; a > o; o++)t[u + o] = t[l + o]; t[u + a] = d[s] } else { if (0 === n) throw new Error; for (o = 0; n > o; o++)t[u + o] = d[s + o] } } else for (o = 0; n > o; o++)t[u + o] = d[s + o] } function s(i, n, r, a) { var o = 0; for (o = 0; a > o; o++)d[o] = t[r + o]; var s = i + n - 1, l = a - 1, u = r + a - 1, c = 0, f = 0; if (t[u--] = t[s--], 0 !== --n) { if (1 === a) { for (u -= n, s -= n, f = u + 1, c = s + 1, o = n - 1; o >= 0; o--)t[f + o] = t[c + o]; return void (t[u] = d[l]) } for (var p = h; ;) { var g = 0, m = 0, v = !1; do if (e(d[l], t[s]) < 0) { if (t[u--] = t[s--], g++ , m = 0, 0 === --n) { v = !0; break } } else if (t[u--] = d[l--], m++ , g = 0, 1 === --a) { v = !0; break } while (p > (g | m)); if (v) break; do { if (g = n - Si(d[l], t, i, n, n - 1, e), 0 !== g) { for (u -= g, s -= g, n -= g, f = u + 1, c = s + 1, o = g - 1; o >= 0; o--)t[f + o] = t[c + o]; if (0 === n) { v = !0; break } } if (t[u--] = d[l--], 1 === --a) { v = !0; break } if (m = a - wi(t[s], d, 0, a, a - 1, e), 0 !== m) { for (u -= m, l -= m, a -= m, f = u + 1, c = l + 1, o = 0; m > o; o++)t[f + o] = d[c + o]; if (1 >= a) { v = !0; break } } if (t[u--] = t[s--], 0 === --n) { v = !0; break } p-- } while (g >= Jg || m >= Jg); if (v) break; 0 > p && (p = 0), p += 2 } if (h = p, 1 > h && (h = 1), 1 === a) { for (u -= n, s -= n, f = u + 1, c = s + 1, o = n - 1; o >= 0; o--)t[f + o] = t[c + o]; t[u] = d[l] } else { if (0 === a) throw new Error; for (c = u - (a - 1), o = 0; a > o; o++)t[c + o] = d[o] } } else for (c = u - (a - 1), o = 0; a > o; o++)t[c + o] = d[o] } var l, u, h = Jg, c = 0, d = []; l = [], u = [], this.mergeRuns = n, this.forceMergeRuns = r, this.pushRun = i } function Ii(t, e, i, n) { i || (i = 0), n || (n = t.length); var r = n - i; if (!(2 > r)) { var a = 0; if (Qg > r) return a = xi(t, i, n, e), void bi(t, i, n, i + a, e); var o = new Mi(t, e), s = yi(r); do { if (a = xi(t, i, n, e), s > a) { var l = r; l > s && (l = s), bi(t, i, i + l, i + a, e), a = l } o.pushRun(i, a), o.mergeRuns(), r -= a, i += a } while (0 !== r); o.forceMergeRuns() } } function Di(t, e) { return t.zlevel === e.zlevel ? t.z === e.z ? t.z2 - e.z2 : t.z - e.z : t.zlevel - e.zlevel } function Ti(t, e, i) { var n = null == e.x ? 0 : e.x, r = null == e.x2 ? 1 : e.x2, a = null == e.y ? 0 : e.y, o = null == e.y2 ? 0 : e.y2; e.global || (n = n * i.width + i.x, r = r * i.width + i.x, a = a * i.height + i.y, o = o * i.height + i.y), n = isNaN(n) ? 0 : n, r = isNaN(r) ? 1 : r, a = isNaN(a) ? 0 : a, o = isNaN(o) ? 0 : o; var s = t.createLinearGradient(n, a, r, o); return s } function Ai(t, e, i) { var n = i.width, r = i.height, a = Math.min(n, r), o = null == e.x ? .5 : e.x, s = null == e.y ? .5 : e.y, l = null == e.r ? .5 : e.r; e.global || (o = o * n + i.x, s = s * r + i.y, l *= a); var u = t.createRadialGradient(o, s, 0, o, s, l); return u } function Ci() { return !1 } function ki(t, e, i) { var n = Qp(), r = e.getWidth(), a = e.getHeight(), o = n.style; return o && (o.position = "absolute", o.left = 0, o.top = 0, o.width = r + "px", o.height = a + "px", n.setAttribute("data-zr-dom-id", t)), n.width = r * i, n.height = a * i, n } function Pi(t) { if ("string" == typeof t) { var e = fm.get(t); return e && e.image } return t } function Li(t, e, i, n, r) { if (t) { if ("string" == typeof t) { if (e && e.__zrImageSrc === t || !i) return e; var a = fm.get(t), o = { hostEl: i, cb: n, cbPayload: r }; return a ? (e = a.image, !zi(e) && a.pending.push(o)) : (e = new Image, e.onload = e.onerror = Oi, fm.put(t, e.__cachedImgObj = { image: e, pending: [o] }), e.src = e.__zrImageSrc = t), e } return t } return e } function Oi() { var t = this.__cachedImgObj; this.onload = this.onerror = this.__cachedImgObj = null; for (var e = 0; e < t.pending.length; e++) { var i = t.pending[e], n = i.cb; n && n(this, i.cbPayload), i.hostEl.dirty() } t.pending.length = 0 } function zi(t) { return t && t.width && t.height } function Ei(t, e) { e = e || ym; var i = t + ":" + e; if (pm[i]) return pm[i]; for (var n = (t + "").split("\n"), r = 0, a = 0, o = n.length; o > a; a++)r = Math.max(Yi(n[a], e).width, r); return gm > mm && (gm = 0, pm = {}), gm++ , pm[i] = r, r } function Bi(t, e, i, n, r, a, o, s) { return o ? Ni(t, e, i, n, r, a, o, s) : Ri(t, e, i, n, r, a, s) } function Ri(t, e, i, n, r, a, o) { var s = qi(t, e, r, a, o), l = Ei(t, e); r && (l += r[1] + r[3]); var u = s.outerHeight, h = Fi(0, l, i), c = Vi(0, u, n), d = new vi(h, c, l, u); return d.lineHeight = s.lineHeight, d } function Ni(t, e, i, n, r, a, o, s) { var l = Zi(t, { rich: o, truncate: s, font: e, textAlign: i, textPadding: r, textLineHeight: a }), u = l.outerWidth, h = l.outerHeight, c = Fi(0, u, i), d = Vi(0, h, n); return new vi(c, d, u, h) } function Fi(t, e, i) { return "right" === i ? t -= e : "center" === i && (t -= e / 2), t } function Vi(t, e, i) { return "middle" === i ? t -= e / 2 : "bottom" === i && (t -= e), t } function Gi(t, e, i) { var n = e.x, r = e.y, a = e.height, o = e.width, s = a / 2, l = "left", u = "top"; switch (t) { case "left": n -= i, r += s, l = "right", u = "middle"; break; case "right": n += i + o, r += s, u = "middle"; break; case "top": n += o / 2, r -= i, l = "center", u = "bottom"; break; case "bottom": n += o / 2, r += a + i, l = "center"; break; case "inside": n += o / 2, r += s, l = "center", u = "middle"; break; case "insideLeft": n += i, r += s, u = "middle"; break; case "insideRight": n += o - i, r += s, l = "right", u = "middle"; break; case "insideTop": n += o / 2, r += i, l = "center"; break; case "insideBottom": n += o / 2, r += a - i, l = "center", u = "bottom"; break; case "insideTopLeft": n += i, r += i; break; case "insideTopRight": n += o - i, r += i, l = "right"; break; case "insideBottomLeft": n += i, r += a - i, u = "bottom"; break; case "insideBottomRight": n += o - i, r += a - i, l = "right", u = "bottom" }return { x: n, y: r, textAlign: l, textVerticalAlign: u } } function Hi(t, e, i, n, r) { if (!e) return ""; var a = (t + "").split("\n"); r = Wi(e, i, n, r); for (var o = 0, s = a.length; s > o; o++)a[o] = Xi(a[o], r); return a.join("\n") } function Wi(t, e, i, n) { n = o({}, n), n.font = e; var i = C(i, "..."); n.maxIterations = C(n.maxIterations, 2); var r = n.minChar = C(n.minChar, 0); n.cnCharWidth = Ei("国", e); var a = n.ascCharWidth = Ei("a", e); n.placeholder = C(n.placeholder, ""); for (var s = t = Math.max(0, t - 1), l = 0; r > l && s >= a; l++)s -= a; var u = Ei(i, e); return u > s && (i = "", u = 0), s = t - u, n.ellipsis = i, n.ellipsisWidth = u, n.contentWidth = s, n.containerWidth = t, n } function Xi(t, e) { var i = e.containerWidth, n = e.font, r = e.contentWidth; if (!i) return ""; var a = Ei(t, n); if (i >= a) return t; for (var o = 0; ; o++) { if (r >= a || o >= e.maxIterations) { t += e.ellipsis; break } var s = 0 === o ? Ui(t, r, e.ascCharWidth, e.cnCharWidth) : a > 0 ? Math.floor(t.length * r / a) : 0; t = t.substr(0, s), a = Ei(t, n) } return "" === t && (t = e.placeholder), t } function Ui(t, e, i, n) { for (var r = 0, a = 0, o = t.length; o > a && e > r; a++) { var s = t.charCodeAt(a); r += s >= 0 && 127 >= s ? i : n } return a } function ji(t) { return Ei("国", t) } function Yi(t, e) { return xm.measureText(t, e) } function qi(t, e, i, n, r) { null != t && (t += ""); var a = C(n, ji(e)), o = t ? t.split("\n") : [], s = o.length * a, l = s; if (i && (l += i[0] + i[2]), t && r) { var u = r.outerHeight, h = r.outerWidth; if (null != u && l > u) t = "", o = []; else if (null != h) for (var c = Wi(h - (i ? i[1] + i[3] : 0), e, r.ellipsis, { minChar: r.minChar, placeholder: r.placeholder }), d = 0, f = o.length; f > d; d++)o[d] = Xi(o[d], c) } return { lines: o, height: s, outerHeight: l, lineHeight: a } } function Zi(t, e) { var i = { lines: [], width: 0, height: 0 }; if (null != t && (t += ""), !t) return i; for (var n, r = vm.lastIndex = 0; null != (n = vm.exec(t));) { var a = n.index; a > r && Ki(i, t.substring(r, a)), Ki(i, n[2], n[1]), r = vm.lastIndex } r < t.length && Ki(i, t.substring(r, t.length)); var o = i.lines, s = 0, l = 0, u = [], h = e.textPadding, c = e.truncate, d = c && c.outerWidth, f = c && c.outerHeight; h && (null != d && (d -= h[1] + h[3]), null != f && (f -= h[0] + h[2])); for (var p = 0; p < o.length; p++) { for (var g = o[p], m = 0, v = 0, y = 0; y < g.tokens.length; y++) { var x = g.tokens[y], _ = x.styleName && e.rich[x.styleName] || {}, b = x.textPadding = _.textPadding, w = x.font = _.font || e.font, S = x.textHeight = C(_.textHeight, ji(w)); if (b && (S += b[0] + b[2]), x.height = S, x.lineHeight = k(_.textLineHeight, e.textLineHeight, S), x.textAlign = _ && _.textAlign || e.textAlign, x.textVerticalAlign = _ && _.textVerticalAlign || "middle", null != f && s + x.lineHeight > f) return { lines: [], width: 0, height: 0 }; x.textWidth = Ei(x.text, w); var M = _.textWidth, I = null == M || "auto" === M; if ("string" == typeof M && "%" === M.charAt(M.length - 1)) x.percentWidth = M, u.push(x), M = 0; else { if (I) { M = x.textWidth; var D = _.textBackgroundColor, T = D && D.image; T && (T = Pi(T), zi(T) && (M = Math.max(M, T.width * S / T.height))) } var A = b ? b[1] + b[3] : 0; M += A; var P = null != d ? d - v : null; null != P && M > P && (!I || A > P ? (x.text = "", x.textWidth = M = 0) : (x.text = Hi(x.text, P - A, w, c.ellipsis, { minChar: c.minChar }), x.textWidth = Ei(x.text, w), M = x.textWidth + A)) } v += x.width = M, _ && (m = Math.max(m, x.lineHeight)) } g.width = v, g.lineHeight = m, s += m, l = Math.max(l, v) } i.outerWidth = i.width = C(e.textWidth, l), i.outerHeight = i.height = C(e.textHeight, s), h && (i.outerWidth += h[1] + h[3], i.outerHeight += h[0] + h[2]); for (var p = 0; p < u.length; p++) { var x = u[p], L = x.percentWidth; x.width = parseInt(L, 10) / 100 * l } return i } function Ki(t, e, i) { for (var n = "" === e, r = e.split("\n"), a = t.lines, o = 0; o < r.length; o++) { var s = r[o], l = { styleName: i, text: s, isLineHolder: !s && !n }; if (o) a.push({ tokens: [l] }); else { var u = (a[a.length - 1] || (a[0] = { tokens: [] })).tokens, h = u.length; 1 === h && u[0].isLineHolder ? u[0] = l : (s || !h || n) && u.push(l) } } } function $i(t) { var e = (t.fontSize || t.fontFamily) && [t.fontStyle, t.fontWeight, (t.fontSize || 12) + "px", t.fontFamily || "sans-serif"].join(" "); return e && z(e) || t.textFont || t.font } function Qi(t, e) { var i, n, r, a, o = e.x, s = e.y, l = e.width, u = e.height, h = e.r; 0 > l && (o += l, l = -l), 0 > u && (s += u, u = -u), "number" == typeof h ? i = n = r = a = h : h instanceof Array ? 1 === h.length ? i = n = r = a = h[0] : 2 === h.length ? (i = r = h[0], n = a = h[1]) : 3 === h.length ? (i = h[0], n = a = h[1], r = h[2]) : (i = h[0], n = h[1], r = h[2], a = h[3]) : i = n = r = a = 0; var c; i + n > l && (c = i + n, i *= l / c, n *= l / c), r + a > l && (c = r + a, r *= l / c, a *= l / c), n + r > u && (c = n + r, n *= u / c, r *= u / c), i + a > u && (c = i + a, i *= u / c, a *= u / c), t.moveTo(o + i, s), t.lineTo(o + l - n, s), 0 !== n && t.arc(o + l - n, s + n, n, -Math.PI / 2, 0), t.lineTo(o + l, s + u - r), 0 !== r && t.arc(o + l - r, s + u - r, r, 0, Math.PI / 2), t.lineTo(o + a, s + u), 0 !== a && t.arc(o + a, s + u - a, a, Math.PI / 2, Math.PI), t.lineTo(o, s + i), 0 !== i && t.arc(o + i, s + i, i, Math.PI, 1.5 * Math.PI) } function Ji(t) { return tn(t), f(t.rich, tn), t } function tn(t) { if (t) { t.font = $i(t); var e = t.textAlign; "middle" === e && (e = "center"), t.textAlign = null == e || bm[e] ? e : "left"; var i = t.textVerticalAlign || t.textBaseline; "center" === i && (i = "middle"), t.textVerticalAlign = null == i || wm[i] ? i : "top"; var n = t.textPadding; n && (t.textPadding = L(t.textPadding)) } } function en(t, e, i, n, r, a) { n.rich ? rn(t, e, i, n, r, a) : nn(t, e, i, n, r, a) } function nn(t, e, i, n, r, a) { var o, s = ln(n), l = !1, u = e.__attrCachedBy === nm.PLAIN_TEXT; a !== rm ? (a && (o = a.style, l = !s && u && o), e.__attrCachedBy = s ? nm.NONE : nm.PLAIN_TEXT) : u && (e.__attrCachedBy = nm.NONE); var h = n.font || _m; l && h === (o.font || _m) || (e.font = h); var c = t.__computedFont; t.__styleFont !== h && (t.__styleFont = h, c = t.__computedFont = e.font); var d = n.textPadding, f = n.textLineHeight, p = t.__textCotentBlock; (!p || t.__dirtyText) && (p = t.__textCotentBlock = qi(i, c, d, f, n.truncate)); var g = p.outerHeight, m = p.lines, v = p.lineHeight, y = cn(g, n, r), x = y.baseX, _ = y.baseY, b = y.textAlign || "left", w = y.textVerticalAlign; on(e, n, r, x, _); var S = Vi(_, g, w), M = x, I = S; if (s || d) { var D = Ei(i, c), T = D; d && (T += d[1] + d[3]); var A = Fi(x, T, b); s && un(t, e, n, A, S, T, g), d && (M = mn(x, b, d), I += d[0]) } e.textAlign = b, e.textBaseline = "middle", e.globalAlpha = n.opacity || 1; for (var C = 0; C < Sm.length; C++) { var k = Sm[C], P = k[0], L = k[1], O = n[P]; l && O === o[P] || (e[L] = im(e, L, O || k[2])) } I += v / 2; var z = n.textStrokeWidth, E = l ? o.textStrokeWidth : null, B = !l || z !== E, R = !l || B || n.textStroke !== o.textStroke, N = fn(n.textStroke, z), F = pn(n.textFill); if (N && (B && (e.lineWidth = z), R && (e.strokeStyle = N)), F && (l && n.textFill === o.textFill || (e.fillStyle = F)), 1 === m.length) N && e.strokeText(m[0], M, I), F && e.fillText(m[0], M, I); else for (var C = 0; C < m.length; C++)N && e.strokeText(m[C], M, I), F && e.fillText(m[C], M, I), I += v } function rn(t, e, i, n, r, a) { a !== rm && (e.__attrCachedBy = nm.NONE); var o = t.__textCotentBlock; (!o || t.__dirtyText) && (o = t.__textCotentBlock = Zi(i, n)), an(t, e, o, n, r) } function an(t, e, i, n, r) { var a = i.width, o = i.outerWidth, s = i.outerHeight, l = n.textPadding, u = cn(s, n, r), h = u.baseX, c = u.baseY, d = u.textAlign, f = u.textVerticalAlign; on(e, n, r, h, c); var p = Fi(h, o, d), g = Vi(c, s, f), m = p, v = g; l && (m += l[3], v += l[0]); var y = m + a; ln(n) && un(t, e, n, p, g, o, s); for (var x = 0; x < i.lines.length; x++) { for (var _, b = i.lines[x], w = b.tokens, S = w.length, M = b.lineHeight, I = b.width, D = 0, T = m, A = y, C = S - 1; S > D && (_ = w[D], !_.textAlign || "left" === _.textAlign);)sn(t, e, _, n, M, v, T, "left"), I -= _.width, T += _.width, D++; for (; C >= 0 && (_ = w[C], "right" === _.textAlign);)sn(t, e, _, n, M, v, A, "right"), I -= _.width, A -= _.width, C--; for (T += (a - (T - m) - (y - A) - I) / 2; C >= D;)_ = w[D], sn(t, e, _, n, M, v, T + _.width / 2, "center"), T += _.width, D++; v += M } } function on(t, e, i, n, r) { if (i && e.textRotation) { var a = e.textOrigin; "center" === a ? (n = i.width / 2 + i.x, r = i.height / 2 + i.y) : a && (n = a[0] + i.x, r = a[1] + i.y), t.translate(n, r), t.rotate(-e.textRotation), t.translate(-n, -r) } } function sn(t, e, i, n, r, a, o, s) { var l = n.rich[i.styleName] || {}; l.text = i.text; var u = i.textVerticalAlign, h = a + r / 2; "top" === u ? h = a + i.height / 2 : "bottom" === u && (h = a + r - i.height / 2), !i.isLineHolder && ln(l) && un(t, e, l, "right" === s ? o - i.width : "center" === s ? o - i.width / 2 : o, h - i.height / 2, i.width, i.height); var c = i.textPadding; c && (o = mn(o, s, c), h -= i.height / 2 - c[2] - i.textHeight / 2), dn(e, "shadowBlur", k(l.textShadowBlur, n.textShadowBlur, 0)), dn(e, "shadowColor", l.textShadowColor || n.textShadowColor || "transparent"), dn(e, "shadowOffsetX", k(l.textShadowOffsetX, n.textShadowOffsetX, 0)), dn(e, "shadowOffsetY", k(l.textShadowOffsetY, n.textShadowOffsetY, 0)), dn(e, "textAlign", s), dn(e, "textBaseline", "middle"), dn(e, "font", i.font || _m); var d = fn(l.textStroke || n.textStroke, p), f = pn(l.textFill || n.textFill), p = C(l.textStrokeWidth, n.textStrokeWidth); d && (dn(e, "lineWidth", p), dn(e, "strokeStyle", d), e.strokeText(i.text, o, h)), f && (dn(e, "fillStyle", f), e.fillText(i.text, o, h)) } function ln(t) { return !!(t.textBackgroundColor || t.textBorderWidth && t.textBorderColor) } function un(t, e, i, n, r, a, o) { var s = i.textBackgroundColor, l = i.textBorderWidth, u = i.textBorderColor, h = w(s); if (dn(e, "shadowBlur", i.textBoxShadowBlur || 0), dn(e, "shadowColor", i.textBoxShadowColor || "transparent"), dn(e, "shadowOffsetX", i.textBoxShadowOffsetX || 0), dn(e, "shadowOffsetY", i.textBoxShadowOffsetY || 0), h || l && u) { e.beginPath(); var c = i.textBorderRadius; c ? Qi(e, { x: n, y: r, width: a, height: o, r: c }) : e.rect(n, r, a, o), e.closePath() } if (h) if (dn(e, "fillStyle", s), null != i.fillOpacity) { var d = e.globalAlpha; e.globalAlpha = i.fillOpacity * i.opacity, e.fill(), e.globalAlpha = d } else e.fill(); else if (S(s)) { var f = s.image; f = Li(f, null, t, hn, s), f && zi(f) && e.drawImage(f, n, r, a, o) } if (l && u) if (dn(e, "lineWidth", l), dn(e, "strokeStyle", u), null != i.strokeOpacity) { var d = e.globalAlpha; e.globalAlpha = i.strokeOpacity * i.opacity, e.stroke(), e.globalAlpha = d } else e.stroke() } function hn(t, e) { e.image = t } function cn(t, e, i) { var n = e.x || 0, r = e.y || 0, a = e.textAlign, o = e.textVerticalAlign; if (i) { var s = e.textPosition; if (s instanceof Array) n = i.x + gn(s[0], i.width), r = i.y + gn(s[1], i.height); else { var l = Gi(s, i, e.textDistance); n = l.x, r = l.y, a = a || l.textAlign, o = o || l.textVerticalAlign } var u = e.textOffset; u && (n += u[0], r += u[1]) } return { baseX: n, baseY: r, textAlign: a, textVerticalAlign: o } } function dn(t, e, i) { return t[e] = im(t, e, i), t[e] } function fn(t, e) {
    return null == t || 0 >= e || "transparent" === t || "none" === t ? null : t.image || t.colorStops ? "#000" : t
  } function pn(t) { return null == t || "none" === t ? null : t.image || t.colorStops ? "#000" : t } function gn(t, e) { return "string" == typeof t ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t } function mn(t, e, i) { return "right" === e ? t - i[1] : "center" === e ? t + i[3] / 2 - i[1] / 2 : t + i[3] } function vn(t, e) { return null != t && (t || e.textBackgroundColor || e.textBorderWidth && e.textBorderColor || e.textPadding) } function yn(t) { t = t || {}, Yg.call(this, t); for (var e in t) t.hasOwnProperty(e) && "style" !== e && (this[e] = t[e]); this.style = new om(t.style, this), this._rect = null, this.__clipPaths = [] } function xn(t) { yn.call(this, t) } function _n(t) { return parseInt(t, 10) } function bn(t) { return t ? t.__builtin__ ? !0 : "function" != typeof t.resize || "function" != typeof t.refresh ? !1 : !0 : !1 } function wn(t, e, i) { return km.copy(t.getBoundingRect()), t.transform && km.applyTransform(t.transform), Pm.width = e, Pm.height = i, !km.intersect(Pm) } function Sn(t, e) { if (t === e) return !1; if (!t || !e || t.length !== e.length) return !0; for (var i = 0; i < t.length; i++)if (t[i] !== e[i]) return !0 } function Mn(t, e) { for (var i = 0; i < t.length; i++) { var n = t[i]; n.setTransform(e), e.beginPath(), n.buildPath(e, n.shape), e.clip(), n.restoreTransform(e) } } function In(t, e) { var i = document.createElement("div"); return i.style.cssText = ["position:relative", "overflow:hidden", "width:" + t + "px", "height:" + e + "px", "padding:0", "margin:0", "border-width:0"].join(";") + ";", i } function Dn(t) { return "mousewheel" === t && Gp.browser.firefox ? "DOMMouseScroll" : t } function Tn(t) { t._touching = !0, clearTimeout(t._touchTimer), t._touchTimer = setTimeout(function () { t._touching = !1 }, 700) } function An(t) { var e = t.pointerType; return "pen" === e || "touch" === e } function Cn(t) { function e(t, e) { return function () { return e._touching ? void 0 : t.apply(e, arguments) } } f(Bm, function (e) { t._handlers[e] = y(Fm[e], t) }), f(Nm, function (e) { t._handlers[e] = y(Fm[e], t) }), f(Em, function (i) { t._handlers[i] = e(Fm[i], t) }) } function kn(t) { function e(e, i) { f(e, function (e) { me(t, Dn(e), i._handlers[e]) }, i) } ug.call(this), this.dom = t, this._touching = !1, this._touchTimer, this._handlers = {}, Cn(this), Gp.pointerEventsSupported ? e(Nm, this) : (Gp.touchEventsSupported && e(Bm, this), e(Em, this)) } function Pn(t, e) { var i = new Um(Fp(), t, e); return Wm[i.id] = i, i } function Ln(t) { if (t) t.dispose(); else { for (var e in Wm) Wm.hasOwnProperty(e) && Wm[e].dispose(); Wm = {} } return this } function On(t) { return Wm[t] } function zn(t, e) { Hm[t] = e } function En(t) { delete Wm[t] } function Bn(t) { return t instanceof Array ? t : null == t ? [] : [t] } function Rn(t, e, i) { if (t) { t[e] = t[e] || {}, t.emphasis = t.emphasis || {}, t.emphasis[e] = t.emphasis[e] || {}; for (var n = 0, r = i.length; r > n; n++) { var a = i[n]; !t.emphasis[e].hasOwnProperty(a) && t[e].hasOwnProperty(a) && (t.emphasis[e][a] = t[e][a]) } } } function Nn(t) { return !qm(t) || Zm(t) || t instanceof Date ? t : t.value } function Fn(t) { return qm(t) && !(t instanceof Array) } function Vn(t, e) { e = (e || []).slice(); var i = p(t || [], function (t) { return { exist: t } }); return Ym(e, function (t, n) { if (qm(t)) { for (var r = 0; r < i.length; r++)if (!i[r].option && null != t.id && i[r].exist.id === t.id + "") return i[r].option = t, void (e[n] = null); for (var r = 0; r < i.length; r++) { var a = i[r].exist; if (!(i[r].option || null != a.id && null != t.id || null == t.name || Wn(t) || Wn(a) || a.name !== t.name + "")) return i[r].option = t, void (e[n] = null) } } }), Ym(e, function (t) { if (qm(t)) { for (var e = 0; e < i.length; e++) { var n = i[e].exist; if (!i[e].option && !Wn(n) && null == t.id) { i[e].option = t; break } } e >= i.length && i.push({ option: t }) } }), i } function Gn(t) { var e = N(); Ym(t, function (t) { var i = t.exist; i && e.set(i.id, t) }), Ym(t, function (t) { var i = t.option; O(!i || null == i.id || !e.get(i.id) || e.get(i.id) === t, "id duplicates: " + (i && i.id)), i && null != i.id && e.set(i.id, t), !t.keyInfo && (t.keyInfo = {}) }), Ym(t, function (t, i) { var n = t.exist, r = t.option, a = t.keyInfo; if (qm(r)) { if (a.name = null != r.name ? r.name + "" : n ? n.name : Km + i, n) a.id = n.id; else if (null != r.id) a.id = r.id + ""; else { var o = 0; do a.id = "\x00" + a.name + "\x00" + o++; while (e.get(a.id)) } e.set(a.id, t) } }) } function Hn(t) { var e = t.name; return !(!e || !e.indexOf(Km)) } function Wn(t) { return qm(t) && t.id && 0 === (t.id + "").indexOf("\x00_ec_\x00") } function Xn(t, e) { return null != e.dataIndexInside ? e.dataIndexInside : null != e.dataIndex ? _(e.dataIndex) ? p(e.dataIndex, function (e) { return t.indexOfRawIndex(e) }) : t.indexOfRawIndex(e.dataIndex) : null != e.name ? _(e.name) ? p(e.name, function (e) { return t.indexOfName(e) }) : t.indexOfName(e.name) : void 0 } function Un() { var t = "__\x00ec_inner_" + Qm++ + "_" + Math.random().toFixed(5); return function (e) { return e[t] || (e[t] = {}) } } function jn(t, e, i) { if (w(e)) { var n = {}; n[e + "Index"] = 0, e = n } var r = i && i.defaultMainType; !r || Yn(e, r + "Index") || Yn(e, r + "Id") || Yn(e, r + "Name") || (e[r + "Index"] = 0); var a = {}; return Ym(e, function (n, r) { var n = e[r]; if ("dataIndex" === r || "dataIndexInside" === r) return void (a[r] = n); var o = r.match(/^(\w+)(Index|Id|Name)$/) || [], s = o[1], l = (o[2] || "").toLowerCase(); if (!(!s || !l || null == n || "index" === l && "none" === n || i && i.includeMainTypes && u(i.includeMainTypes, s) < 0)) { var h = { mainType: s }; ("index" !== l || "all" !== n) && (h[l] = n); var c = t.queryComponents(h); a[s + "Models"] = c, a[s + "Model"] = c[0] } }), a } function Yn(t, e) { return t && t.hasOwnProperty(e) } function qn(t, e, i) { t.setAttribute ? t.setAttribute(e, i) : t[e] = i } function Zn(t, e) { return t.getAttribute ? t.getAttribute(e) : t[e] } function Kn(t) { return "auto" === t ? Gp.domSupported ? "html" : "richText" : t || "html" } function $n(t, e) { var i = N(), n = []; return f(t, function (t) { var r = e(t); (i.get(r) || (n.push(r), i.set(r, []))).push(t) }), { keys: n, buckets: i } } function Qn(t) { var e = { main: "", sub: "" }; return t && (t = t.split(Jm), e.main = t[0] || "", e.sub = t[1] || ""), e } function Jn(t) { O(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(t), 'componentType "' + t + '" illegal') } function tr(t) { t.$constructor = t, t.extend = function (t) { var e = this, i = function () { t.$constructor ? t.$constructor.apply(this, arguments) : e.apply(this, arguments) }; return o(i.prototype, t), i.extend = this.extend, i.superCall = ir, i.superApply = nr, h(i, this), i.superClass = e, i } } function er(t) { var e = ["__\x00is_clz", ev++, Math.random().toFixed(3)].join("_"); t.prototype[e] = !0, t.isInstance = function (t) { return !(!t || !t[e]) } } function ir(t, e) { var i = P(arguments, 2); return this.superClass.prototype[e].apply(t, i) } function nr(t, e, i) { return this.superClass.prototype[e].apply(t, i) } function rr(t, e) { function i(t) { var e = n[t.main]; return e && e[tv] || (e = n[t.main] = {}, e[tv] = !0), e } e = e || {}; var n = {}; if (t.registerClass = function (t, e) { if (e) if (Jn(e), e = Qn(e), e.sub) { if (e.sub !== tv) { var r = i(e); r[e.sub] = t } } else n[e.main] = t; return t }, t.getClass = function (t, e, i) { var r = n[t]; if (r && r[tv] && (r = e ? r[e] : null), i && !r) throw new Error(e ? "Component " + t + "." + (e || "") + " not exists. Load it first." : t + ".type should be specified."); return r }, t.getClassesByMainType = function (t) { t = Qn(t); var e = [], i = n[t.main]; return i && i[tv] ? f(i, function (t, i) { i !== tv && e.push(t) }) : e.push(i), e }, t.hasClass = function (t) { return t = Qn(t), !!n[t.main] }, t.getAllClassMainTypes = function () { var t = []; return f(n, function (e, i) { t.push(i) }), t }, t.hasSubTypes = function (t) { t = Qn(t); var e = n[t.main]; return e && e[tv] }, t.parseClassType = Qn, e.registerWhenExtend) { var r = t.extend; r && (t.extend = function (e) { var i = r.call(this, e); return t.registerClass(i, e.type) }) } return t } function ar(t) { return t > -uv && uv > t } function or(t) { return t > uv || -uv > t } function sr(t, e, i, n, r) { var a = 1 - r; return a * a * (a * t + 3 * r * e) + r * r * (r * n + 3 * a * i) } function lr(t, e, i, n, r) { var a = 1 - r; return 3 * (((e - t) * a + 2 * (i - e) * r) * a + (n - i) * r * r) } function ur(t, e, i, n, r, a) { var o = n + 3 * (e - i) - t, s = 3 * (i - 2 * e + t), l = 3 * (e - t), u = t - r, h = s * s - 3 * o * l, c = s * l - 9 * o * u, d = l * l - 3 * s * u, f = 0; if (ar(h) && ar(c)) if (ar(s)) a[0] = 0; else { var p = -l / s; p >= 0 && 1 >= p && (a[f++] = p) } else { var g = c * c - 4 * h * d; if (ar(g)) { var m = c / h, p = -s / o + m, v = -m / 2; p >= 0 && 1 >= p && (a[f++] = p), v >= 0 && 1 >= v && (a[f++] = v) } else if (g > 0) { var y = lv(g), x = h * s + 1.5 * o * (-c + y), _ = h * s + 1.5 * o * (-c - y); x = 0 > x ? -sv(-x, dv) : sv(x, dv), _ = 0 > _ ? -sv(-_, dv) : sv(_, dv); var p = (-s - (x + _)) / (3 * o); p >= 0 && 1 >= p && (a[f++] = p) } else { var b = (2 * h * s - 3 * o * c) / (2 * lv(h * h * h)), w = Math.acos(b) / 3, S = lv(h), M = Math.cos(w), p = (-s - 2 * S * M) / (3 * o), v = (-s + S * (M + cv * Math.sin(w))) / (3 * o), I = (-s + S * (M - cv * Math.sin(w))) / (3 * o); p >= 0 && 1 >= p && (a[f++] = p), v >= 0 && 1 >= v && (a[f++] = v), I >= 0 && 1 >= I && (a[f++] = I) } } return f } function hr(t, e, i, n, r) { var a = 6 * i - 12 * e + 6 * t, o = 9 * e + 3 * n - 3 * t - 9 * i, s = 3 * e - 3 * t, l = 0; if (ar(o)) { if (or(a)) { var u = -s / a; u >= 0 && 1 >= u && (r[l++] = u) } } else { var h = a * a - 4 * o * s; if (ar(h)) r[0] = -a / (2 * o); else if (h > 0) { var c = lv(h), u = (-a + c) / (2 * o), d = (-a - c) / (2 * o); u >= 0 && 1 >= u && (r[l++] = u), d >= 0 && 1 >= d && (r[l++] = d) } } return l } function cr(t, e, i, n, r, a) { var o = (e - t) * r + t, s = (i - e) * r + e, l = (n - i) * r + i, u = (s - o) * r + o, h = (l - s) * r + s, c = (h - u) * r + u; a[0] = t, a[1] = o, a[2] = u, a[3] = c, a[4] = c, a[5] = h, a[6] = l, a[7] = n } function dr(t, e, i, n, r, a, o, s, l, u, h) { var c, d, f, p, g, m = .005, v = 1 / 0; fv[0] = l, fv[1] = u; for (var y = 0; 1 > y; y += .05)pv[0] = sr(t, i, r, o, y), pv[1] = sr(e, n, a, s, y), p = og(fv, pv), v > p && (c = y, v = p); v = 1 / 0; for (var x = 0; 32 > x && !(hv > m); x++)d = c - m, f = c + m, pv[0] = sr(t, i, r, o, d), pv[1] = sr(e, n, a, s, d), p = og(pv, fv), d >= 0 && v > p ? (c = d, v = p) : (gv[0] = sr(t, i, r, o, f), gv[1] = sr(e, n, a, s, f), g = og(gv, fv), 1 >= f && v > g ? (c = f, v = g) : m *= .5); return h && (h[0] = sr(t, i, r, o, c), h[1] = sr(e, n, a, s, c)), lv(v) } function fr(t, e, i, n) { var r = 1 - n; return r * (r * t + 2 * n * e) + n * n * i } function pr(t, e, i, n) { return 2 * ((1 - n) * (e - t) + n * (i - e)) } function gr(t, e, i, n, r) { var a = t - 2 * e + i, o = 2 * (e - t), s = t - n, l = 0; if (ar(a)) { if (or(o)) { var u = -s / o; u >= 0 && 1 >= u && (r[l++] = u) } } else { var h = o * o - 4 * a * s; if (ar(h)) { var u = -o / (2 * a); u >= 0 && 1 >= u && (r[l++] = u) } else if (h > 0) { var c = lv(h), u = (-o + c) / (2 * a), d = (-o - c) / (2 * a); u >= 0 && 1 >= u && (r[l++] = u), d >= 0 && 1 >= d && (r[l++] = d) } } return l } function mr(t, e, i) { var n = t + i - 2 * e; return 0 === n ? .5 : (t - e) / n } function vr(t, e, i, n, r) { var a = (e - t) * n + t, o = (i - e) * n + e, s = (o - a) * n + a; r[0] = t, r[1] = a, r[2] = s, r[3] = s, r[4] = o, r[5] = i } function yr(t, e, i, n, r, a, o, s, l) { var u, h = .005, c = 1 / 0; fv[0] = o, fv[1] = s; for (var d = 0; 1 > d; d += .05) { pv[0] = fr(t, i, r, d), pv[1] = fr(e, n, a, d); var f = og(fv, pv); c > f && (u = d, c = f) } c = 1 / 0; for (var p = 0; 32 > p && !(hv > h); p++) { var g = u - h, m = u + h; pv[0] = fr(t, i, r, g), pv[1] = fr(e, n, a, g); var f = og(pv, fv); if (g >= 0 && c > f) u = g, c = f; else { gv[0] = fr(t, i, r, m), gv[1] = fr(e, n, a, m); var v = og(gv, fv); 1 >= m && c > v ? (u = m, c = v) : h *= .5 } } return l && (l[0] = fr(t, i, r, u), l[1] = fr(e, n, a, u)), lv(c) } function xr(t, e, i) { if (0 !== t.length) { var n, r = t[0], a = r[0], o = r[0], s = r[1], l = r[1]; for (n = 1; n < t.length; n++)r = t[n], a = mv(a, r[0]), o = vv(o, r[0]), s = mv(s, r[1]), l = vv(l, r[1]); e[0] = a, e[1] = s, i[0] = o, i[1] = l } } function _r(t, e, i, n, r, a) { r[0] = mv(t, i), r[1] = mv(e, n), a[0] = vv(t, i), a[1] = vv(e, n) } function br(t, e, i, n, r, a, o, s, l, u) { var h, c = hr, d = sr, f = c(t, i, r, o, Mv); for (l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0, h = 0; f > h; h++) { var p = d(t, i, r, o, Mv[h]); l[0] = mv(p, l[0]), u[0] = vv(p, u[0]) } for (f = c(e, n, a, s, Iv), h = 0; f > h; h++) { var g = d(e, n, a, s, Iv[h]); l[1] = mv(g, l[1]), u[1] = vv(g, u[1]) } l[0] = mv(t, l[0]), u[0] = vv(t, u[0]), l[0] = mv(o, l[0]), u[0] = vv(o, u[0]), l[1] = mv(e, l[1]), u[1] = vv(e, u[1]), l[1] = mv(s, l[1]), u[1] = vv(s, u[1]) } function wr(t, e, i, n, r, a, o, s) { var l = mr, u = fr, h = vv(mv(l(t, i, r), 1), 0), c = vv(mv(l(e, n, a), 1), 0), d = u(t, i, r, h), f = u(e, n, a, c); o[0] = mv(t, r, d), o[1] = mv(e, a, f), s[0] = vv(t, r, d), s[1] = vv(e, a, f) } function Sr(t, e, i, n, r, a, o, s, l) { var u = oe, h = se, c = Math.abs(r - a); if (1e-4 > c % _v && c > 1e-4) return s[0] = t - i, s[1] = e - n, l[0] = t + i, void (l[1] = e + n); if (bv[0] = xv(r) * i + t, bv[1] = yv(r) * n + e, wv[0] = xv(a) * i + t, wv[1] = yv(a) * n + e, u(s, bv, wv), h(l, bv, wv), r %= _v, 0 > r && (r += _v), a %= _v, 0 > a && (a += _v), r > a && !o ? a += _v : a > r && o && (r += _v), o) { var d = a; a = r, r = d } for (var f = 0; a > f; f += Math.PI / 2)f > r && (Sv[0] = xv(f) * i + t, Sv[1] = yv(f) * n + e, u(s, Sv, s), h(l, Sv, l)) } function Mr(t, e, i, n, r, a, o) { if (0 === r) return !1; var s = r, l = 0, u = t; if (o > e + s && o > n + s || e - s > o && n - s > o || a > t + s && a > i + s || t - s > a && i - s > a) return !1; if (t === i) return Math.abs(a - t) <= s / 2; l = (e - n) / (t - i), u = (t * n - i * e) / (t - i); var h = l * a - o + u, c = h * h / (l * l + 1); return s / 2 * s / 2 >= c } function Ir(t, e, i, n, r, a, o, s, l, u, h) { if (0 === l) return !1; var c = l; if (h > e + c && h > n + c && h > a + c && h > s + c || e - c > h && n - c > h && a - c > h && s - c > h || u > t + c && u > i + c && u > r + c && u > o + c || t - c > u && i - c > u && r - c > u && o - c > u) return !1; var d = dr(t, e, i, n, r, a, o, s, u, h, null); return c / 2 >= d } function Dr(t, e, i, n, r, a, o, s, l) { if (0 === o) return !1; var u = o; if (l > e + u && l > n + u && l > a + u || e - u > l && n - u > l && a - u > l || s > t + u && s > i + u && s > r + u || t - u > s && i - u > s && r - u > s) return !1; var h = yr(t, e, i, n, r, a, s, l, null); return u / 2 >= h } function Tr(t) { return t %= Fv, 0 > t && (t += Fv), t } function Ar(t, e, i, n, r, a, o, s, l) { if (0 === o) return !1; var u = o; s -= t, l -= e; var h = Math.sqrt(s * s + l * l); if (h - u > i || i > h + u) return !1; if (Math.abs(n - r) % Vv < 1e-4) return !0; if (a) { var c = n; n = Tr(r), r = Tr(c) } else n = Tr(n), r = Tr(r); n > r && (r += Vv); var d = Math.atan2(l, s); return 0 > d && (d += Vv), d >= n && r >= d || d + Vv >= n && r >= d + Vv } function Cr(t, e, i, n, r, a) { if (a > e && a > n || e > a && n > a) return 0; if (n === e) return 0; var o = e > n ? 1 : -1, s = (a - e) / (n - e); (1 === s || 0 === s) && (o = e > n ? .5 : -.5); var l = s * (i - t) + t; return l === r ? 1 / 0 : l > r ? o : 0 } function kr(t, e) { return Math.abs(t - e) < Wv } function Pr() { var t = Uv[0]; Uv[0] = Uv[1], Uv[1] = t } function Lr(t, e, i, n, r, a, o, s, l, u) { if (u > e && u > n && u > a && u > s || e > u && n > u && a > u && s > u) return 0; var h = ur(e, n, a, s, u, Xv); if (0 === h) return 0; for (var c, d, f = 0, p = -1, g = 0; h > g; g++) { var m = Xv[g], v = 0 === m || 1 === m ? .5 : 1, y = sr(t, i, r, o, m); l > y || (0 > p && (p = hr(e, n, a, s, Uv), Uv[1] < Uv[0] && p > 1 && Pr(), c = sr(e, n, a, s, Uv[0]), p > 1 && (d = sr(e, n, a, s, Uv[1]))), f += 2 === p ? m < Uv[0] ? e > c ? v : -v : m < Uv[1] ? c > d ? v : -v : d > s ? v : -v : m < Uv[0] ? e > c ? v : -v : c > s ? v : -v) } return f } function Or(t, e, i, n, r, a, o, s) { if (s > e && s > n && s > a || e > s && n > s && a > s) return 0; var l = gr(e, n, a, s, Xv); if (0 === l) return 0; var u = mr(e, n, a); if (u >= 0 && 1 >= u) { for (var h = 0, c = fr(e, n, a, u), d = 0; l > d; d++) { var f = 0 === Xv[d] || 1 === Xv[d] ? .5 : 1, p = fr(t, i, r, Xv[d]); o > p || (h += Xv[d] < u ? e > c ? f : -f : c > a ? f : -f) } return h } var f = 0 === Xv[0] || 1 === Xv[0] ? .5 : 1, p = fr(t, i, r, Xv[0]); return o > p ? 0 : e > a ? f : -f } function zr(t, e, i, n, r, a, o, s) { if (s -= e, s > i || -i > s) return 0; var l = Math.sqrt(i * i - s * s); Xv[0] = -l, Xv[1] = l; var u = Math.abs(n - r); if (1e-4 > u) return 0; if (1e-4 > u % Hv) { n = 0, r = Hv; var h = a ? 1 : -1; return o >= Xv[0] + t && o <= Xv[1] + t ? h : 0 } if (a) { var l = n; n = Tr(r), r = Tr(l) } else n = Tr(n), r = Tr(r); n > r && (r += Hv); for (var c = 0, d = 0; 2 > d; d++) { var f = Xv[d]; if (f + t > o) { var p = Math.atan2(s, f), h = a ? 1 : -1; 0 > p && (p = Hv + p), (p >= n && r >= p || p + Hv >= n && r >= p + Hv) && (p > Math.PI / 2 && p < 1.5 * Math.PI && (h = -h), c += h) } } return c } function Er(t, e, i, n, r) { for (var a = 0, o = 0, s = 0, l = 0, u = 0, h = 0; h < t.length;) { var c = t[h++]; switch (c === Gv.M && h > 1 && (i || (a += Cr(o, s, l, u, n, r))), 1 === h && (o = t[h], s = t[h + 1], l = o, u = s), c) { case Gv.M: l = t[h++], u = t[h++], o = l, s = u; break; case Gv.L: if (i) { if (Mr(o, s, t[h], t[h + 1], e, n, r)) return !0 } else a += Cr(o, s, t[h], t[h + 1], n, r) || 0; o = t[h++], s = t[h++]; break; case Gv.C: if (i) { if (Ir(o, s, t[h++], t[h++], t[h++], t[h++], t[h], t[h + 1], e, n, r)) return !0 } else a += Lr(o, s, t[h++], t[h++], t[h++], t[h++], t[h], t[h + 1], n, r) || 0; o = t[h++], s = t[h++]; break; case Gv.Q: if (i) { if (Dr(o, s, t[h++], t[h++], t[h], t[h + 1], e, n, r)) return !0 } else a += Or(o, s, t[h++], t[h++], t[h], t[h + 1], n, r) || 0; o = t[h++], s = t[h++]; break; case Gv.A: var d = t[h++], f = t[h++], p = t[h++], g = t[h++], m = t[h++], v = t[h++]; h += 1; var y = 1 - t[h++], x = Math.cos(m) * p + d, _ = Math.sin(m) * g + f; h > 1 ? a += Cr(o, s, x, _, n, r) : (l = x, u = _); var b = (n - d) * g / p + d; if (i) { if (Ar(d, f, g, m, m + v, y, e, b, r)) return !0 } else a += zr(d, f, g, m, m + v, y, b, r); o = Math.cos(m + v) * p + d, s = Math.sin(m + v) * g + f; break; case Gv.R: l = o = t[h++], u = s = t[h++]; var w = t[h++], S = t[h++], x = l + w, _ = u + S; if (i) { if (Mr(l, u, x, u, e, n, r) || Mr(x, u, x, _, e, n, r) || Mr(x, _, l, _, e, n, r) || Mr(l, _, l, u, e, n, r)) return !0 } else a += Cr(x, u, x, _, n, r), a += Cr(l, _, l, u, n, r); break; case Gv.Z: if (i) { if (Mr(o, s, l, u, e, n, r)) return !0 } else a += Cr(o, s, l, u, n, r); o = l, s = u } } return i || kr(s, u) || (a += Cr(o, s, l, u, n, r) || 0), 0 !== a } function Br(t, e, i) { return Er(t, 0, !1, e, i) } function Rr(t, e, i, n) { return Er(t, e, !0, i, n) } function Nr(t) { yn.call(this, t), this.path = null } function Fr(t, e, i, n, r, a, o, s, l, u, h) { var c = l * (ny / 180), d = iy(c) * (t - i) / 2 + ey(c) * (e - n) / 2, f = -1 * ey(c) * (t - i) / 2 + iy(c) * (e - n) / 2, p = d * d / (o * o) + f * f / (s * s); p > 1 && (o *= ty(p), s *= ty(p)); var g = (r === a ? -1 : 1) * ty((o * o * s * s - o * o * f * f - s * s * d * d) / (o * o * f * f + s * s * d * d)) || 0, m = g * o * f / s, v = g * -s * d / o, y = (t + i) / 2 + iy(c) * m - ey(c) * v, x = (e + n) / 2 + ey(c) * m + iy(c) * v, _ = oy([1, 0], [(d - m) / o, (f - v) / s]), b = [(d - m) / o, (f - v) / s], w = [(-1 * d - m) / o, (-1 * f - v) / s], S = oy(b, w); ay(b, w) <= -1 && (S = ny), ay(b, w) >= 1 && (S = 0), 0 === a && S > 0 && (S -= 2 * ny), 1 === a && 0 > S && (S += 2 * ny), h.addData(u, y, x, o, s, _, S, c, a) } function Vr(t) { if (!t) return new Nv; for (var e, i = 0, n = 0, r = i, a = n, o = new Nv, s = Nv.CMD, l = t.match(sy), u = 0; u < l.length; u++) { for (var h, c = l[u], d = c.charAt(0), f = c.match(ly) || [], p = f.length, g = 0; p > g; g++)f[g] = parseFloat(f[g]); for (var m = 0; p > m;) { var v, y, x, _, b, w, S, M = i, I = n; switch (d) { case "l": i += f[m++], n += f[m++], h = s.L, o.addData(h, i, n); break; case "L": i = f[m++], n = f[m++], h = s.L, o.addData(h, i, n); break; case "m": i += f[m++], n += f[m++], h = s.M, o.addData(h, i, n), r = i, a = n, d = "l"; break; case "M": i = f[m++], n = f[m++], h = s.M, o.addData(h, i, n), r = i, a = n, d = "L"; break; case "h": i += f[m++], h = s.L, o.addData(h, i, n); break; case "H": i = f[m++], h = s.L, o.addData(h, i, n); break; case "v": n += f[m++], h = s.L, o.addData(h, i, n); break; case "V": n = f[m++], h = s.L, o.addData(h, i, n); break; case "C": h = s.C, o.addData(h, f[m++], f[m++], f[m++], f[m++], f[m++], f[m++]), i = f[m - 2], n = f[m - 1]; break; case "c": h = s.C, o.addData(h, f[m++] + i, f[m++] + n, f[m++] + i, f[m++] + n, f[m++] + i, f[m++] + n), i += f[m - 2], n += f[m - 1]; break; case "S": v = i, y = n; var D = o.len(), T = o.data; e === s.C && (v += i - T[D - 4], y += n - T[D - 3]), h = s.C, M = f[m++], I = f[m++], i = f[m++], n = f[m++], o.addData(h, v, y, M, I, i, n); break; case "s": v = i, y = n; var D = o.len(), T = o.data; e === s.C && (v += i - T[D - 4], y += n - T[D - 3]), h = s.C, M = i + f[m++], I = n + f[m++], i += f[m++], n += f[m++], o.addData(h, v, y, M, I, i, n); break; case "Q": M = f[m++], I = f[m++], i = f[m++], n = f[m++], h = s.Q, o.addData(h, M, I, i, n); break; case "q": M = f[m++] + i, I = f[m++] + n, i += f[m++], n += f[m++], h = s.Q, o.addData(h, M, I, i, n); break; case "T": v = i, y = n; var D = o.len(), T = o.data; e === s.Q && (v += i - T[D - 4], y += n - T[D - 3]), i = f[m++], n = f[m++], h = s.Q, o.addData(h, v, y, i, n); break; case "t": v = i, y = n; var D = o.len(), T = o.data; e === s.Q && (v += i - T[D - 4], y += n - T[D - 3]), i += f[m++], n += f[m++], h = s.Q, o.addData(h, v, y, i, n); break; case "A": x = f[m++], _ = f[m++], b = f[m++], w = f[m++], S = f[m++], M = i, I = n, i = f[m++], n = f[m++], h = s.A, Fr(M, I, i, n, w, S, x, _, b, h, o); break; case "a": x = f[m++], _ = f[m++], b = f[m++], w = f[m++], S = f[m++], M = i, I = n, i += f[m++], n += f[m++], h = s.A, Fr(M, I, i, n, w, S, x, _, b, h, o) } } ("z" === d || "Z" === d) && (h = s.Z, o.addData(h), i = r, n = a), e = h } return o.toStatic(), o } function Gr(t, e) { var i = Vr(t); return e = e || {}, e.buildPath = function (t) { if (t.setData) { t.setData(i.data); var e = t.getContext(); e && t.rebuildPath(e) } else { var e = t; i.rebuildPath(e) } }, e.applyTransform = function (t) { Jv(i, t), this.dirty(!0) }, e } function Hr(t, e) { return new Nr(Gr(t, e)) } function Wr(t, e) { return Nr.extend(Gr(t, e)) } function Xr(t, e) { for (var i = [], n = t.length, r = 0; n > r; r++) { var a = t[r]; a.path || a.createPathProxy(), a.__dirtyPath && a.buildPath(a.path, a.shape, !0), i.push(a.path) } var o = new Nr(e); return o.createPathProxy(), o.buildPath = function (t) { t.appendPath(i); var e = t.getContext(); e && t.rebuildPath(e) }, o } function Ur(t, e, i, n, r, a, o) { var s = .5 * (i - t), l = .5 * (n - e); return (2 * (e - i) + s + l) * o + (-3 * (e - i) - 2 * s - l) * a + s * r + e } function jr(t, e, i) { var n = e.points, r = e.smooth; if (n && n.length >= 2) { if (r && "spline" !== r) { var a = my(n, r, i, e.smoothConstraint); t.moveTo(n[0][0], n[0][1]); for (var o = n.length, s = 0; (i ? o : o - 1) > s; s++) { var l = a[2 * s], u = a[2 * s + 1], h = n[(s + 1) % o]; t.bezierCurveTo(l[0], l[1], u[0], u[1], h[0], h[1]) } } else { "spline" === r && (n = gy(n, i)), t.moveTo(n[0][0], n[0][1]); for (var s = 1, c = n.length; c > s; s++)t.lineTo(n[s][0], n[s][1]) } i && t.closePath() } } function Yr(t, e, i) { var n = i && i.lineWidth; if (e && n) { var r = e.x1, a = e.x2, o = e.y1, s = e.y2; xy(2 * r) === xy(2 * a) ? t.x1 = t.x2 = Zr(r, n, !0) : (t.x1 = r, t.x2 = a), xy(2 * o) === xy(2 * s) ? t.y1 = t.y2 = Zr(o, n, !0) : (t.y1 = o, t.y2 = s) } } function qr(t, e, i) { var n = i && i.lineWidth; if (e && n) { var r = e.x, a = e.y, o = e.width, s = e.height; t.x = Zr(r, n, !0), t.y = Zr(a, n, !0), t.width = Math.max(Zr(r + o, n, !1) - t.x, 0 === o ? 0 : 1), t.height = Math.max(Zr(a + s, n, !1) - t.y, 0 === s ? 0 : 1) } } function Zr(t, e, i) { var n = xy(2 * t); return (n + xy(e)) % 2 === 0 ? n / 2 : (n + (i ? 1 : -1)) / 2 } function Kr(t, e, i) { var n = t.cpx2, r = t.cpy2; return null === n || null === r ? [(i ? lr : sr)(t.x1, t.cpx1, t.cpx2, t.x2, e), (i ? lr : sr)(t.y1, t.cpy1, t.cpy2, t.y2, e)] : [(i ? pr : fr)(t.x1, t.cpx1, t.x2, e), (i ? pr : fr)(t.y1, t.cpy1, t.y2, e)] } function $r(t) { yn.call(this, t), this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.notClear = !0 } function Qr(t) { return Nr.extend(t) } function Jr(t, e) { return Wr(t, e) } function ta(t, e, i, n) { var r = Hr(t, e); return i && ("center" === n && (i = ia(i, r.getBoundingRect())), na(r, i)), r } function ea(t, e, i) { var n = new xn({ style: { image: t, x: e.x, y: e.y, width: e.width, height: e.height }, onload: function (t) { if ("center" === i) { var r = { width: t.width, height: t.height }; n.setStyle(ia(e, r)) } } }); return n } function ia(t, e) { var i, n = e.width / e.height, r = t.height * n; r <= t.width ? i = t.height : (r = t.width, i = r / n); var a = t.x + t.width / 2, o = t.y + t.height / 2; return { x: a - r / 2, y: o - i / 2, width: r, height: i } } function na(t, e) { if (t.applyTransform) { var i = t.getBoundingRect(), n = i.calculateTransform(e); t.applyTransform(n) } } function ra(t) { var e = t.shape, i = t.style.lineWidth; return Ly(2 * e.x1) === Ly(2 * e.x2) && (e.x1 = e.x2 = oa(e.x1, i, !0)), Ly(2 * e.y1) === Ly(2 * e.y2) && (e.y1 = e.y2 = oa(e.y1, i, !0)), t } function aa(t) { var e = t.shape, i = t.style.lineWidth, n = e.x, r = e.y, a = e.width, o = e.height; return e.x = oa(e.x, i, !0), e.y = oa(e.y, i, !0), e.width = Math.max(oa(n + a, i, !1) - e.x, 0 === a ? 0 : 1), e.height = Math.max(oa(r + o, i, !1) - e.y, 0 === o ? 0 : 1), t } function oa(t, e, i) { var n = Ly(2 * t); return (n + Ly(e)) % 2 === 0 ? n / 2 : (n + (i ? 1 : -1)) / 2 } function sa(t) { return null != t && "none" !== t } function la(t) { if ("string" != typeof t) return t; var e = Ny.get(t); return e || (e = qe(t, -.1), 1e4 > Fy && (Ny.set(t, e), Fy++)), e } function ua(t) { if (t.__hoverStlDirty) { t.__hoverStlDirty = !1; var e = t.__hoverStl; if (!e) return void (t.__cachedNormalStl = t.__cachedNormalZ2 = null); var i = t.__cachedNormalStl = {}; t.__cachedNormalZ2 = t.z2; var n = t.style; for (var r in e) null != e[r] && (i[r] = n[r]); i.fill = n.fill, i.stroke = n.stroke } } function ha(t) { var e = t.__hoverStl; if (e && !t.__highlighted) { var i = t.useHoverLayer; t.__highlighted = i ? "layer" : "plain"; var n = t.__zr; if (n || !i) { var r = t, a = t.style; i && (r = n.addHover(t), a = r.style), ka(a), i || ua(r), a.extendFrom(e), ca(a, e, "fill"), ca(a, e, "stroke"), Ca(a), i || (t.dirty(!1), t.z2 += By) } } } function ca(t, e, i) { !sa(e[i]) && sa(t[i]) && (t[i] = la(t[i])) } function da(t) { var e = t.__highlighted; if (e) if (t.__highlighted = !1, "layer" === e) t.__zr && t.__zr.removeHover(t); else if (e) { var i = t.style, n = t.__cachedNormalStl; n && (ka(i), t.setStyle(n), Ca(i)); var r = t.__cachedNormalZ2; null != r && t.z2 - r === By && (t.z2 = r) } } function fa(t, e) { t.isGroup ? t.traverse(function (t) { !t.isGroup && e(t) }) : e(t) } function pa(t, e) { e = t.__hoverStl = e !== !1 && (e || {}), t.__hoverStlDirty = !0, t.__highlighted && (t.__cachedNormalStl = null, da(t), ha(t)) } function ga(t) { return t && t.__isEmphasisEntered } function ma(t) { this.__hoverSilentOnTouch && t.zrByTouch || !this.__isEmphasisEntered && fa(this, ha) } function va(t) { this.__hoverSilentOnTouch && t.zrByTouch || !this.__isEmphasisEntered && fa(this, da) } function ya() { this.__isEmphasisEntered = !0, fa(this, ha) } function xa() { this.__isEmphasisEntered = !1, fa(this, da) } function _a(t, e, i) { t.isGroup ? t.traverse(function (t) { !t.isGroup && pa(t, t.hoverStyle || e) }) : pa(t, t.hoverStyle || e), ba(t, i) } function ba(t, e) { var i = e === !1; if (t.__hoverSilentOnTouch = null != e && e.hoverSilentOnTouch, !i || t.__hoverStyleTrigger) { var n = i ? "off" : "on"; t[n]("mouseover", ma)[n]("mouseout", va), t[n]("emphasis", ya)[n]("normal", xa), t.__hoverStyleTrigger = !i } } function wa(t, e, i, n, r, a, o) { r = r || Ey; var s, l = r.labelFetcher, u = r.labelDataIndex, h = r.labelDimIndex, c = i.getShallow("show"), d = n.getShallow("show"); (c || d) && (l && (s = l.getFormattedLabel(u, "normal", null, h)), null == s && (s = b(r.defaultText) ? r.defaultText(u, r) : r.defaultText)); var f = c ? s : null, p = d ? C(l ? l.getFormattedLabel(u, "emphasis", null, h) : null, s) : null; (null != f || null != p) && (Sa(t, i, a, r), Sa(e, n, o, r, !0)), t.text = f, e.text = p } function Sa(t, e, i, n, r) { return Ia(t, e, n, r), i && o(t, i), t } function Ma(t, e, i) { var n, r = { isRectText: !0 }; i === !1 ? n = !0 : r.autoColor = i, Ia(t, e, r, n) } function Ia(t, e, i, n) { if (i = i || Ey, i.isRectText) { var r = e.getShallow("position") || (n ? null : "inside"); "outside" === r && (r = "top"), t.textPosition = r, t.textOffset = e.getShallow("offset"); var a = e.getShallow("rotate"); null != a && (a *= Math.PI / 180), t.textRotation = a, t.textDistance = C(e.getShallow("distance"), n ? null : 5) } var o, s = e.ecModel, l = s && s.option.textStyle, u = Da(e); if (u) { o = {}; for (var h in u) if (u.hasOwnProperty(h)) { var c = e.getModel(["rich", h]); Ta(o[h] = {}, c, l, i, n) } } return t.rich = o, Ta(t, e, l, i, n, !0), i.forceRich && !i.textStyle && (i.textStyle = {}), t } function Da(t) { for (var e; t && t !== t.ecModel;) { var i = (t.option || Ey).rich; if (i) { e = e || {}; for (var n in i) i.hasOwnProperty(n) && (e[n] = 1) } t = t.parentModel } return e } function Ta(t, e, i, n, r, a) { i = !r && i || Ey, t.textFill = Aa(e.getShallow("color"), n) || i.color, t.textStroke = Aa(e.getShallow("textBorderColor"), n) || i.textBorderColor, t.textStrokeWidth = C(e.getShallow("textBorderWidth"), i.textBorderWidth), t.insideRawTextPosition = t.textPosition, r || (a && (t.insideRollbackOpt = n, Ca(t)), null == t.textFill && (t.textFill = n.autoColor)), t.fontStyle = e.getShallow("fontStyle") || i.fontStyle, t.fontWeight = e.getShallow("fontWeight") || i.fontWeight, t.fontSize = e.getShallow("fontSize") || i.fontSize, t.fontFamily = e.getShallow("fontFamily") || i.fontFamily, t.textAlign = e.getShallow("align"), t.textVerticalAlign = e.getShallow("verticalAlign") || e.getShallow("baseline"), t.textLineHeight = e.getShallow("lineHeight"), t.textWidth = e.getShallow("width"), t.textHeight = e.getShallow("height"), t.textTag = e.getShallow("tag"), a && n.disableBox || (t.textBackgroundColor = Aa(e.getShallow("backgroundColor"), n), t.textPadding = e.getShallow("padding"), t.textBorderColor = Aa(e.getShallow("borderColor"), n), t.textBorderWidth = e.getShallow("borderWidth"), t.textBorderRadius = e.getShallow("borderRadius"), t.textBoxShadowColor = e.getShallow("shadowColor"), t.textBoxShadowBlur = e.getShallow("shadowBlur"), t.textBoxShadowOffsetX = e.getShallow("shadowOffsetX"), t.textBoxShadowOffsetY = e.getShallow("shadowOffsetY")), t.textShadowColor = e.getShallow("textShadowColor") || i.textShadowColor, t.textShadowBlur = e.getShallow("textShadowBlur") || i.textShadowBlur, t.textShadowOffsetX = e.getShallow("textShadowOffsetX") || i.textShadowOffsetX, t.textShadowOffsetY = e.getShallow("textShadowOffsetY") || i.textShadowOffsetY } function Aa(t, e) { return "auto" !== t ? t : e && e.autoColor ? e.autoColor : null } function Ca(t) { var e = t.insideRollbackOpt; if (e && null == t.textFill) { var i, n = e.useInsideStyle, r = t.insideRawTextPosition, a = e.autoColor; n !== !1 && (n === !0 || e.isRectText && r && "string" == typeof r && r.indexOf("inside") >= 0) ? (i = { textFill: null, textStroke: t.textStroke, textStrokeWidth: t.textStrokeWidth }, t.textFill = "#fff", null == t.textStroke && (t.textStroke = a, null == t.textStrokeWidth && (t.textStrokeWidth = 2))) : null != a && (i = { textFill: null }, t.textFill = a), i && (t.insideRollback = i) } } function ka(t) { var e = t.insideRollback; e && (t.textFill = e.textFill, t.textStroke = e.textStroke, t.textStrokeWidth = e.textStrokeWidth, t.insideRollback = null) } function Pa(t, e) { var i = e || e.getModel("textStyle"); return z([t.fontStyle || i && i.getShallow("fontStyle") || "", t.fontWeight || i && i.getShallow("fontWeight") || "", (t.fontSize || i && i.getShallow("fontSize") || 12) + "px", t.fontFamily || i && i.getShallow("fontFamily") || "sans-serif"].join(" ")) } function La(t, e, i, n, r, a) { "function" == typeof r && (a = r, r = null); var o = n && n.isAnimationEnabled(); if (o) { var s = t ? "Update" : "", l = n.getShallow("animationDuration" + s), u = n.getShallow("animationEasing" + s), h = n.getShallow("animationDelay" + s); "function" == typeof h && (h = h(r, n.getAnimationDelayParams ? n.getAnimationDelayParams(e, r) : null)), "function" == typeof l && (l = l(r)), l > 0 ? e.animateTo(i, l, h || 0, u, a, !!a) : (e.stopAnimation(), e.attr(i), a && a()) } else e.stopAnimation(), e.attr(i), a && a() } function Oa(t, e, i, n, r) { La(!0, t, e, i, n, r) } function za(t, e, i, n, r) { La(!1, t, e, i, n, r) } function Ea(t, e) { for (var i = Ie([]); t && t !== e;)Te(i, t.getLocalTransform(), i), t = t.parent; return i } function Ba(t, e, i) { return e && !d(e) && (e = wg.getLocalTransform(e)), i && (e = Pe([], e)), ae([], t, e) } function Ra(t, e, i) { var n = 0 === e[4] || 0 === e[5] || 0 === e[0] ? 1 : Math.abs(2 * e[4] / e[0]), r = 0 === e[4] || 0 === e[5] || 0 === e[2] ? 1 : Math.abs(2 * e[4] / e[2]), a = ["left" === t ? -n : "right" === t ? n : 0, "top" === t ? -r : "bottom" === t ? r : 0]; return a = Ba(a, e, i), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top" } function Na(t, e, i) { function n(t) { var e = {}; return t.traverse(function (t) { !t.isGroup && t.anid && (e[t.anid] = t) }), e } function r(t) { var e = { position: W(t.position), rotation: t.rotation }; return t.shape && (e.shape = o({}, t.shape)), e } if (t && e) { var a = n(t); e.traverse(function (t) { if (!t.isGroup && t.anid) { var e = a[t.anid]; if (e) { var n = r(t); t.attr(r(e)), Oa(t, n, i, t.dataIndex) } } }) } } function Fa(t, e) { return p(t, function (t) { var i = t[0]; i = Oy(i, e.x), i = zy(i, e.x + e.width); var n = t[1]; return n = Oy(n, e.y), n = zy(n, e.y + e.height), [i, n] }) } function Va(t, e) { var i = Oy(t.x, e.x), n = zy(t.x + t.width, e.x + e.width), r = Oy(t.y, e.y), a = zy(t.y + t.height, e.y + e.height); return n >= i && a >= r ? { x: i, y: r, width: n - i, height: a - r } : void 0 } function Ga(t, e, i) { e = o({ rectHover: !0 }, e); var n = e.style = { strokeNoScale: !0 }; return i = i || { x: -1, y: -1, width: 2, height: 2 }, t ? 0 === t.indexOf("image://") ? (n.image = t.slice(8), s(n, i), new xn(e)) : ta(t.replace("path://", ""), e, i, "center") : void 0 } function Ha(t, e, i) { this.parentModel = e, this.ecModel = i, this.option = t } function Wa(t, e, i) { for (var n = 0; n < e.length && (!e[n] || (t = t && "object" == typeof t ? t[e[n]] : null, null != t)); n++); return null == t && i && (t = i.get(e)), t } function Xa(t, e) { var i = jy(t).getParent; return i ? i.call(t, e) : t.parentModel } function Ua(t) { return [t || "", Yy++, Math.random().toFixed(5)].join("_") } function ja(t) { var e = {}; return t.registerSubTypeDefaulter = function (t, i) { t = Qn(t), e[t.main] = i }, t.determineSubType = function (i, n) { var r = n.type; if (!r) { var a = Qn(i).main; t.hasSubTypes(i) && e[a] && (r = e[a](n)) } return r }, t } function Ya(t, e) { function i(t) { var i = {}, a = []; return f(t, function (o) { var s = n(i, o), l = s.originalDeps = e(o), h = r(l, t); s.entryCount = h.length, 0 === s.entryCount && a.push(o), f(h, function (t) { u(s.predecessor, t) < 0 && s.predecessor.push(t); var e = n(i, t); u(e.successor, t) < 0 && e.successor.push(o) }) }), { graph: i, noEntryList: a } } function n(t, e) { return t[e] || (t[e] = { predecessor: [], successor: [] }), t[e] } function r(t, e) { var i = []; return f(t, function (t) { u(e, t) >= 0 && i.push(t) }), i } t.topologicalTravel = function (t, e, n, r) { function a(t) { l[t].entryCount-- , 0 === l[t].entryCount && u.push(t) } function o(t) { h[t] = !0, a(t) } if (t.length) { var s = i(e), l = s.graph, u = s.noEntryList, h = {}; for (f(t, function (t) { h[t] = !0 }); u.length;) { var c = u.pop(), d = l[c], p = !!h[c]; p && (n.call(r, c, d.originalDeps.slice()), delete h[c]), f(d.successor, p ? o : a) } f(h, function () { throw new Error("Circle dependency may exists") }) } } } function qa(t) { return t.replace(/^\s+/, "").replace(/\s+$/, "") } function Za(t, e, i, n) { var r = e[1] - e[0], a = i[1] - i[0]; if (0 === r) return 0 === a ? i[0] : (i[0] + i[1]) / 2; if (n) if (r > 0) { if (t <= e[0]) return i[0]; if (t >= e[1]) return i[1] } else { if (t >= e[0]) return i[0]; if (t <= e[1]) return i[1] } else { if (t === e[0]) return i[0]; if (t === e[1]) return i[1] } return (t - e[0]) / r * a + i[0] } function Ka(t, e) { switch (t) { case "center": case "middle": t = "50%"; break; case "left": case "top": t = "0%"; break; case "right": case "bottom": t = "100%" }return "string" == typeof t ? qa(t).match(/%$/) ? parseFloat(t) / 100 * e : parseFloat(t) : null == t ? 0 / 0 : +t } function $a(t, e, i) { return null == e && (e = 10), e = Math.min(Math.max(0, e), 20), t = (+t).toFixed(e), i ? t : +t } function Qa(t) { return t.sort(function (t, e) { return t - e }), t } function Ja(t) { if (t = +t, isNaN(t)) return 0; for (var e = 1, i = 0; Math.round(t * e) / e !== t;)e *= 10, i++; return i } function to(t) { var e = t.toString(), i = e.indexOf("e"); if (i > 0) { var n = +e.slice(i + 1); return 0 > n ? -n : 0 } var r = e.indexOf("."); return 0 > r ? 0 : e.length - 1 - r } function eo(t, e) { var i = Math.log, n = Math.LN10, r = Math.floor(i(t[1] - t[0]) / n), a = Math.round(i(Math.abs(e[1] - e[0])) / n), o = Math.min(Math.max(-r + a, 0), 20); return isFinite(o) ? o : 20 } function io(t, e, i) { if (!t[e]) return 0; var n = g(t, function (t, e) { return t + (isNaN(e) ? 0 : e) }, 0); if (0 === n) return 0; for (var r = Math.pow(10, i), a = p(t, function (t) { return (isNaN(t) ? 0 : t) / n * r * 100 }), o = 100 * r, s = p(a, function (t) { return Math.floor(t) }), l = g(s, function (t, e) { return t + e }, 0), u = p(a, function (t, e) { return t - s[e] }); o > l;) { for (var h = Number.NEGATIVE_INFINITY, c = null, d = 0, f = u.length; f > d; ++d)u[d] > h && (h = u[d], c = d); ++s[c], u[c] = 0, ++l } return s[e] / r } function no(t) { var e = 2 * Math.PI; return (t % e + e) % e } function ro(t) { return t > -qy && qy > t } function ao(t) { if (t instanceof Date) return t; if ("string" == typeof t) { var e = Ky.exec(t); if (!e) return new Date(0 / 0); if (e[8]) { var i = +e[4] || 0; return "Z" !== e[8].toUpperCase() && (i -= e[8].slice(0, 3)), new Date(Date.UTC(+e[1], +(e[2] || 1) - 1, +e[3] || 1, i, +(e[5] || 0), +e[6] || 0, +e[7] || 0)) } return new Date(+e[1], +(e[2] || 1) - 1, +e[3] || 1, +e[4] || 0, +(e[5] || 0), +e[6] || 0, +e[7] || 0) } return new Date(null == t ? 0 / 0 : Math.round(t)) } function oo(t) { return Math.pow(10, so(t)) } function so(t) { return Math.floor(Math.log(t) / Math.LN10) } function lo(t, e) { var i, n = so(t), r = Math.pow(10, n), a = t / r; return i = e ? 1.5 > a ? 1 : 2.5 > a ? 2 : 4 > a ? 3 : 7 > a ? 5 : 10 : 1 > a ? 1 : 2 > a ? 2 : 3 > a ? 3 : 5 > a ? 5 : 10, t = i * r, n >= -20 ? +t.toFixed(0 > n ? -n : 0) : t } function uo(t, e) { var i = (t.length - 1) * e + 1, n = Math.floor(i), r = +t[n - 1], a = i - n; return a ? r + a * (t[n] - r) : r } function ho(t) { function e(t, i, n) { return t.interval[n] < i.interval[n] || t.interval[n] === i.interval[n] && (t.close[n] - i.close[n] === (n ? -1 : 1) || !n && e(t, i, 1)) } t.sort(function (t, i) { return e(t, i, 0) ? -1 : 1 }); for (var i = -1 / 0, n = 1, r = 0; r < t.length;) { for (var a = t[r].interval, o = t[r].close, s = 0; 2 > s; s++)a[s] <= i && (a[s] = i, o[s] = s ? 1 : 1 - n), i = a[s], n = o[s]; a[0] === a[1] && o[0] * o[1] !== 1 ? t.splice(r, 1) : r++ } return t } function co(t) { return t - parseFloat(t) >= 0 } function fo(t) { return isNaN(t) ? "-" : (t = (t + "").split("."), t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t.length > 1 ? "." + t[1] : "")) } function po(t, e) {
    return t = (t || "").toLowerCase().replace(/-(.)/g, function (t, e) {
      return e.toUpperCase()
    }), e && t && (t = t.charAt(0).toUpperCase() + t.slice(1)), t
  } function go(t) { return null == t ? "" : (t + "").replace(Jy, function (t, e) { return tx[e] }) } function mo(t, e, i) { _(e) || (e = [e]); var n = e.length; if (!n) return ""; for (var r = e[0].$vars || [], a = 0; a < r.length; a++) { var o = ex[a]; t = t.replace(ix(o), ix(o, 0)) } for (var s = 0; n > s; s++)for (var l = 0; l < r.length; l++) { var u = e[s][r[l]]; t = t.replace(ix(ex[l], s), i ? go(u) : u) } return t } function vo(t, e, i) { return f(e, function (e, n) { t = t.replace("{" + n + "}", i ? go(e) : e) }), t } function yo(t, e) { t = w(t) ? { color: t, extraCssText: e } : t || {}; var i = t.color, n = t.type, e = t.extraCssText, r = t.renderMode || "html", a = t.markerId || "X"; return i ? "html" === r ? "subItem" === n ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + go(i) + ";" + (e || "") + '"></span>' : '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:' + go(i) + ";" + (e || "") + '"></span>' : { renderMode: r, content: "{marker" + a + "|}  ", style: { color: i } } : "" } function xo(t, e) { return t += "", "0000".substr(0, e - t.length) + t } function _o(t, e, i) { ("week" === t || "month" === t || "quarter" === t || "half-year" === t || "year" === t) && (t = "MM-dd\nyyyy"); var n = ao(e), r = i ? "UTC" : "", a = n["get" + r + "FullYear"](), o = n["get" + r + "Month"]() + 1, s = n["get" + r + "Date"](), l = n["get" + r + "Hours"](), u = n["get" + r + "Minutes"](), h = n["get" + r + "Seconds"](), c = n["get" + r + "Milliseconds"](); return t = t.replace("MM", xo(o, 2)).replace("M", o).replace("yyyy", a).replace("yy", a % 100).replace("dd", xo(s, 2)).replace("d", s).replace("hh", xo(l, 2)).replace("h", l).replace("mm", xo(u, 2)).replace("m", u).replace("ss", xo(h, 2)).replace("s", h).replace("SSS", xo(c, 3)) } function bo(t) { return t ? t.charAt(0).toUpperCase() + t.substr(1) : t } function wo(t) { return Bi(t.text, t.font, t.textAlign, t.textVerticalAlign, t.textPadding, t.textLineHeight, t.rich, t.truncate) } function So(t, e, i, n, r, a, o, s) { return Bi(t, e, i, n, r, s, a, o) } function Mo(t, e, i, n, r) { var a = 0, o = 0; null == n && (n = 1 / 0), null == r && (r = 1 / 0); var s = 0; e.eachChild(function (l, u) { var h, c, d = l.position, f = l.getBoundingRect(), p = e.childAt(u + 1), g = p && p.getBoundingRect(); if ("horizontal" === t) { var m = f.width + (g ? -g.x + f.x : 0); h = a + m, h > n || l.newline ? (a = 0, h = m, o += s + i, s = f.height) : s = Math.max(s, f.height) } else { var v = f.height + (g ? -g.y + f.y : 0); c = o + v, c > r || l.newline ? (a += s + i, o = 0, c = v, s = f.width) : s = Math.max(s, f.width) } l.newline || (d[0] = a, d[1] = o, "horizontal" === t ? a = h + i : o = c + i) }) } function Io(t, e, i) { i = Qy(i || 0); var n = e.width, r = e.height, a = Ka(t.left, n), o = Ka(t.top, r), s = Ka(t.right, n), l = Ka(t.bottom, r), u = Ka(t.width, n), h = Ka(t.height, r), c = i[2] + i[0], d = i[1] + i[3], f = t.aspect; switch (isNaN(u) && (u = n - s - d - a), isNaN(h) && (h = r - l - c - o), null != f && (isNaN(u) && isNaN(h) && (f > n / r ? u = .8 * n : h = .8 * r), isNaN(u) && (u = f * h), isNaN(h) && (h = u / f)), isNaN(a) && (a = n - s - u - d), isNaN(o) && (o = r - l - h - c), t.left || t.right) { case "center": a = n / 2 - u / 2 - i[3]; break; case "right": a = n - u - d }switch (t.top || t.bottom) { case "middle": case "center": o = r / 2 - h / 2 - i[0]; break; case "bottom": o = r - h - c }a = a || 0, o = o || 0, isNaN(u) && (u = n - d - a - (s || 0)), isNaN(h) && (h = r - c - o - (l || 0)); var p = new vi(a + i[3], o + i[0], u, h); return p.margin = i, p } function Do(t, e, i) { function n(i, n) { var o = {}, l = 0, u = {}, h = 0, c = 2; if (ax(i, function (e) { u[e] = t[e] }), ax(i, function (t) { r(e, t) && (o[t] = u[t] = e[t]), a(o, t) && l++ , a(u, t) && h++ }), s[n]) return a(e, i[1]) ? u[i[2]] = null : a(e, i[2]) && (u[i[1]] = null), u; if (h !== c && l) { if (l >= c) return o; for (var d = 0; d < i.length; d++) { var f = i[d]; if (!r(o, f) && r(t, f)) { o[f] = t[f]; break } } return o } return u } function r(t, e) { return t.hasOwnProperty(e) } function a(t, e) { return null != t[e] && "auto" !== t[e] } function o(t, e, i) { ax(t, function (t) { e[t] = i[t] }) } !S(i) && (i = {}); var s = i.ignoreSize; !_(s) && (s = [s, s]); var l = n(sx[0], 0), u = n(sx[1], 1); o(sx[0], t, l), o(sx[1], t, u) } function To(t) { return Ao({}, t) } function Ao(t, e) { return e && t && ax(ox, function (i) { e.hasOwnProperty(i) && (t[i] = e[i]) }), t } function Co(t) { var e = []; return f(cx.getClassesByMainType(t), function (t) { e = e.concat(t.prototype.dependencies || []) }), e = p(e, function (t) { return Qn(t).main }), "dataset" !== t && u(e, "dataset") <= 0 && e.unshift("dataset"), e } function ko(t, e) { for (var i = t.length, n = 0; i > n; n++)if (t[n].length > e) return t[n]; return t[i - 1] } function Po(t) { var e = t.get("coordinateSystem"), i = { coordSysName: e, coordSysDims: [], axisMap: N(), categoryAxisMap: N() }, n = mx[e]; return n ? (n(t, i, i.axisMap, i.categoryAxisMap), i) : void 0 } function Lo(t) { return "category" === t.get("type") } function Oo(t) { this.fromDataset = t.fromDataset, this.data = t.data || (t.sourceFormat === _x ? {} : []), this.sourceFormat = t.sourceFormat || bx, this.seriesLayoutBy = t.seriesLayoutBy || Mx, this.dimensionsDefine = t.dimensionsDefine, this.encodeDefine = t.encodeDefine && N(t.encodeDefine), this.startIndex = t.startIndex || 0, this.dimensionsDetectCount = t.dimensionsDetectCount } function zo(t) { var e = t.option.source, i = bx; if (I(e)) i = Sx; else if (_(e)) { 0 === e.length && (i = yx); for (var n = 0, r = e.length; r > n; n++) { var a = e[n]; if (null != a) { if (_(a)) { i = yx; break } if (S(a)) { i = xx; break } } } } else if (S(e)) { for (var o in e) if (e.hasOwnProperty(o) && d(e[o])) { i = _x; break } } else if (null != e) throw new Error("Invalid data"); Dx(t).sourceFormat = i } function Eo(t) { return Dx(t).source } function Bo(t) { Dx(t).datasetMap = N() } function Ro(t) { var e = t.option, i = e.data, n = I(i) ? Sx : vx, r = !1, a = e.seriesLayoutBy, o = e.sourceHeader, s = e.dimensions, l = Wo(t); if (l) { var u = l.option; i = u.source, n = Dx(l).sourceFormat, r = !0, a = a || u.seriesLayoutBy, null == o && (o = u.sourceHeader), s = s || u.dimensions } var h = No(i, n, a, o, s), c = e.encode; !c && l && (c = Ho(t, l, i, n, a, h)), Dx(t).source = new Oo({ data: i, fromDataset: r, seriesLayoutBy: a, sourceFormat: n, dimensionsDefine: h.dimensionsDefine, startIndex: h.startIndex, dimensionsDetectCount: h.dimensionsDetectCount, encodeDefine: c }) } function No(t, e, i, n, r) { if (!t) return { dimensionsDefine: Fo(r) }; var a, o, s; if (e === yx) "auto" === n || null == n ? Vo(function (t) { null != t && "-" !== t && (w(t) ? null == o && (o = 1) : o = 0) }, i, t, 10) : o = n ? 1 : 0, r || 1 !== o || (r = [], Vo(function (t, e) { r[e] = null != t ? t : "" }, i, t)), a = r ? r.length : i === Ix ? t.length : t[0] ? t[0].length : null; else if (e === xx) r || (r = Go(t), s = !0); else if (e === _x) r || (r = [], s = !0, f(t, function (t, e) { r.push(e) })); else if (e === vx) { var l = Nn(t[0]); a = _(l) && l.length || 1 } var u; return s && f(r, function (t, e) { "name" === (S(t) ? t.name : t) && (u = e) }), { startIndex: o, dimensionsDefine: Fo(r), dimensionsDetectCount: a, potentialNameDimIndex: u } } function Fo(t) { if (t) { var e = N(); return p(t, function (t) { if (t = o({}, S(t) ? t : { name: t }), null == t.name) return t; t.name += "", null == t.displayName && (t.displayName = t.name); var i = e.get(t.name); return i ? t.name += "-" + i.count++ : e.set(t.name, { count: 1 }), t }) } } function Vo(t, e, i, n) { if (null == n && (n = 1 / 0), e === Ix) for (var r = 0; r < i.length && n > r; r++)t(i[r] ? i[r][0] : null, r); else for (var a = i[0] || [], r = 0; r < a.length && n > r; r++)t(a[r], r) } function Go(t) { for (var e, i = 0; i < t.length && !(e = t[i++]);); if (e) { var n = []; return f(e, function (t, e) { n.push(e) }), n } } function Ho(t, e, i, n, r, a) { var o = Po(t), s = {}, l = [], u = [], h = t.subType, c = N(["pie", "map", "funnel"]), d = N(["line", "bar", "pictorialBar", "scatter", "effectScatter", "candlestick", "boxplot"]); if (o && null != d.get(h)) { var p = t.ecModel, g = Dx(p).datasetMap, m = e.uid + "_" + r, v = g.get(m) || g.set(m, { categoryWayDim: 1, valueWayDim: 0 }); f(o.coordSysDims, function (t) { if (null == o.firstCategoryDimIndex) { var e = v.valueWayDim++; s[t] = e, u.push(e) } else if (o.categoryAxisMap.get(t)) s[t] = 0, l.push(0); else { var e = v.categoryWayDim++; s[t] = e, u.push(e) } }) } else if (null != c.get(h)) { for (var y, x = 0; 5 > x && null == y; x++)Uo(i, n, r, a.dimensionsDefine, a.startIndex, x) || (y = x); if (null != y) { s.value = y; var _ = a.potentialNameDimIndex || Math.max(y - 1, 0); u.push(_), l.push(_) } } return l.length && (s.itemName = l), u.length && (s.seriesName = u), s } function Wo(t) { var e = t.option, i = e.data; return i ? void 0 : t.ecModel.getComponent("dataset", e.datasetIndex || 0) } function Xo(t, e) { return Uo(t.data, t.sourceFormat, t.seriesLayoutBy, t.dimensionsDefine, t.startIndex, e) } function Uo(t, e, i, n, r, a) { function o(t) { return null != t && isFinite(t) && "" !== t ? !1 : w(t) && "-" !== t ? !0 : void 0 } var s, l = 5; if (I(t)) return !1; var u; if (n && (u = n[a], u = S(u) ? u.name : u), e === yx) if (i === Ix) { for (var h = t[a], c = 0; c < (h || []).length && l > c; c++)if (null != (s = o(h[r + c]))) return s } else for (var c = 0; c < t.length && l > c; c++) { var d = t[r + c]; if (d && null != (s = o(d[a]))) return s } else if (e === xx) { if (!u) return; for (var c = 0; c < t.length && l > c; c++) { var f = t[c]; if (f && null != (s = o(f[u]))) return s } } else if (e === _x) { if (!u) return; var h = t[u]; if (!h || I(h)) return !1; for (var c = 0; c < h.length && l > c; c++)if (null != (s = o(h[c]))) return s } else if (e === vx) for (var c = 0; c < t.length && l > c; c++) { var f = t[c], p = Nn(f); if (!_(p)) return !1; if (null != (s = o(p[a]))) return s } return !1 } function jo(t, e) { if (e) { var i = e.seiresIndex, n = e.seriesId, r = e.seriesName; return null != i && t.componentIndex !== i || null != n && t.id !== n || null != r && t.name !== r } } function Yo(t, e) { var i = t.color && !t.colorLayer; f(e, function (e, a) { "colorLayer" === a && i || cx.hasClass(a) || ("object" == typeof e ? t[a] = t[a] ? r(t[a], e, !1) : n(e) : null == t[a] && (t[a] = e)) }) } function qo(t) { t = t, this.option = {}, this.option[Tx] = 1, this._componentsMap = N({ series: [] }), this._seriesIndices, this._seriesIndicesMap, Yo(t, this._theme.option), r(t, fx, !1), this.mergeOption(t) } function Zo(t, e) { _(e) || (e = e ? [e] : []); var i = {}; return f(e, function (e) { i[e] = (t.get(e) || []).slice() }), i } function Ko(t, e, i) { var n = e.type ? e.type : i ? i.subType : cx.determineSubType(t, e); return n } function $o(t, e) { t._seriesIndicesMap = N(t._seriesIndices = p(e, function (t) { return t.componentIndex }) || []) } function Qo(t, e) { return e.hasOwnProperty("subType") ? m(t, function (t) { return t.subType === e.subType }) : t } function Jo(t) { f(Cx, function (e) { this[e] = y(t[e], t) }, this) } function ts() { this._coordinateSystems = [] } function es(t) { this._api = t, this._timelineOptions = [], this._mediaList = [], this._mediaDefault, this._currentMediaIndices = [], this._optionBackup, this._newBaseOption } function is(t, e, i) { var n, r, a = [], o = [], s = t.timeline; if (t.baseOption && (r = t.baseOption), (s || t.options) && (r = r || {}, a = (t.options || []).slice()), t.media) { r = r || {}; var l = t.media; Px(l, function (t) { t && t.option && (t.query ? o.push(t) : n || (n = t)) }) } return r || (r = t), r.timeline || (r.timeline = s), Px([r].concat(a).concat(p(o, function (t) { return t.option })), function (t) { Px(e, function (e) { e(t, i) }) }), { baseOption: r, timelineOptions: a, mediaDefault: n, mediaList: o } } function ns(t, e, i) { var n = { width: e, height: i, aspectratio: e / i }, r = !0; return f(t, function (t, e) { var i = e.match(Ex); if (i && i[1] && i[2]) { var a = i[1], o = i[2].toLowerCase(); rs(n[o], t, a) || (r = !1) } }), r } function rs(t, e, i) { return "min" === i ? t >= e : "max" === i ? e >= t : t === e } function as(t, e) { return t.join(",") === e.join(",") } function os(t, e) { e = e || {}, Px(e, function (e, i) { if (null != e) { var n = t[i]; if (cx.hasClass(i)) { e = Bn(e), n = Bn(n); var r = Vn(n, e); t[i] = Ox(r, function (t) { return t.option && t.exist ? zx(t.exist, t.option, !0) : t.exist || t.option }) } else t[i] = zx(n, e, !0) } }) } function ss(t) { var e = t && t.itemStyle; if (e) for (var i = 0, n = Nx.length; n > i; i++) { var a = Nx[i], o = e.normal, s = e.emphasis; o && o[a] && (t[a] = t[a] || {}, t[a].normal ? r(t[a].normal, o[a]) : t[a].normal = o[a], o[a] = null), s && s[a] && (t[a] = t[a] || {}, t[a].emphasis ? r(t[a].emphasis, s[a]) : t[a].emphasis = s[a], s[a] = null) } } function ls(t, e, i) { if (t && t[e] && (t[e].normal || t[e].emphasis)) { var n = t[e].normal, r = t[e].emphasis; n && (i ? (t[e].normal = t[e].emphasis = null, s(t[e], n)) : t[e] = n), r && (t.emphasis = t.emphasis || {}, t.emphasis[e] = r) } } function us(t) { ls(t, "itemStyle"), ls(t, "lineStyle"), ls(t, "areaStyle"), ls(t, "label"), ls(t, "labelLine"), ls(t, "upperLabel"), ls(t, "edgeLabel") } function hs(t, e) { var i = Rx(t) && t[e], n = Rx(i) && i.textStyle; if (n) for (var r = 0, a = $m.length; a > r; r++) { var e = $m[r]; n.hasOwnProperty(e) && (i[e] = n[e]) } } function cs(t) { t && (us(t), hs(t, "label"), t.emphasis && hs(t.emphasis, "label")) } function ds(t) { if (Rx(t)) { ss(t), us(t), hs(t, "label"), hs(t, "upperLabel"), hs(t, "edgeLabel"), t.emphasis && (hs(t.emphasis, "label"), hs(t.emphasis, "upperLabel"), hs(t.emphasis, "edgeLabel")); var e = t.markPoint; e && (ss(e), cs(e)); var i = t.markLine; i && (ss(i), cs(i)); var n = t.markArea; n && cs(n); var r = t.data; if ("graph" === t.type) { r = r || t.nodes; var a = t.links || t.edges; if (a && !I(a)) for (var o = 0; o < a.length; o++)cs(a[o]); f(t.categories, function (t) { us(t) }) } if (r && !I(r)) for (var o = 0; o < r.length; o++)cs(r[o]); var e = t.markPoint; if (e && e.data) for (var s = e.data, o = 0; o < s.length; o++)cs(s[o]); var i = t.markLine; if (i && i.data) for (var l = i.data, o = 0; o < l.length; o++)_(l[o]) ? (cs(l[o][0]), cs(l[o][1])) : cs(l[o]); "gauge" === t.type ? (hs(t, "axisLabel"), hs(t, "title"), hs(t, "detail")) : "treemap" === t.type ? (ls(t.breadcrumb, "itemStyle"), f(t.levels, function (t) { us(t) })) : "tree" === t.type && us(t.leaves) } } function fs(t) { return _(t) ? t : t ? [t] : [] } function ps(t) { return (_(t) ? t[0] : t) || {} } function gs(t, e) { e = e.split(","); for (var i = t, n = 0; n < e.length && (i = i && i[e[n]], null != i); n++); return i } function ms(t, e, i, n) { e = e.split(","); for (var r, a = t, o = 0; o < e.length - 1; o++)r = e[o], null == a[r] && (a[r] = {}), a = a[r]; (n || null == a[e[o]]) && (a[e[o]] = i) } function vs(t) { f(Vx, function (e) { e[0] in t && !(e[1] in t) && (t[e[1]] = t[e[0]]) }) } function ys(t) { f(t, function (e, i) { var n = [], r = [0 / 0, 0 / 0], a = [e.stackResultDimension, e.stackedOverDimension], o = e.data, s = e.isStackedByIndex, l = o.map(a, function (a, l, u) { var h = o.get(e.stackedDimension, u); if (isNaN(h)) return r; var c, d; s ? d = o.getRawIndex(u) : c = o.get(e.stackedByDimension, u); for (var f = 0 / 0, p = i - 1; p >= 0; p--) { var g = t[p]; if (s || (d = g.data.rawIndexOf(g.stackedByDimension, c)), d >= 0) { var m = g.data.getByRawIndex(g.stackResultDimension, d); if (h >= 0 && m > 0 || 0 >= h && 0 > m) { h += m, f = m; break } } } return n[0] = h, n[1] = f, n }); o.hostModel.setData(l), e.data = l }) } function xs(t, e) { Oo.isInstance(t) || (t = Oo.seriesDataToSource(t)), this._source = t; var i = this._data = t.data, n = t.sourceFormat; n === Sx && (this._offset = 0, this._dimSize = e, this._data = i); var r = Ux[n === yx ? n + "_" + t.seriesLayoutBy : n]; o(this, r) } function _s() { return this._data.length } function bs(t) { return this._data[t] } function ws(t) { for (var e = 0; e < t.length; e++)this._data.push(t[e]) } function Ss(t, e, i) { return null != i ? t[i] : t } function Ms(t, e, i, n) { return Is(t[n], this._dimensionInfos[e]) } function Is(t, e) { var i = e && e.type; if ("ordinal" === i) { var n = e && e.ordinalMeta; return n ? n.parseAndCollect(t) : t } return "time" === i && "number" != typeof t && null != t && "-" !== t && (t = +ao(t)), null == t || "" === t ? 0 / 0 : +t } function Ds(t, e, i) { if (t) { var n = t.getRawDataItem(e); if (null != n) { var r, a, o = t.getProvider().getSource().sourceFormat, s = t.getDimensionInfo(i); return s && (r = s.name, a = s.index), jx[o](n, e, a, r) } } } function Ts(t, e, i) { if (t) { var n = t.getProvider().getSource().sourceFormat; if (n === vx || n === xx) { var r = t.getRawDataItem(e); return n !== vx || S(r) || (r = null), r ? r[i] : void 0 } } } function As(t) { return new Cs(t) } function Cs(t) { t = t || {}, this._reset = t.reset, this._plan = t.plan, this._count = t.count, this._onDirty = t.onDirty, this._dirty = !0, this.context } function ks(t, e, i, n, r, a) { $x.reset(i, n, r, a), t._callingProgress = e, t._callingProgress({ start: i, end: n, count: n - i, next: $x.next }, t.context) } function Ps(t, e) { t._dueIndex = t._outputDueEnd = t._dueEnd = 0, t._settedOutputEnd = null; var i, n; !e && t._reset && (i = t._reset(t.context), i && i.progress && (n = i.forceFirstProgress, i = i.progress), _(i) && !i.length && (i = null)), t._progress = i, t._modBy = t._modDataCount = null; var r = t._downstream; return r && r.dirty(), n } function Ls(t) { var e = t.name; Hn(t) || (t.name = Os(t) || e) } function Os(t) { var e = t.getRawData(), i = e.mapDimension("seriesName", !0), n = []; return f(i, function (t) { var i = e.getDimensionInfo(t); i.displayName && n.push(i.displayName) }), n.join(" ") } function zs(t) { return t.model.getRawData().count() } function Es(t) { var e = t.model; return e.setData(e.getRawData().cloneShallow()), Bs } function Bs(t, e) { t.end > e.outputData.count() && e.model.getRawData().cloneShallow(e.outputData) } function Rs(t, e) { f(t.CHANGABLE_METHODS, function (i) { t.wrapMethod(i, x(Ns, e)) }) } function Ns(t) { var e = Fs(t); e && e.setOutputEnd(this.count()) } function Fs(t) { var e = (t.ecModel || {}).scheduler, i = e && e.getPipeline(t.uid); if (i) { var n = i.currentTask; if (n) { var r = n.agentStubMap; r && (n = r.get(t.uid)) } return n } } function Vs() { this.group = new $g, this.uid = Ua("viewChart"), this.renderTask = As({ plan: Ws, reset: Xs }), this.renderTask.context = { view: this } } function Gs(t, e) { if (t && (t.trigger(e), "group" === t.type)) for (var i = 0; i < t.childCount(); i++)Gs(t.childAt(i), e) } function Hs(t, e, i) { var n = Xn(t, e); null != n ? f(Bn(n), function (e) { Gs(t.getItemGraphicEl(e), i) }) : t.eachItemGraphicEl(function (t) { Gs(t, i) }) } function Ws(t) { return r_(t.model) } function Xs(t) { var e = t.model, i = t.ecModel, n = t.api, r = t.payload, a = e.pipelineContext.progressiveRender, o = t.view, s = r && n_(r).updateMethod, l = a ? "incrementalPrepareRender" : s && o[s] ? s : "render"; return "render" !== l && o[l](e, i, n, r), o_[l] } function Us(t, e, i) { function n() { h = (new Date).getTime(), c = null, t.apply(o, s || []) } var r, a, o, s, l, u = 0, h = 0, c = null; e = e || 0; var d = function () { r = (new Date).getTime(), o = this, s = arguments; var t = l || e, d = l || i; l = null, a = r - (d ? u : h) - t, clearTimeout(c), d ? c = setTimeout(n, t) : a >= 0 ? n() : c = setTimeout(n, -a), u = r }; return d.clear = function () { c && (clearTimeout(c), c = null) }, d.debounceNextCall = function (t) { l = t }, d } function js(t, e, i, n) { var r = t[e]; if (r) { var a = r[s_] || r, o = r[u_], s = r[l_]; if (s !== i || o !== n) { if (null == i || !n) return t[e] = a; r = t[e] = Us(a, i, "debounce" === n), r[s_] = a, r[u_] = n, r[l_] = i } return r } } function Ys(t, e, i, n) { this.ecInstance = t, this.api = e, this.unfinished; var i = this._dataProcessorHandlers = i.slice(), n = this._visualHandlers = n.slice(); this._allHandlers = i.concat(n), this._stageTaskMap = N() } function qs(t, e, i, n, r) { function a(t, e) { return t.setDirty && (!t.dirtyMap || t.dirtyMap.get(e.__pipeline.id)) } r = r || {}; var o; f(e, function (e) { if (!r.visualType || r.visualType === e.visualType) { var s = t._stageTaskMap.get(e.uid), l = s.seriesTaskMap, u = s.overallTask; if (u) { var h, c = u.agentStubMap; c.each(function (t) { a(r, t) && (t.dirty(), h = !0) }), h && u.dirty(), m_(u, n); var d = t.getPerformArgs(u, r.block); c.each(function (t) { t.perform(d) }), o |= u.perform(d) } else l && l.each(function (s) { a(r, s) && s.dirty(); var l = t.getPerformArgs(s, r.block); l.skip = !e.performRawSeries && i.isSeriesFiltered(s.context.model), m_(s, n), o |= s.perform(l) }) } }), t.unfinished |= o } function Zs(t, e, i, n, r) { function a(i) { var a = i.uid, s = o.get(a) || o.set(a, As({ plan: el, reset: il, count: rl })); s.context = { model: i, ecModel: n, api: r, useClearVisual: e.isVisual && !e.isLayout, plan: e.plan, reset: e.reset, scheduler: t }, al(t, i, s) } var o = i.seriesTaskMap || (i.seriesTaskMap = N()), s = e.seriesType, l = e.getTargetSeries; e.createOnAllSeries ? n.eachRawSeries(a) : s ? n.eachRawSeriesByType(s, a) : l && l(n, r).each(a); var u = t._pipelineMap; o.each(function (t, e) { u.get(e) || (t.dispose(), o.removeKey(e)) }) } function Ks(t, e, i, n, r) { function a(e) { var i = e.uid, n = s.get(i); n || (n = s.set(i, As({ reset: Qs, onDirty: tl })), o.dirty()), n.context = { model: e, overallProgress: h, modifyOutputEnd: c }, n.agent = o, n.__block = h, al(t, e, n) } var o = i.overallTask = i.overallTask || As({ reset: $s }); o.context = { ecModel: n, api: r, overallReset: e.overallReset, scheduler: t }; var s = o.agentStubMap = o.agentStubMap || N(), l = e.seriesType, u = e.getTargetSeries, h = !0, c = e.modifyOutputEnd; l ? n.eachRawSeriesByType(l, a) : u ? u(n, r).each(a) : (h = !1, f(n.getSeries(), a)); var d = t._pipelineMap; s.each(function (t, e) { d.get(e) || (t.dispose(), o.dirty(), s.removeKey(e)) }) } function $s(t) { t.overallReset(t.ecModel, t.api, t.payload) } function Qs(t) { return t.overallProgress && Js } function Js() { this.agent.dirty(), this.getDownstream().dirty() } function tl() { this.agent && this.agent.dirty() } function el(t) { return t.plan && t.plan(t.model, t.ecModel, t.api, t.payload) } function il(t) { t.useClearVisual && t.data.clearAllVisual(); var e = t.resetDefines = Bn(t.reset(t.model, t.ecModel, t.api, t.payload)); return e.length > 1 ? p(e, function (t, e) { return nl(e) }) : v_ } function nl(t) { return function (e, i) { var n = i.data, r = i.resetDefines[t]; if (r && r.dataEach) for (var a = e.start; a < e.end; a++)r.dataEach(n, a); else r && r.progress && r.progress(e, n) } } function rl(t) { return t.data.count() } function al(t, e, i) { var n = e.uid, r = t._pipelineMap.get(n); !r.head && (r.head = i), r.tail && r.tail.pipe(i), r.tail = i, i.__idxInPipeline = r.count++ , i.__pipeline = r } function ol(t) { y_ = null; try { t(x_, __) } catch (e) { } return y_ } function sl(t, e) { for (var i in e.prototype) t[i] = V } function ll(t) { if (w(t)) { var e = new DOMParser; t = e.parseFromString(t, "text/xml") } for (9 === t.nodeType && (t = t.firstChild); "svg" !== t.nodeName.toLowerCase() || 1 !== t.nodeType;)t = t.nextSibling; return t } function ul() { this._defs = {}, this._root = null, this._isDefine = !1, this._isText = !1 } function hl(t, e) { for (var i = t.firstChild; i;) { if (1 === i.nodeType) { var n = i.getAttribute("offset"); n = n.indexOf("%") > 0 ? parseInt(n, 10) / 100 : n ? parseFloat(n) : 0; var r = i.getAttribute("stop-color") || "#000000"; e.addColorStop(n, r) } i = i.nextSibling } } function cl(t, e) { t && t.__inheritedStyle && (e.__inheritedStyle || (e.__inheritedStyle = {}), s(e.__inheritedStyle, t.__inheritedStyle)) } function dl(t) { for (var e = z(t).split(A_), i = [], n = 0; n < e.length; n += 2) { var r = parseFloat(e[n]), a = parseFloat(e[n + 1]); i.push([r, a]) } return i } function fl(t, e, i, n) { var r = e.__inheritedStyle || {}, a = "text" === e.type; if (1 === t.nodeType && (gl(t, e), o(r, ml(t)), !n)) for (var s in P_) if (P_.hasOwnProperty(s)) { var l = t.getAttribute(s); null != l && (r[P_[s]] = l) } var u = a ? "textFill" : "fill", h = a ? "textStroke" : "stroke"; e.style = e.style || new om; var c = e.style; null != r.fill && c.set(u, pl(r.fill, i)), null != r.stroke && c.set(h, pl(r.stroke, i)), f(["lineWidth", "opacity", "fillOpacity", "strokeOpacity", "miterLimit", "fontSize"], function (t) { var e = "lineWidth" === t && a ? "textStrokeWidth" : t; null != r[t] && c.set(e, parseFloat(r[t])) }), r.textBaseline && "auto" !== r.textBaseline || (r.textBaseline = "alphabetic"), "alphabetic" === r.textBaseline && (r.textBaseline = "bottom"), "start" === r.textAlign && (r.textAlign = "left"), "end" === r.textAlign && (r.textAlign = "right"), f(["lineDashOffset", "lineCap", "lineJoin", "fontWeight", "fontFamily", "fontStyle", "textAlign", "textBaseline"], function (t) { null != r[t] && c.set(t, r[t]) }), r.lineDash && (e.style.lineDash = z(r.lineDash).split(A_)), c[h] && "none" !== c[h] && (e[h] = !0), e.__inheritedStyle = r } function pl(t, e) { var i = e && t && t.match(L_); if (i) { var n = z(i[1]), r = e[n]; return r } return t } function gl(t, e) { var i = t.getAttribute("transform"); if (i) { i = i.replace(/,/g, " "); var n = null, r = []; i.replace(O_, function (t, e, i) { r.push(e, i) }); for (var a = r.length - 1; a > 0; a -= 2) { var o = r[a], s = r[a - 1]; switch (n = n || Me(), s) { case "translate": o = z(o).split(A_), Ae(n, n, [parseFloat(o[0]), parseFloat(o[1] || 0)]); break; case "scale": o = z(o).split(A_), ke(n, n, [parseFloat(o[0]), parseFloat(o[1] || o[0])]); break; case "rotate": o = z(o).split(A_), Ce(n, n, parseFloat(o[0])); break; case "skew": o = z(o).split(A_), console.warn("Skew transform is not supported yet"); break; case "matrix": var o = z(o).split(A_); n[0] = parseFloat(o[0]), n[1] = parseFloat(o[1]), n[2] = parseFloat(o[2]), n[3] = parseFloat(o[3]), n[4] = parseFloat(o[4]), n[5] = parseFloat(o[5]) } } e.setLocalTransform(n) } } function ml(t) { var e = t.getAttribute("style"), i = {}; if (!e) return i; var n = {}; z_.lastIndex = 0; for (var r; null != (r = z_.exec(e));)n[r[1]] = r[2]; for (var a in P_) P_.hasOwnProperty(a) && null != n[a] && (i[P_[a]] = n[a]); return i } function vl(t, e, i) { var n = e / t.width, r = i / t.height, a = Math.min(n, r), o = [a, a], s = [-(t.x + t.width / 2) * a + e / 2, -(t.y + t.height / 2) * a + i / 2]; return { scale: o, position: s } } function yl(t) { return function (e, i, n) { e = e && e.toLowerCase(), ug.prototype[t].call(this, e, i, n) } } function xl() { ug.call(this) } function _l(t, e, i) { function r(t, e) { return t.__prio - e.__prio } i = i || {}, "string" == typeof e && (e = db[e]), this.id, this.group, this._dom = t; var a = "canvas", o = this._zr = Pn(t, { renderer: i.renderer || a, devicePixelRatio: i.devicePixelRatio, width: i.width, height: i.height }); this._throttledZrFlush = Us(y(o.flush, o), 17); var e = n(e); e && Hx(e, !0), this._theme = e, this._chartsViews = [], this._chartsMap = {}, this._componentsViews = [], this._componentsMap = {}, this._coordSysMgr = new ts; var s = this._api = Nl(this); Ii(cb, r), Ii(lb, r), this._scheduler = new Ys(this, s, lb, cb), ug.call(this, this._ecEventProcessor = new Fl), this._messageCenter = new xl, this._initEvents(), this.resize = y(this.resize, this), this._pendingActions = [], o.animation.on("frame", this._onframe, this), Al(o, this), E(this) } function bl(t, e, i) { var n, r = this._model, a = this._coordSysMgr.getCoordinateSystems(); e = jn(r, e); for (var o = 0; o < a.length; o++) { var s = a[o]; if (s[t] && null != (n = s[t](r, e, i))) return n } } function wl(t) { var e = t._model, i = t._scheduler; i.restorePipelines(e), i.prepareStageTasks(), Cl(t, "component", e, i), Cl(t, "chart", e, i), i.plan() } function Sl(t, e, i, n, r) { function a(n) { n && n.__alive && n[e] && n[e](n.__model, o, t._api, i) } var o = t._model; if (!n) return void F_(t._componentsViews.concat(t._chartsViews), a); var s = {}; s[n + "Id"] = i[n + "Id"], s[n + "Index"] = i[n + "Index"], s[n + "Name"] = i[n + "Name"]; var l = { mainType: n, query: s }; r && (l.subType = r); var u = i.excludeSeriesId; null != u && (u = N(Bn(u))), o && o.eachComponent(l, function (e) { u && null != u.get(e.id) || a(t["series" === n ? "_chartsMap" : "_componentsMap"][e.__viewId]) }, t) } function Ml(t, e) { var i = t._chartsMap, n = t._scheduler; e.eachSeries(function (t) { n.updateStreamModes(t, i[t.__viewId]) }) } function Il(t, e) { var i = t.type, n = t.escapeConnect, r = ob[i], a = r.actionInfo, l = (a.update || "update").split(":"), u = l.pop(); l = null != l[0] && H_(l[0]), this[tb] = !0; var h = [t], c = !1; t.batch && (c = !0, h = p(t.batch, function (e) { return e = s(o({}, e), t), e.batch = null, e })); var d, f = [], g = "highlight" === i || "downplay" === i; F_(h, function (t) { d = r.action(t, this._model, this._api), d = d || o({}, t), d.type = a.event || d.type, f.push(d), g ? Sl(this, u, t, "series") : l && Sl(this, u, t, l.main, l.sub) }, this), "none" === u || g || l || (this[eb] ? (wl(this), rb.update.call(this, t), this[eb] = !1) : rb[u].call(this, t)), d = c ? { type: a.event || i, escapeConnect: n, batch: f } : f[0], this[tb] = !1, !e && this._messageCenter.trigger(d.type, d) } function Dl(t) { for (var e = this._pendingActions; e.length;) { var i = e.shift(); Il.call(this, i, t) } } function Tl(t) { !t && this.trigger("updated") } function Al(t, e) { t.on("rendered", function () { e.trigger("rendered"), !t.animation.isFinished() || e[eb] || e._scheduler.unfinished || e._pendingActions.length || e.trigger("finished") }) } function Cl(t, e, i, n) { function r(t) { var e = "_ec_" + t.id + "_" + t.type, r = s[e]; if (!r) { var h = H_(t.type), c = a ? t_.getClass(h.main, h.sub) : Vs.getClass(h.sub); r = new c, r.init(i, u), s[e] = r, o.push(r), l.add(r.group) } t.__viewId = r.__id = e, r.__alive = !0, r.__model = t, r.group.__ecComponentInfo = { mainType: t.mainType, index: t.componentIndex }, !a && n.prepareView(r, t, i, u) } for (var a = "component" === e, o = a ? t._componentsViews : t._chartsViews, s = a ? t._componentsMap : t._chartsMap, l = t._zr, u = t._api, h = 0; h < o.length; h++)o[h].__alive = !1; a ? i.eachComponent(function (t, e) { "series" !== t && r(e) }) : i.eachSeries(r); for (var h = 0; h < o.length;) { var c = o[h]; c.__alive ? h++ : (!a && c.renderTask.dispose(), l.remove(c.group), c.dispose(i, u), o.splice(h, 1), delete s[c.__id], c.__id = c.group.__ecComponentInfo = null) } } function kl(t) { t.clearColorPalette(), t.eachSeries(function (t) { t.clearColorPalette() }) } function Pl(t, e, i, n) { Ll(t, e, i, n), F_(t._chartsViews, function (t) { t.__alive = !1 }), Ol(t, e, i, n), F_(t._chartsViews, function (t) { t.__alive || t.remove(e, i) }) } function Ll(t, e, i, n, r) { F_(r || t._componentsViews, function (t) { var r = t.__model; t.render(r, e, i, n), Rl(r, t) }) } function Ol(t, e, i, n, r) { var a, o = t._scheduler; e.eachSeries(function (e) { var i = t._chartsMap[e.__viewId]; i.__alive = !0; var s = i.renderTask; o.updatePayload(s, n), r && r.get(e.uid) && s.dirty(), a |= s.perform(o.getPerformArgs(s)), i.group.silent = !!e.get("silent"), Rl(e, i), Bl(e, i) }), o.unfinished |= a, El(t._zr, e), d_(t._zr.dom, e) } function zl(t, e) { F_(hb, function (i) { i(t, e) }) } function El(t, e) { var i = t.storage, n = 0; i.traverse(function (t) { t.isGroup || n++ }), n > e.get("hoverLayerThreshold") && !Gp.node && i.traverse(function (t) { t.isGroup || (t.useHoverLayer = !0) }) } function Bl(t, e) { var i = t.get("blendMode") || null; e.group.traverse(function (t) { t.isGroup || t.style.blend !== i && t.setStyle("blend", i), t.eachPendingDisplayable && t.eachPendingDisplayable(function (t) { t.setStyle("blend", i) }) }) } function Rl(t, e) { var i = t.get("z"), n = t.get("zlevel"); e.group.traverse(function (t) { "group" !== t.type && (null != i && (t.z = i), null != n && (t.zlevel = n)) }) } function Nl(t) { var e = t._coordSysMgr; return o(new Jo(t), { getCoordinateSystems: y(e.getCoordinateSystems, e), getComponentByElement: function (e) { for (; e;) { var i = e.__ecComponentInfo; if (null != i) return t._model.getComponent(i.mainType, i.index); e = e.parent } } }) } function Fl() { this.eventInfo } function Vl(t) { function e(t, e) { for (var i = 0; i < t.length; i++) { var n = t[i]; n[a] = e } } var i = 0, n = 1, r = 2, a = "__connectUpdateStatus"; F_(sb, function (o, s) { t._messageCenter.on(s, function (o) { if (gb[t.group] && t[a] !== i) { if (o && o.escapeConnect) return; var s = t.makeActionFromEvent(o), l = []; F_(pb, function (e) { e !== t && e.group === t.group && l.push(e) }), e(l, i), F_(l, function (t) { t[a] !== n && t.dispatchAction(s) }), e(l, r) } }) }) } function Gl(t, e, i) { var n = Ul(t); if (n) return n; var r = new _l(t, e, i); return r.id = "ec_" + mb++ , pb[r.id] = r, qn(t, yb, r.id), Vl(r), r } function Hl(t) { if (_(t)) { var e = t; t = null, F_(e, function (e) { null != e.group && (t = e.group) }), t = t || "g_" + vb++ , F_(e, function (e) { e.group = t }) } return gb[t] = !0, t } function Wl(t) { gb[t] = !1 } function Xl(t) { "string" == typeof t ? t = pb[t] : t instanceof _l || (t = Ul(t)), t instanceof _l && !t.isDisposed() && t.dispose() } function Ul(t) { return pb[Zn(t, yb)] } function jl(t) { return pb[t] } function Yl(t, e) { db[t] = e } function ql(t) { ub.push(t) } function Zl(t, e) { iu(lb, t, e, j_) } function Kl(t) { hb.push(t) } function $l(t, e, i) { "function" == typeof e && (i = e, e = ""); var n = G_(t) ? t.type : [t, t = { event: e }][0]; t.event = (t.event || n).toLowerCase(), e = t.event, N_(ib.test(n) && ib.test(e)), ob[n] || (ob[n] = { action: i, actionInfo: t }), sb[e] = n } function Ql(t, e) { ts.register(t, e) } function Jl(t) { var e = ts.get(t); return e ? e.getDimensionsInfo ? e.getDimensionsInfo() : e.dimensions.slice() : void 0 } function tu(t, e) { iu(cb, t, e, q_, "layout") } function eu(t, e) { iu(cb, t, e, K_, "visual") } function iu(t, e, i, n, r) { (V_(e) || G_(e)) && (i = e, e = n); var a = Ys.wrapStageHandler(i, r); return a.__prio = e, a.__raw = i, t.push(a), a } function nu(t, e) { fb[t] = e } function ru(t) { return cx.extend(t) } function au(t) { return t_.extend(t) } function ou(t) { return Jx.extend(t) } function su(t) { return Vs.extend(t) } function lu(t) { i("createCanvas", t) } function uu(t, e, i) { B_.registerMap(t, e, i) } function hu(t) { var e = B_.retrieveMap(t); return e && e[0] && { geoJson: e[0].geoJSON, specialAreas: e[0].specialAreas } } function cu(t) { return t } function du(t, e, i, n, r) { this._old = t, this._new = e, this._oldKeyGetter = i || cu, this._newKeyGetter = n || cu, this.context = r } function fu(t, e, i, n, r) { for (var a = 0; a < t.length; a++) { var o = "_ec_" + r[n](t[a], a), s = e[o]; null == s ? (i.push(o), e[o] = a) : (s.length || (e[o] = s = [s]), s.push(a)) } } function pu(t) { var e = {}, i = e.encode = {}, n = N(), r = [], a = []; f(t.dimensions, function (e) { var o = t.getDimensionInfo(e), s = o.coordDim; if (s) { var l = i[s]; i.hasOwnProperty(s) || (l = i[s] = []), l[o.coordDimIndex] = e, o.isExtraCoord || (n.set(s, 1), mu(o.type) && (r[0] = e)), o.defaultTooltip && a.push(e) } bb.each(function (t, e) { var n = i[e]; i.hasOwnProperty(e) || (n = i[e] = []); var r = o.otherDims[e]; null != r && r !== !1 && (n[r] = o.name) }) }); var o = [], s = {}; n.each(function (t, e) { var n = i[e]; s[e] = n[0], o = o.concat(n) }), e.dataDimsOnCoord = o, e.encodeFirstDimNotExtra = s; var l = i.label; l && l.length && (r = l.slice()); var u = i.tooltip; return u && u.length ? a = u.slice() : a.length || (a = r.slice()), i.defaultedLabel = r, i.defaultedTooltip = a, e } function gu(t) { return "category" === t ? "ordinal" : "time" === t ? "time" : "float" } function mu(t) { return !("ordinal" === t || "time" === t) } function vu(t) { return t._rawCount > 65535 ? Tb : Cb } function yu(t) { var e = t.constructor; return e === Array ? t.slice() : new e(t) } function xu(t, e) { f(kb.concat(e.__wrappedMethods || []), function (i) { e.hasOwnProperty(i) && (t[i] = e[i]) }), t.__wrappedMethods = e.__wrappedMethods, f(Pb, function (i) { t[i] = n(e[i]) }), t._calculationInfo = o(e._calculationInfo) } function _u(t, e, i, n, r) { var a = Db[e.type], o = n - 1, s = e.name, l = t[s][o]; if (l && l.length < i) { for (var u = new a(Math.min(r - o * i, i)), h = 0; h < l.length; h++)u[h] = l[h]; t[s][o] = u } for (var c = n * i; r > c; c += i)t[s].push(new a(Math.min(r - c, i))) } function bu(t) { var e = t._invertedIndicesMap; f(e, function (i, n) { var r = t._dimensionInfos[n], a = r.ordinalMeta; if (a) { i = e[n] = new Ab(a.categories.length); for (var o = 0; o < i.length; o++)i[o] = Mb; for (var o = 0; o < t._count; o++)i[t.get(n, o)] = o } }) } function wu(t, e, i) { var n; if (null != e) { var r = t._chunkSize, a = Math.floor(i / r), o = i % r, s = t.dimensions[e], l = t._storage[s][a]; if (l) { n = l[o]; var u = t._dimensionInfos[s].ordinalMeta; u && u.categories.length && (n = u.categories[n]) } } return n } function Su(t) { return t } function Mu(t) { return t < this._count && t >= 0 ? this._indices[t] : -1 } function Iu(t, e) { var i = t._idList[e]; return null == i && (i = wu(t, t._idDimIdx, e)), null == i && (i = Ib + e), i } function Du(t) { return _(t) || (t = [t]), t } function Tu(t, e) { var i = t.dimensions, n = new Lb(p(i, t.getDimensionInfo, t), t.hostModel); xu(n, t); for (var r = n._storage = {}, a = t._storage, o = 0; o < i.length; o++) { var s = i[o]; a[s] && (u(e, s) >= 0 ? (r[s] = Au(a[s]), n._rawExtent[s] = Cu(), n._extent[s] = null) : r[s] = a[s]) } return n } function Au(t) { for (var e = new Array(t.length), i = 0; i < t.length; i++)e[i] = yu(t[i]); return e } function Cu() { return [1 / 0, -1 / 0] } function ku(t, e, i) {
    function r(t, e, i) { null != bb.get(e) ? t.otherDims[e] = i : (t.coordDim = e, t.coordDimIndex = i, h.set(e, !0)) } Oo.isInstance(e) || (e = Oo.seriesDataToSource(e)), i = i || {}, t = (t || []).slice(); for (var a = (i.dimsDef || []).slice(), l = N(i.encodeDef), u = N(), h = N(), c = [], d = Pu(e, t, a, i.dimCount), p = 0; d > p; p++) {
      var g = a[p] = o({}, S(a[p]) ? a[p] : { name: a[p] }), m = g.name, v = c[p] = { otherDims: {} };
      null != m && null == u.get(m) && (v.name = v.displayName = m, u.set(m, p)), null != g.type && (v.type = g.type), null != g.displayName && (v.displayName = g.displayName)
    } l.each(function (t, e) { if (t = Bn(t).slice(), 1 === t.length && t[0] < 0) return void l.set(e, !1); var i = l.set(e, []); f(t, function (t, n) { w(t) && (t = u.get(t)), null != t && d > t && (i[n] = t, r(c[t], e, n)) }) }); var y = 0; f(t, function (t) { var e, t, i, a; if (w(t)) e = t, t = {}; else { e = t.name; var o = t.ordinalMeta; t.ordinalMeta = null, t = n(t), t.ordinalMeta = o, i = t.dimsDef, a = t.otherDims, t.name = t.coordDim = t.coordDimIndex = t.dimsDef = t.otherDims = null } var u = l.get(e); if (u !== !1) { var u = Bn(u); if (!u.length) for (var h = 0; h < (i && i.length || 1); h++) { for (; y < c.length && null != c[y].coordDim;)y++; y < c.length && u.push(y++) } f(u, function (n, o) { var l = c[n]; if (r(s(l, t), e, o), null == l.name && i) { var u = i[o]; !S(u) && (u = { name: u }), l.name = l.displayName = u.name, l.defaultTooltip = u.defaultTooltip } a && s(l.otherDims, a) }) } }); var x = i.generateCoord, _ = i.generateCoordCount, b = null != _; _ = x ? _ || 1 : 0; for (var M = x || "value", I = 0; d > I; I++) { var v = c[I] = c[I] || {}, D = v.coordDim; null == D && (v.coordDim = Lu(M, h, b), v.coordDimIndex = 0, (!x || 0 >= _) && (v.isExtraCoord = !0), _--), null == v.name && (v.name = Lu(v.coordDim, u)), null == v.type && Xo(e, I, v.name) && (v.type = "ordinal") } return c
  } function Pu(t, e, i, n) { var r = Math.max(t.dimensionsDetectCount || 1, e.length, i.length, n || 0); return f(e, function (t) { var e = t.dimsDef; e && (r = Math.max(r, e.length)) }), r } function Lu(t, e, i) { if (i || null != e.get(t)) { for (var n = 0; null != e.get(t + n);)n++; t += n } return e.set(t, !0), t } function Ou(t, e, i) { i = i || {}; var n, r, a, o, s = i.byIndex, l = i.stackedCoordDimension, u = !(!t || !t.get("stack")); if (f(e, function (t, i) { w(t) && (e[i] = t = { name: t }), u && !t.isExtraCoord && (s || n || !t.ordinalMeta || (n = t), r || "ordinal" === t.type || "time" === t.type || l && l !== t.coordDim || (r = t)) }), !r || s || n || (s = !0), r) { a = "__\x00ecstackresult", o = "__\x00ecstackedover", n && (n.createInvertedIndices = !0); var h = r.coordDim, c = r.type, d = 0; f(e, function (t) { t.coordDim === h && d++ }), e.push({ name: a, coordDim: h, coordDimIndex: d, type: c, isExtraCoord: !0, isCalculationCoord: !0 }), d++ , e.push({ name: o, coordDim: o, coordDimIndex: d, type: c, isExtraCoord: !0, isCalculationCoord: !0 }) } return { stackedDimension: r && r.name, stackedByDimension: n && n.name, isStackedByIndex: s, stackedOverDimension: o, stackResultDimension: a } } function zu(t, e) { return !!e && e === t.getCalculationInfo("stackedDimension") } function Eu(t, e) { return zu(t, e) ? t.getCalculationInfo("stackResultDimension") : e } function Bu(t, e, i) { i = i || {}, Oo.isInstance(t) || (t = Oo.seriesDataToSource(t)); var n, r = e.get("coordinateSystem"), a = ts.get(r), o = Po(e); o && (n = p(o.coordSysDims, function (t) { var e = { name: t }, i = o.axisMap.get(t); if (i) { var n = i.get("type"); e.type = gu(n) } return e })), n || (n = a && (a.getDimensionsInfo ? a.getDimensionsInfo() : a.dimensions.slice()) || ["x", "y"]); var s, l, u = Eb(t, { coordDimensions: n, generateCoord: i.generateCoord }); o && f(u, function (t, e) { var i = t.coordDim, n = o.categoryAxisMap.get(i); n && (null == s && (s = e), t.ordinalMeta = n.getOrdinalMeta()), null != t.otherDims.itemName && (l = !0) }), l || null == s || (u[s].otherDims.itemName = 0); var h = Ou(e, u), c = new Lb(u, e); c.setCalculationInfo(h); var d = null != s && Ru(t) ? function (t, e, i, n) { return n === s ? i : this.defaultDimValueGetter(t, e, i, n) } : null; return c.hasItemOption = !1, c.initData(t, null, d), c } function Ru(t) { if (t.sourceFormat === vx) { var e = Nu(t.data || []); return null != e && !_(Nn(e)) } } function Nu(t) { for (var e = 0; e < t.length && null == t[e];)e++; return t[e] } function Fu(t) { this._setting = t || {}, this._extent = [1 / 0, -1 / 0], this._interval = 0, this.init && this.init.apply(this, arguments) } function Vu(t) { this.categories = t.categories || [], this._needCollect = t.needCollect, this._deduplication = t.deduplication, this._map } function Gu(t) { return t._map || (t._map = N(t.categories)) } function Hu(t) { return S(t) && null != t.value ? t.value : t + "" } function Wu(t, e, i, n) { var r = {}, a = t[1] - t[0], o = r.interval = lo(a / e, !0); null != i && i > o && (o = r.interval = i), null != n && o > n && (o = r.interval = n); var s = r.intervalPrecision = Xu(o), l = r.niceTickExtent = [Fb(Math.ceil(t[0] / o) * o, s), Fb(Math.floor(t[1] / o) * o, s)]; return ju(l, t), r } function Xu(t) { return to(t) + 2 } function Uu(t, e, i) { t[e] = Math.max(Math.min(t[e], i[1]), i[0]) } function ju(t, e) { !isFinite(t[0]) && (t[0] = e[0]), !isFinite(t[1]) && (t[1] = e[1]), Uu(t, 0, e), Uu(t, 1, e), t[0] > t[1] && (t[0] = t[1]) } function Yu(t, e, i, n) { var r = []; if (!t) return r; var a = 1e4; e[0] < i[0] && r.push(e[0]); for (var o = i[0]; o <= i[1] && (r.push(o), o = Fb(o + t, n), o !== r[r.length - 1]);)if (r.length > a) return []; return e[1] > (r.length ? r[r.length - 1] : i[1]) && r.push(e[1]), r } function qu(t) { return t.get("stack") || Hb + t.seriesIndex } function Zu(t) { return t.dim + t.index } function Ku(t, e) { var i = []; return e.eachSeriesByType(t, function (t) { eh(t) && !ih(t) && i.push(t) }), i } function $u(t) { var e = []; return f(t, function (t) { var i = t.getData(), n = t.coordinateSystem, r = n.getBaseAxis(), a = r.getExtent(), o = "category" === r.type ? r.getBandWidth() : Math.abs(a[1] - a[0]) / i.count(), s = Ka(t.get("barWidth"), o), l = Ka(t.get("barMaxWidth"), o), u = t.get("barGap"), h = t.get("barCategoryGap"); e.push({ bandWidth: o, barWidth: s, barMaxWidth: l, barGap: u, barCategoryGap: h, axisKey: Zu(r), stackId: qu(t) }) }), Qu(e) } function Qu(t) { var e = {}; f(t, function (t) { var i = t.axisKey, n = t.bandWidth, r = e[i] || { bandWidth: n, remainedWidth: n, autoWidthCount: 0, categoryGap: "20%", gap: "30%", stacks: {} }, a = r.stacks; e[i] = r; var o = t.stackId; a[o] || r.autoWidthCount++ , a[o] = a[o] || { width: 0, maxWidth: 0 }; var s = t.barWidth; s && !a[o].width && (a[o].width = s, s = Math.min(r.remainedWidth, s), r.remainedWidth -= s); var l = t.barMaxWidth; l && (a[o].maxWidth = l); var u = t.barGap; null != u && (r.gap = u); var h = t.barCategoryGap; null != h && (r.categoryGap = h) }); var i = {}; return f(e, function (t, e) { i[e] = {}; var n = t.stacks, r = t.bandWidth, a = Ka(t.categoryGap, r), o = Ka(t.gap, 1), s = t.remainedWidth, l = t.autoWidthCount, u = (s - a) / (l + (l - 1) * o); u = Math.max(u, 0), f(n, function (t) { var e = t.maxWidth; e && u > e && (e = Math.min(e, s), t.width && (e = Math.min(e, t.width)), s -= e, t.width = e, l--) }), u = (s - a) / (l + (l - 1) * o), u = Math.max(u, 0); var h, c = 0; f(n, function (t) { t.width || (t.width = u), h = t, c += t.width * (1 + o) }), h && (c -= h.width * o); var d = -c / 2; f(n, function (t, n) { i[e][n] = i[e][n] || { offset: d, width: t.width }, d += t.width * (1 + o) }) }), i } function Ju(t, e, i) { if (t && e) { var n = t[Zu(e)]; return null != n && null != i && (n = n[qu(i)]), n } } function th(t, e) { var i = Ku(t, e), n = $u(i), r = {}; f(i, function (t) { var e = t.getData(), i = t.coordinateSystem, a = i.getBaseAxis(), o = qu(t), s = n[Zu(a)][o], l = s.offset, u = s.width, h = i.getOtherAxis(a), c = t.get("barMinHeight") || 0; r[o] = r[o] || [], e.setLayout({ offset: l, size: u }); for (var d = e.mapDimension(h.dim), f = e.mapDimension(a.dim), p = zu(e, d), g = h.isHorizontal(), m = nh(a, h, p), v = 0, y = e.count(); y > v; v++) { var x = e.get(d, v), _ = e.get(f, v); if (!isNaN(x)) { var b = x >= 0 ? "p" : "n", w = m; p && (r[o][_] || (r[o][_] = { p: m, n: m }), w = r[o][_][b]); var S, M, I, D; if (g) { var T = i.dataToPoint([x, _]); S = w, M = T[1] + l, I = T[0] - m, D = u, Math.abs(I) < c && (I = (0 > I ? -1 : 1) * c), p && (r[o][_][b] += I) } else { var T = i.dataToPoint([_, x]); S = T[0] + l, M = w, I = u, D = T[1] - m, Math.abs(D) < c && (D = (0 >= D ? -1 : 1) * c), p && (r[o][_][b] += D) } e.setItemLayout(v, { x: S, y: M, width: I, height: D }) } } }, this) } function eh(t) { return t.coordinateSystem && "cartesian2d" === t.coordinateSystem.type } function ih(t) { return t.pipelineContext && t.pipelineContext.large } function nh(t, e) { var i, n, r = e.getGlobalExtent(); r[0] > r[1] ? (i = r[1], n = r[0]) : (i = r[0], n = r[1]); var a = e.toGlobalCoord(e.dataToCoord(0)); return i > a && (a = i), a > n && (a = n), a } function rh(t, e) { return aw(t, rw(e)) } function ah(t, e) { var i, n, r, a = t.type, o = e.getMin(), s = e.getMax(), l = null != o, u = null != s, h = t.getExtent(); "ordinal" === a ? i = e.getCategories().length : (n = e.get("boundaryGap"), _(n) || (n = [n || 0, n || 0]), "boolean" == typeof n[0] && (n = [0, 0]), n[0] = Ka(n[0], 1), n[1] = Ka(n[1], 1), r = h[1] - h[0] || Math.abs(h[0])), null == o && (o = "ordinal" === a ? i ? 0 : 0 / 0 : h[0] - n[0] * r), null == s && (s = "ordinal" === a ? i ? i - 1 : 0 / 0 : h[1] + n[1] * r), "dataMin" === o ? o = h[0] : "function" == typeof o && (o = o({ min: h[0], max: h[1] })), "dataMax" === s ? s = h[1] : "function" == typeof s && (s = s({ min: h[0], max: h[1] })), (null == o || !isFinite(o)) && (o = 0 / 0), (null == s || !isFinite(s)) && (s = 0 / 0), t.setBlank(T(o) || T(s) || "ordinal" === a && !t.getOrdinalMeta().categories.length), e.getNeedCrossZero() && (o > 0 && s > 0 && !l && (o = 0), 0 > o && 0 > s && !u && (s = 0)); var c = e.ecModel; if (c && "time" === a) { var d, p = Ku("bar", c); if (f(p, function (t) { d |= t.getBaseAxis() === e.axis }), d) { var g = $u(p), m = oh(o, s, e, g); o = m.min, s = m.max } } return [o, s] } function oh(t, e, i, n) { var r = i.axis.getExtent(), a = r[1] - r[0], o = Ju(n, i.axis); if (void 0 === o) return { min: t, max: e }; var s = 1 / 0; f(o, function (t) { s = Math.min(t.offset, s) }); var l = -1 / 0; f(o, function (t) { l = Math.max(t.offset + t.width, l) }), s = Math.abs(s), l = Math.abs(l); var u = s + l, h = e - t, c = 1 - (s + l) / a, d = h / c - h; return e += d * (l / u), t -= d * (s / u), { min: t, max: e } } function sh(t, e) { var i = ah(t, e), n = null != e.getMin(), r = null != e.getMax(), a = e.get("splitNumber"); "log" === t.type && (t.base = e.get("logBase")); var o = t.type; t.setExtent(i[0], i[1]), t.niceExtent({ splitNumber: a, fixMin: n, fixMax: r, minInterval: "interval" === o || "time" === o ? e.get("minInterval") : null, maxInterval: "interval" === o || "time" === o ? e.get("maxInterval") : null }); var s = e.get("interval"); null != s && t.setInterval && t.setInterval(s) } function lh(t, e) { if (e = e || t.get("type")) switch (e) { case "category": return new Nb(t.getOrdinalMeta ? t.getOrdinalMeta() : t.getCategories(), [1 / 0, -1 / 0]); case "value": return new Gb; default: return (Fu.getClass(e) || Gb).create(t) } } function uh(t) { var e = t.scale.getExtent(), i = e[0], n = e[1]; return !(i > 0 && n > 0 || 0 > i && 0 > n) } function hh(t) { var e = t.getLabelModel().get("formatter"), i = "category" === t.type ? t.scale.getExtent()[0] : null; return "string" == typeof e ? e = function (e) { return function (i) { return i = t.scale.getLabel(i), e.replace("{value}", null != i ? i : "") } }(e) : "function" == typeof e ? function (n, r) { return null != i && (r = n - i), e(ch(t, n), r) } : function (e) { return t.scale.getLabel(e) } } function ch(t, e) { return "category" === t.type ? t.scale.getLabel(e) : e } function dh(t) { var e = t.model, i = t.scale; if (e.get("axisLabel.show") && !i.isBlank()) { var n, r, a = "category" === t.type, o = i.getExtent(); a ? r = i.count() : (n = i.getTicks(), r = n.length); var s, l = t.getLabelModel(), u = hh(t), h = 1; r > 40 && (h = Math.ceil(r / 40)); for (var c = 0; r > c; c += h) { var d = n ? n[c] : o[0] + c, f = u(d), p = l.getTextRect(f), g = fh(p, l.get("rotate") || 0); s ? s.union(g) : s = g } return s } } function fh(t, e) { var i = e * Math.PI / 180, n = t.plain(), r = n.width, a = n.height, o = r * Math.cos(i) + a * Math.sin(i), s = r * Math.sin(i) + a * Math.cos(i), l = new vi(n.x, n.y, o, s); return l } function ph(t) { var e = t.get("interval"); return null == e ? "auto" : e } function gh(t) { return "category" === t.type && 0 === ph(t.getLabelModel()) } function mh(t, e) { if ("image" !== this.type) { var i = this.style, n = this.shape; n && "line" === n.symbolType ? i.stroke = t : this.__isEmptyBrush ? (i.stroke = t, i.fill = e || "#fff") : (i.fill && (i.fill = t), i.stroke && (i.stroke = t)), this.dirty(!1) } } function vh(t, e, i, n, r, a, o) { var s = 0 === t.indexOf("empty"); s && (t = t.substr(5, 1).toLowerCase() + t.substr(6)); var l; return l = 0 === t.indexOf("image://") ? ea(t.slice(8), new vi(e, i, n, r), o ? "center" : "cover") : 0 === t.indexOf("path://") ? ta(t.slice(7), {}, new vi(e, i, n, r), o ? "center" : "cover") : new xw({ shape: { symbolType: t, x: e, y: i, width: n, height: r } }), l.__isEmptyBrush = s, l.setColor = mh, l.setColor(a), l } function yh(t) { return Bu(t.getSource(), t) } function xh(t, e) { var i = e; Ha.isInstance(e) || (i = new Ha(e), c(i, cw)); var n = lh(i); return n.setExtent(t[0], t[1]), sh(n, i), n } function _h(t) { c(t, cw) } function bh(t, e) { return Math.abs(t - e) < ww } function wh(t, e, i) { var n = 0, r = t[0]; if (!r) return !1; for (var a = 1; a < t.length; a++) { var o = t[a]; n += Cr(r[0], r[1], o[0], o[1], e, i), r = o } var s = t[0]; return bh(r[0], s[0]) && bh(r[1], s[1]) || (n += Cr(r[0], r[1], s[0], s[1], e, i)), 0 !== n } function Sh(t, e, i) { if (this.name = t, this.geometries = e, i) i = [i[0], i[1]]; else { var n = this.getBoundingRect(); i = [n.x + n.width / 2, n.y + n.height / 2] } this.center = i } function Mh(t) { if (!t.UTF8Encoding) return t; var e = t.UTF8Scale; null == e && (e = 1024); for (var i = t.features, n = 0; n < i.length; n++)for (var r = i[n], a = r.geometry, o = a.coordinates, s = a.encodeOffsets, l = 0; l < o.length; l++) { var u = o[l]; if ("Polygon" === a.type) o[l] = Ih(u, s[l], e); else if ("MultiPolygon" === a.type) for (var h = 0; h < u.length; h++) { var c = u[h]; u[h] = Ih(c, s[l][h], e) } } return t.UTF8Encoding = !1, t } function Ih(t, e, i) { for (var n = [], r = e[0], a = e[1], o = 0; o < t.length; o += 2) { var s = t.charCodeAt(o) - 64, l = t.charCodeAt(o + 1) - 64; s = s >> 1 ^ -(1 & s), l = l >> 1 ^ -(1 & l), s += r, l += a, r = s, a = l, n.push([s / i, l / i]) } return n } function Dh(t) { return "category" === t.type ? Ah(t) : Ph(t) } function Th(t, e) { return "category" === t.type ? kh(t, e) : { ticks: t.scale.getTicks() } } function Ah(t) { var e = t.getLabelModel(), i = Ch(t, e); return !e.get("show") || t.scale.isBlank() ? { labels: [], labelCategoryInterval: i.labelCategoryInterval } : i } function Ch(t, e) { var i = Lh(t, "labels"), n = ph(e), r = Oh(i, n); if (r) return r; var a, o; return b(n) ? a = Fh(t, n) : (o = "auto" === n ? Eh(t) : n, a = Nh(t, o)), zh(i, n, { labels: a, labelCategoryInterval: o }) } function kh(t, e) { var i = Lh(t, "ticks"), n = ph(e), r = Oh(i, n); if (r) return r; var a, o; if ((!e.get("show") || t.scale.isBlank()) && (a = []), b(n)) a = Fh(t, n, !0); else if ("auto" === n) { var s = Ch(t, t.getLabelModel()); o = s.labelCategoryInterval, a = p(s.labels, function (t) { return t.tickValue }) } else o = n, a = Nh(t, o, !0); return zh(i, n, { ticks: a, tickCategoryInterval: o }) } function Ph(t) { var e = t.scale.getTicks(), i = hh(t); return { labels: p(e, function (e, n) { return { formattedLabel: i(e, n), rawLabel: t.scale.getLabel(e), tickValue: e } }) } } function Lh(t, e) { return Mw(t)[e] || (Mw(t)[e] = []) } function Oh(t, e) { for (var i = 0; i < t.length; i++)if (t[i].key === e) return t[i].value } function zh(t, e, i) { return t.push({ key: e, value: i }), i } function Eh(t) { var e = Mw(t).autoInterval; return null != e ? e : Mw(t).autoInterval = t.calculateCategoryInterval() } function Bh(t) { var e = Rh(t), i = hh(t), n = (e.axisRotate - e.labelRotate) / 180 * Math.PI, r = t.scale, a = r.getExtent(), o = r.count(); if (a[1] - a[0] < 1) return 0; var s = 1; o > 40 && (s = Math.max(1, Math.floor(o / 40))); for (var l = a[0], u = t.dataToCoord(l + 1) - t.dataToCoord(l), h = Math.abs(u * Math.cos(n)), c = Math.abs(u * Math.sin(n)), d = 0, f = 0; l <= a[1]; l += s) { var p = 0, g = 0, m = Bi(i(l), e.font, "center", "top"); p = 1.3 * m.width, g = 1.3 * m.height, d = Math.max(d, p, 7), f = Math.max(f, g, 7) } var v = d / h, y = f / c; isNaN(v) && (v = 1 / 0), isNaN(y) && (y = 1 / 0); var x = Math.max(0, Math.floor(Math.min(v, y))), _ = Mw(t.model), b = _.lastAutoInterval, w = _.lastTickCount; return null != b && null != w && Math.abs(b - x) <= 1 && Math.abs(w - o) <= 1 && b > x ? x = b : (_.lastTickCount = o, _.lastAutoInterval = x), x } function Rh(t) { var e = t.getLabelModel(); return { axisRotate: t.getRotate ? t.getRotate() : t.isHorizontal && !t.isHorizontal() ? 90 : 0, labelRotate: e.get("rotate") || 0, font: e.getFont() } } function Nh(t, e, i) { function n(t) { l.push(i ? t : { formattedLabel: r(t), rawLabel: a.getLabel(t), tickValue: t }) } var r = hh(t), a = t.scale, o = a.getExtent(), s = t.getLabelModel(), l = [], u = Math.max((e || 0) + 1, 1), h = o[0], c = a.count(); 0 !== h && u > 1 && c / u > 2 && (h = Math.round(Math.ceil(h / u) * u)); var d = gh(t), f = s.get("showMinLabel") || d, p = s.get("showMaxLabel") || d; f && h !== o[0] && n(o[0]); for (var g = h; g <= o[1]; g += u)n(g); return p && g !== o[1] && n(o[1]), l } function Fh(t, e, i) { var n = t.scale, r = hh(t), a = []; return f(n.getTicks(), function (t) { var o = n.getLabel(t); e(t, o) && a.push(i ? t : { formattedLabel: r(t), rawLabel: o, tickValue: t }) }), a } function Vh(t, e) { var i = t[1] - t[0], n = e, r = i / n / 2; t[0] += r, t[1] -= r } function Gh(t, e, i, n, r) { function a(t, e) { return h ? t > e : e > t } var o = e.length; if (t.onBand && !n && o) { var s, l = t.getExtent(); if (1 === o) e[0].coord = l[0], s = e[1] = { coord: l[0] }; else { var u = e[1].coord - e[0].coord; f(e, function (t) { t.coord -= u / 2; var e = e || 0; e % 2 > 0 && (t.coord -= u / (2 * (e + 1))) }), s = { coord: e[o - 1].coord + u }, e.push(s) } var h = l[0] > l[1]; a(e[0].coord, l[0]) && (r ? e[0].coord = l[0] : e.shift()), r && a(l[0], e[0].coord) && e.unshift({ coord: l[0] }), a(l[1], s.coord) && (r ? s.coord = l[1] : e.pop()), r && a(s.coord, l[1]) && e.push({ coord: l[1] }) } } function Hh(t) { return this._axes[t] } function Wh(t) { kw.call(this, t) } function Xh(t, e) { return e.type || (e.data ? "category" : "value") } function Uh(t, e) { return t.getCoordSysModel() === e } function jh(t, e, i) { this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this._initCartesian(t, e, i), this.model = t } function Yh(t, e, i, n) { function r(t) { return t.dim + "_" + t.index } i.getAxesOnZeroOf = function () { return a ? [a] : [] }; var a, o = t[e], s = i.model, l = s.get("axisLine.onZero"), u = s.get("axisLine.onZeroAxisIndex"); if (l) { if (null != u) qh(o[u]) && (a = o[u]); else for (var h in o) if (o.hasOwnProperty(h) && qh(o[h]) && !n[r(o[h])]) { a = o[h]; break } a && (n[r(a)] = !0) } } function qh(t) { return t && "category" !== t.type && "time" !== t.type && uh(t) } function Zh(t, e) { var i = t.getExtent(), n = i[0] + i[1]; t.toGlobalCoord = "x" === t.dim ? function (t) { return t + e } : function (t) { return n - t + e }, t.toLocalCoord = "x" === t.dim ? function (t) { return t - e } : function (t) { return n - t + e } } function Kh(t) { return p(Fw, function (e) { var i = t.getReferringComponents(e)[0]; return i }) } function $h(t) { return "cartesian2d" === t.get("coordinateSystem") } function Qh(t, e) { var i = t.mapDimension("defaultedLabel", !0), n = i.length; if (1 === n) return Ds(t, e, i[0]); if (n) { for (var r = [], a = 0; a < i.length; a++) { var o = Ds(t, e, i[a]); r.push(o) } return r.join(" ") } } function Jh(t, e, i, n, r, a) { var o = i.getModel("label"), s = i.getModel("emphasis.label"); wa(t, e, o, s, { labelFetcher: r, labelDataIndex: a, defaultText: Qh(r.getData(), a), isRectText: !0, autoColor: n }), tc(t), tc(e) } function tc(t, e) { "outside" === t.textPosition && (t.textPosition = e) } function ec(t, e, i) { i.style.text = null, Oa(i, { shape: { width: 0 } }, e, t, function () { i.parent && i.parent.remove(i) }) } function ic(t, e, i) { i.style.text = null, Oa(i, { shape: { r: i.shape.r0 } }, e, t, function () { i.parent && i.parent.remove(i) }) } function nc(t, e, i, n, r, a, o, l) { var u = e.getItemVisual(i, "color"), h = e.getItemVisual(i, "opacity"), c = n.getModel("itemStyle"), d = n.getModel("emphasis.itemStyle").getBarItemStyle(); l || t.setShape("r", c.get("barBorderRadius") || 0), t.useStyle(s({ fill: u, opacity: h }, c.getBarItemStyle())); var f = n.getShallow("cursor"); f && t.attr("cursor", f); var p = o ? r.height > 0 ? "bottom" : "top" : r.width > 0 ? "left" : "right"; l || Jh(t.style, d, n, u, a, i, p), _a(t, d) } function rc(t, e) { var i = t.get(Ww) || 0; return Math.min(i, Math.abs(e.width), Math.abs(e.height)) } function ac(t, e, i) { var n = t.getData(), r = [], a = n.getLayout("valueAxisHorizontal") ? 1 : 0; r[1 - a] = n.getLayout("valueAxisStart"); var o = new jw({ shape: { points: n.getLayout("largePoints") }, incremental: !!i, __startPoint: r, __valueIdx: a }); e.add(o), oc(o, t, n) } function oc(t, e, i) { var n = i.getVisual("borderColor") || i.getVisual("color"), r = e.getModel("itemStyle").getItemStyle(["color", "borderColor"]); t.useStyle(r), t.style.fill = null, t.style.stroke = n, t.style.lineWidth = i.getLayout("barWidth") } function sc(t) { var e = { componentType: t.mainType, componentIndex: t.componentIndex }; return e[t.mainType + "Index"] = t.componentIndex, e } function lc(t, e, i, n) { var r, a, o = no(i - t.rotation), s = n[0] > n[1], l = "start" === e && !s || "start" !== e && s; return ro(o - Yw / 2) ? (a = l ? "bottom" : "top", r = "center") : ro(o - 1.5 * Yw) ? (a = l ? "top" : "bottom", r = "center") : (a = "middle", r = 1.5 * Yw > o && o > Yw / 2 ? l ? "left" : "right" : l ? "right" : "left"), { rotation: o, textAlign: r, textVerticalAlign: a } } function uc(t) { var e = t.get("tooltip"); return t.get("silent") || !(t.get("triggerEvent") || e && e.show) } function hc(t, e, i) { if (!gh(t.axis)) { var n = t.get("axisLabel.showMinLabel"), r = t.get("axisLabel.showMaxLabel"); e = e || [], i = i || []; var a = e[0], o = e[1], s = e[e.length - 1], l = e[e.length - 2], u = i[0], h = i[1], c = i[i.length - 1], d = i[i.length - 2]; n === !1 ? (cc(a), cc(u)) : dc(a, o) && (n ? (cc(o), cc(h)) : (cc(a), cc(u))), r === !1 ? (cc(s), cc(c)) : dc(l, s) && (r ? (cc(l), cc(d)) : (cc(s), cc(c))) } } function cc(t) { t && (t.ignore = !0) } function dc(t, e) { var i = t && t.getBoundingRect().clone(), n = e && e.getBoundingRect().clone(); if (i && n) { var r = Ie([]); return Ce(r, r, -t.rotation), i.applyTransform(Te([], r, t.getLocalTransform())), n.applyTransform(Te([], r, e.getLocalTransform())), i.intersect(n) } } function fc(t) { return "middle" === t || "center" === t } function pc(t, e, i) { var n = e.axis; if (e.get("axisTick.show") && !n.scale.isBlank()) { for (var r = e.getModel("axisTick"), a = r.getModel("lineStyle"), o = r.get("length"), l = n.getTicksCoords(), u = [], h = [], c = t._transform, d = [], f = 0; f < l.length; f++) { var p = l[f].coord; u[0] = p, u[1] = 0, h[0] = p, h[1] = i.tickDirection * o, c && (ae(u, u, c), ae(h, h, c)); var g = new Sy(ra({ anid: "tick_" + l[f].tickValue, shape: { x1: u[0], y1: u[1], x2: h[0], y2: h[1] }, style: s(a.getLineStyle(), { stroke: e.get("axisLine.lineStyle.color") }), z2: 2, silent: !0 })); t.group.add(g), d.push(g) } return d } } function gc(t, e, i) { var n = e.axis, r = A(i.axisLabelShow, e.get("axisLabel.show")); if (r && !n.scale.isBlank()) { var a = e.getModel("axisLabel"), o = a.get("margin"), s = n.getViewLabels(), l = (A(i.labelRotate, a.get("rotate")) || 0) * Yw / 180, u = Kw(i.rotation, l, i.labelDirection), h = e.getCategories(!0), c = [], d = uc(e), p = e.get("triggerEvent"); return f(s, function (r, s) { var l = r.tickValue, f = r.formattedLabel, g = r.rawLabel, m = a; h && h[l] && h[l].textStyle && (m = new Ha(h[l].textStyle, a, e.ecModel)); var v = m.getTextColor() || e.get("axisLine.lineStyle.color"), y = n.dataToCoord(l), x = [y, i.labelOffset + i.labelDirection * o], _ = new uy({ anid: "label_" + l, position: x, rotation: u.rotation, silent: d, z2: 10 }); Sa(_.style, m, { text: f, textAlign: m.getShallow("align", !0) || u.textAlign, textVerticalAlign: m.getShallow("verticalAlign", !0) || m.getShallow("baseline", !0) || u.textVerticalAlign, textFill: "function" == typeof v ? v("category" === n.type ? g : "value" === n.type ? l + "" : l, s) : v }), p && (_.eventData = sc(e), _.eventData.targetType = "axisLabel", _.eventData.value = g), t._dumbGroup.add(_), _.updateTransform(), c.push(_), t.group.add(_), _.decomposeTransform() }), c } } function mc(t, e) { var i = { axesInfo: {}, seriesInvolved: !1, coordSysAxesInfo: {}, coordSysMap: {} }; return vc(i, t, e), i.seriesInvolved && xc(i, t), i } function vc(t, e, i) { var n = e.getComponent("tooltip"), r = e.getComponent("axisPointer"), a = r.get("link", !0) || [], o = []; $w(i.getCoordinateSystems(), function (i) { function s(n, s, l) { var h = l.model.getModel("axisPointer", r), d = h.get("show"); if (d && ("auto" !== d || n || Ic(h))) { null == s && (s = h.get("triggerTooltip")), h = n ? yc(l, c, r, e, n, s) : h; var f = h.get("snap"), p = Dc(l.model), g = s || f || "category" === l.type, m = t.axesInfo[p] = { key: p, axis: l, coordSys: i, axisPointerModel: h, triggerTooltip: s, involveSeries: g, snap: f, useHandle: Ic(h), seriesModels: [] }; u[p] = m, t.seriesInvolved |= g; var v = _c(a, l); if (null != v) { var y = o[v] || (o[v] = { axesInfo: {} }); y.axesInfo[p] = m, y.mapper = a[v].mapper, m.linkGroup = y } } } if (i.axisPointerEnabled) { var l = Dc(i.model), u = t.coordSysAxesInfo[l] = {}; t.coordSysMap[l] = i; var h = i.model, c = h.getModel("tooltip", n); if ($w(i.getAxes(), Qw(s, !1, null)), i.getTooltipAxes && n && c.get("show")) { var d = "axis" === c.get("trigger"), f = "cross" === c.get("axisPointer.type"), p = i.getTooltipAxes(c.get("axisPointer.axis")); (d || f) && $w(p.baseAxes, Qw(s, f ? "cross" : !0, d)), f && $w(p.otherAxes, Qw(s, "cross", !1)) } } }) } function yc(t, e, i, r, a, o) { var l = e.getModel("axisPointer"), u = {}; $w(["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], function (t) { u[t] = n(l.get(t)) }), u.snap = "category" !== t.type && !!o, "cross" === l.get("type") && (u.type = "line"); var h = u.label || (u.label = {}); if (null == h.show && (h.show = !1), "cross" === a) { var c = l.get("label.show"); if (h.show = null != c ? c : !0, !o) { var d = u.lineStyle = l.get("crossStyle"); d && s(h, d.textStyle) } } return t.model.getModel("axisPointer", new Ha(u, i, r)) } function xc(t, e) { e.eachSeries(function (e) { var i = e.coordinateSystem, n = e.get("tooltip.trigger", !0), r = e.get("tooltip.show", !0); i && "none" !== n && n !== !1 && "item" !== n && r !== !1 && e.get("axisPointer.show", !0) !== !1 && $w(t.coordSysAxesInfo[Dc(i.model)], function (t) { var n = t.axis; i.getAxis(n.dim) === n && (t.seriesModels.push(e), null == t.seriesDataCount && (t.seriesDataCount = 0), t.seriesDataCount += e.getData().count()) }) }, this) } function _c(t, e) { for (var i = e.model, n = e.dim, r = 0; r < t.length; r++) { var a = t[r] || {}; if (bc(a[n + "AxisId"], i.id) || bc(a[n + "AxisIndex"], i.componentIndex) || bc(a[n + "AxisName"], i.name)) return r } } function bc(t, e) { return "all" === t || _(t) && u(t, e) >= 0 || t === e } function wc(t) { var e = Sc(t); if (e) { var i = e.axisPointerModel, n = e.axis.scale, r = i.option, a = i.get("status"), o = i.get("value"); null != o && (o = n.parse(o)); var s = Ic(i); null == a && (r.status = s ? "show" : "hide"); var l = n.getExtent().slice(); l[0] > l[1] && l.reverse(), (null == o || o > l[1]) && (o = l[1]), o < l[0] && (o = l[0]), r.value = o, s && (r.status = e.axis.scale.isBlank() ? "hide" : "show") } } function Sc(t) { var e = (t.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo; return e && e.axesInfo[Dc(t)] } function Mc(t) { var e = Sc(t); return e && e.axisPointerModel } function Ic(t) { return !!t.get("handle.show") } function Dc(t) { return t.type + "||" + t.id } function Tc(t, e, i, n, r, a) { var o = Jw.getAxisPointerClass(t.axisPointerClass); if (o) { var s = Mc(e); s ? (t._axisPointer || (t._axisPointer = new o)).render(e, s, n, a) : Ac(t, n) } } function Ac(t, e, i) { var n = t._axisPointer; n && n.dispose(e, i), t._axisPointer = null } function Cc(t, e, i) { i = i || {}; var n = t.coordinateSystem, r = e.axis, a = {}, o = r.getAxesOnZeroOf()[0], s = r.position, l = o ? "onZero" : s, u = r.dim, h = n.getRect(), c = [h.x, h.x + h.width, h.y, h.y + h.height], d = { left: 0, right: 1, top: 0, bottom: 1, onZero: 2 }, f = e.get("offset") || 0, p = "x" === u ? [c[2] - f, c[3] + f] : [c[0] - f, c[1] + f]; if (o) { var g = o.toGlobalCoord(o.dataToCoord(0)); p[d.onZero] = Math.max(Math.min(g, p[1]), p[0]) } a.position = ["y" === u ? p[d[l]] : c[0], "x" === u ? p[d[l]] : c[3]], a.rotation = Math.PI / 2 * ("x" === u ? 0 : 1); var m = { top: -1, bottom: 1, left: -1, right: 1 }; a.labelDirection = a.tickDirection = a.nameDirection = m[s], a.labelOffset = o ? p[d[s]] - p[d.onZero] : 0, e.get("axisTick.inside") && (a.tickDirection = -a.tickDirection), A(i.labelInside, e.get("axisLabel.inside")) && (a.labelDirection = -a.labelDirection); var v = e.get("axisLabel.rotate"); return a.labelRotate = "top" === l ? -v : v, a.z2 = 1, a } function kc(t, e, i) { $g.call(this), this.updateData(t, e, i) } function Pc(t) { return [t[0] / 2, t[1] / 2] } function Lc(t, e) { this.parent.drift(t, e) } function Oc() { !ga(this) && Ec.call(this) } function zc() { !ga(this) && Bc.call(this) } function Ec() { if (!this.incremental && !this.useHoverLayer) { var t = this.__symbolOriginalScale, e = t[1] / t[0]; this.animateTo({ scale: [Math.max(1.1 * t[0], t[0] + 3), Math.max(1.1 * t[1], t[1] + 3 * e)] }, 400, "elasticOut") } } function Bc() { this.incremental || this.useHoverLayer || this.animateTo({ scale: this.__symbolOriginalScale }, 400, "elasticOut") } function Rc(t) { this.group = new $g, this._symbolCtor = t || kc } function Nc(t, e, i, n) { return !(!e || isNaN(e[0]) || isNaN(e[1]) || n.isIgnore && n.isIgnore(i) || n.clipShape && !n.clipShape.contain(e[0], e[1]) || "none" === t.getItemVisual(i, "symbol")) } function Fc(t) { return null == t || S(t) || (t = { isIgnore: t }), t || {} } function Vc(t) { var e = t.hostModel; return { itemStyle: e.getModel("itemStyle").getItemStyle(["color"]), hoverItemStyle: e.getModel("emphasis.itemStyle").getItemStyle(), symbolRotate: e.get("symbolRotate"), symbolOffset: e.get("symbolOffset"), hoverAnimation: e.get("hoverAnimation"), labelModel: e.getModel("label"), hoverLabelModel: e.getModel("emphasis.label"), cursorStyle: e.get("cursor") } } function Gc(t, e, i) { var n, r = t.getBaseAxis(), a = t.getOtherAxis(r), o = Hc(a, i), s = r.dim, l = a.dim, u = e.mapDimension(l), h = e.mapDimension(s), c = "x" === l || "radius" === l ? 1 : 0, d = p(t.dimensions, function (t) { return e.mapDimension(t) }), f = e.getCalculationInfo("stackResultDimension"); return (n |= zu(e, d[0])) && (d[0] = f), (n |= zu(e, d[1])) && (d[1] = f), { dataDimsForPoint: d, valueStart: o, valueAxisDim: l, baseAxisDim: s, stacked: !!n, valueDim: u, baseDim: h, baseDataOffset: c, stackedOverDimension: e.getCalculationInfo("stackedOverDimension") } } function Hc(t, e) { var i = 0, n = t.scale.getExtent(); return "start" === e ? i = n[0] : "end" === e ? i = n[1] : n[0] > 0 ? i = n[0] : n[1] < 0 && (i = n[1]), i } function Wc(t, e, i, n) { var r = 0 / 0; t.stacked && (r = i.get(i.getCalculationInfo("stackedOverDimension"), n)), isNaN(r) && (r = t.valueStart); var a = t.baseDataOffset, o = []; return o[a] = i.get(t.baseDim, n), o[1 - a] = r, e.dataToPoint(o) } function Xc(t, e) { var i = []; return e.diff(t).add(function (t) { i.push({ cmd: "+", idx: t }) }).update(function (t, e) { i.push({ cmd: "=", idx: e, idx1: t }) }).remove(function (t) { i.push({ cmd: "-", idx: t }) }).execute(), i } function Uc(t) { return isNaN(t[0]) || isNaN(t[1]) } function jc(t, e, i, n, r, a, o, s, l, u) { return "none" !== u && u ? Yc.apply(this, arguments) : qc.apply(this, arguments) } function Yc(t, e, i, n, r, a, o, s, l, u, h) { for (var c = 0, d = i, f = 0; n > f; f++) { var p = e[d]; if (d >= r || 0 > d) break; if (Uc(p)) { if (h) { d += a; continue } break } if (d === i) t[a > 0 ? "moveTo" : "lineTo"](p[0], p[1]); else if (l > 0) { var g = e[c], m = "y" === u ? 1 : 0, v = (p[m] - g[m]) * l; gS(vS, g), vS[m] = g[m] + v, gS(yS, p), yS[m] = p[m] - v, t.bezierCurveTo(vS[0], vS[1], yS[0], yS[1], p[0], p[1]) } else t.lineTo(p[0], p[1]); c = d, d += a } return f } function qc(t, e, i, n, r, a, o, s, l, u, h) { for (var c = 0, d = i, f = 0; n > f; f++) { var p = e[d]; if (d >= r || 0 > d) break; if (Uc(p)) { if (h) { d += a; continue } break } if (d === i) t[a > 0 ? "moveTo" : "lineTo"](p[0], p[1]), gS(vS, p); else if (l > 0) { var g = d + a, m = e[g]; if (h) for (; m && Uc(e[g]);)g += a, m = e[g]; var v = .5, y = e[c], m = e[g]; if (!m || Uc(m)) gS(yS, p); else { Uc(m) && !h && (m = p), Y(mS, m, y); var x, _; if ("x" === u || "y" === u) { var b = "x" === u ? 0 : 1; x = Math.abs(p[b] - y[b]), _ = Math.abs(p[b] - m[b]) } else x = ag(p, y), _ = ag(p, m); v = _ / (_ + x), pS(yS, p, mS, -l * (1 - v)) } dS(vS, vS, s), fS(vS, vS, o), dS(yS, yS, s), fS(yS, yS, o), t.bezierCurveTo(vS[0], vS[1], yS[0], yS[1], p[0], p[1]), pS(vS, p, mS, l * v) } else t.lineTo(p[0], p[1]); c = d, d += a } return f } function Zc(t, e) { var i = [1 / 0, 1 / 0], n = [-1 / 0, -1 / 0]; if (e) for (var r = 0; r < t.length; r++) { var a = t[r]; a[0] < i[0] && (i[0] = a[0]), a[1] < i[1] && (i[1] = a[1]), a[0] > n[0] && (n[0] = a[0]), a[1] > n[1] && (n[1] = a[1]) } return { min: e ? i : n, max: e ? n : i } } function Kc(t, e) { if (t.length === e.length) { for (var i = 0; i < t.length; i++) { var n = t[i], r = e[i]; if (n[0] !== r[0] || n[1] !== r[1]) return } return !0 } } function $c(t) { return "number" == typeof t ? t : t ? .5 : 0 } function Qc(t) { var e = t.getGlobalExtent(); if (t.onBand) { var i = t.getBandWidth() / 2 - 1, n = e[1] > e[0] ? 1 : -1; e[0] += n * i, e[1] -= n * i } return e } function Jc(t, e, i) { if (!i.valueDim) return []; for (var n = [], r = 0, a = e.count(); a > r; r++)n.push(Wc(i, t, e, r)); return n } function td(t, e, i, n) { var r = Qc(t.getAxis("x")), a = Qc(t.getAxis("y")), o = t.getBaseAxis().isHorizontal(), s = Math.min(r[0], r[1]), l = Math.min(a[0], a[1]), u = Math.max(r[0], r[1]) - s, h = Math.max(a[0], a[1]) - l; if (i) s -= .5, u += .5, l -= .5, h += .5; else { var c = n.get("lineStyle.width") || 2, d = n.get("clipOverflow") ? c / 2 : Math.max(u, h); o ? (l -= d, h += 2 * d) : (s -= d, u += 2 * d) } var f = new by({ shape: { x: s, y: l, width: u, height: h } }); return e && (f.shape[o ? "width" : "height"] = 0, za(f, { shape: { width: u, height: h } }, n)), f } function ed(t, e, i, n) { var r = t.getAngleAxis(), a = t.getRadiusAxis(), o = a.getExtent().slice(); o[0] > o[1] && o.reverse(); var s = r.getExtent(), l = Math.PI / 180; i && (o[0] -= .5, o[1] += .5); var u = new fy({ shape: { cx: $a(t.cx, 1), cy: $a(t.cy, 1), r0: $a(o[0], 1), r: $a(o[1], 1), startAngle: -s[0] * l, endAngle: -s[1] * l, clockwise: r.inverse } }); return e && (u.shape.endAngle = -s[0] * l, za(u, { shape: { endAngle: -s[1] * l } }, n)), u } function id(t, e, i, n) { return "polar" === t.type ? ed(t, e, i, n) : td(t, e, i, n) } function nd(t, e, i) { for (var n = e.getBaseAxis(), r = "x" === n.dim || "radius" === n.dim ? 0 : 1, a = [], o = 0; o < t.length - 1; o++) { var s = t[o + 1], l = t[o]; a.push(l); var u = []; switch (i) { case "end": u[r] = s[r], u[1 - r] = l[1 - r], a.push(u); break; case "middle": var h = (l[r] + s[r]) / 2, c = []; u[r] = c[r] = h, u[1 - r] = l[1 - r], c[1 - r] = s[1 - r], a.push(u), a.push(c); break; default: u[r] = l[r], u[1 - r] = s[1 - r], a.push(u) } } return t[o] && a.push(t[o]), a } function rd(t, e) { var i = t.getVisual("visualMeta"); if (i && i.length && t.count() && "cartesian2d" === e.type) { for (var n, r, a = i.length - 1; a >= 0; a--) { var o = i[a].dimension, s = t.dimensions[o], l = t.getDimensionInfo(s); if (n = l && l.coordDim, "x" === n || "y" === n) { r = i[a]; break } } if (r) { var u = e.getAxis(n), h = p(r.stops, function (t) { return { coord: u.toGlobalCoord(u.dataToCoord(t.value)), color: t.color } }), c = h.length, d = r.outerColors.slice(); c && h[0].coord > h[c - 1].coord && (h.reverse(), d.reverse()); var g = 10, m = h[0].coord - g, v = h[c - 1].coord + g, y = v - m; if (.001 > y) return "transparent"; f(h, function (t) { t.offset = (t.coord - m) / y }), h.push({ offset: c ? h[c - 1].offset : .5, color: d[1] || "transparent" }), h.unshift({ offset: c ? h[0].offset : .5, color: d[0] || "transparent" }); var x = new Cy(0, 0, 0, 0, h, !0); return x[n] = m, x[n + "2"] = v, x } } } function ad(t, e, i) { var n = t.get("showAllSymbol"), r = "auto" === n; if (!n || r) { var a = i.getAxesByScale("ordinal")[0]; if (a && (!r || !od(a, e))) { var o = e.mapDimension(a.dim), s = {}; return f(a.getViewLabels(), function (t) { s[t.tickValue] = 1 }), function (t) { return !s.hasOwnProperty(e.get(o, t)) } } } } function od(t, e) { var i = t.getExtent(), n = Math.abs(i[1] - i[0]) / t.scale.count(); isNaN(n) && (n = 0); for (var r = e.count(), a = Math.max(1, Math.round(r / 5)), o = 0; r > o; o += a)if (1.5 * kc.getSymbolSize(e, o)[t.isHorizontal() ? 1 : 0] > n) return !1; return !0 } function sd(t, e, i, n) { var r = e.getData(), a = this.dataIndex, o = r.getName(a), s = e.get("selectedOffset"); n.dispatchAction({ type: "pieToggleSelect", from: t, name: o, seriesId: e.id }), r.each(function (t) { ld(r.getItemGraphicEl(t), r.getItemLayout(t), e.isSelected(r.getName(t)), s, i) }) } function ld(t, e, i, n, r) { var a = (e.startAngle + e.endAngle) / 2, o = Math.cos(a), s = Math.sin(a), l = i ? n : 0, u = [o * l, s * l]; r ? t.animate().when(200, { position: u }).start("bounceOut") : t.attr("position", u) } function ud(t, e) { function i() { a.ignore = a.hoverIgnore, o.ignore = o.hoverIgnore } function n() { a.ignore = a.normalIgnore, o.ignore = o.normalIgnore } $g.call(this); var r = new fy({ z2: 2 }), a = new yy, o = new uy; this.add(r), this.add(a), this.add(o), this.updateData(t, e, !0), this.on("emphasis", i).on("normal", n).on("mouseover", i).on("mouseout", n) } function hd(t, e, i, n, r, a, o) {
    function s(e, i, n) { for (var r = e; i > r; r++)if (t[r].y += n, r > e && i > r + 1 && t[r + 1].y > t[r].y + t[r].height) return void l(r, n / 2); l(i - 1, n / 2) } function l(e, i) { for (var n = e; n >= 0 && (t[n].y -= i, !(n > 0 && t[n].y > t[n - 1].y + t[n - 1].height)); n--); } function u(t, e, i, n, r, a) {
      for (var o = a > 0 ? e ? Number.MAX_VALUE : 0 : e ? Number.MAX_VALUE : 0, s = 0, l = t.length; l > s; s++) {
        var u = Math.abs(t[s].y - n), h = t[s].len, c = t[s].len2, d = r + h > u ? Math.sqrt((r + h + c) * (r + h + c) - u * u) : Math.abs(t[s].x - i);
        e && d >= o && (d = o - 10), !e && o >= d && (d = o + 10), t[s].x = i + d * a, o = d
      }
    } t.sort(function (t, e) { return t.y - e.y }); for (var h, c = 0, d = t.length, f = [], p = [], g = 0; d > g; g++)h = t[g].y - c, 0 > h && s(g, d, -h, r), c = t[g].y + t[g].height; 0 > o - c && l(d - 1, c - o); for (var g = 0; d > g; g++)t[g].y >= i ? p.push(t[g]) : f.push(t[g]); u(f, !1, e, i, n, r), u(p, !0, e, i, n, r)
  } function cd(t, e, i, n, r, a) { for (var o = [], s = [], l = 0; l < t.length; l++)dd(t[l]) || (t[l].x < e ? o.push(t[l]) : s.push(t[l])); hd(s, e, i, n, 1, r, a), hd(o, e, i, n, -1, r, a); for (var l = 0; l < t.length; l++)if (!dd(t[l])) { var u = t[l].linePoints; if (u) { var h = u[1][0] - u[2][0]; u[2][0] = t[l].x < e ? t[l].x + 3 : t[l].x - 3, u[1][1] = u[2][1] = t[l].y, u[1][0] = u[2][0] + h } } } function dd(t) { return "center" === t.position } function fd() { this.group = new $g } function pd(t) { return _(t) || (t = [+t, +t]), t } function gd(t, e) { t.eachChild(function (t) { t.attr({ z: e.z, zlevel: e.zlevel, style: { stroke: "stroke" === e.brushType ? e.color : null, fill: "fill" === e.brushType ? e.color : null } }) }) } function md(t, e) { $g.call(this); var i = new kc(t, e), n = new $g; this.add(i), this.add(n), n.beforeUpdate = function () { this.attr(i.getScale()) }, this.updateData(t, e) } function vd(t, e, i) { var n = t.ends; return new YS({ shape: { points: i ? xd(n, t) : n }, z2: 100 }) } function yd(t, e, i, n) { var r = e.getItemModel(i), a = r.getModel(XS), o = e.getItemVisual(i, "color"), s = e.getItemVisual(i, "borderColor") || o, l = a.getItemStyle(jS); t.useStyle(l), t.style.strokeNoScale = !0, t.style.fill = o, t.style.stroke = s, t.__simpleBox = n; var u = r.getModel(US).getItemStyle(); _a(t, u) } function xd(t, e) { return p(t, function (t) { return t = t.slice(), t[1] = e.initBaseline, t }) } function _d(t, e, i) { var n = t.getData(), r = n.getLayout("largePoints"), a = new qS({ shape: { points: r }, __sign: 1 }); e.add(a); var o = new qS({ shape: { points: r }, __sign: -1 }); e.add(o), bd(1, a, t, n), bd(-1, o, t, n), i && (a.incremental = !0, o.incremental = !0) } function bd(t, e, i, n) { var r = t > 0 ? "P" : "N", a = n.getVisual("borderColor" + r) || n.getVisual("color" + r), o = i.getModel(XS).getItemStyle(jS); e.useStyle(o), e.style.fill = null, e.style.stroke = a } function wd(t, e, i, n, r) { var a; return a = i > n ? -1 : n > i ? 1 : e > 0 ? t.get(r, e - 1) <= n ? 1 : -1 : 1 } function Sd(t, e) { var i, n = t.getBaseAxis(), r = "category" === n.type ? n.getBandWidth() : (i = n.getExtent(), Math.abs(i[1] - i[0]) / e.count()), a = Ka(C(t.get("barMaxWidth"), r), r), o = Ka(C(t.get("barMinWidth"), 1), r), s = t.get("barWidth"); return null != s ? Ka(s, r) : Math.max(Math.min(r / 2, a), o) } function Md(t, e, i) { Dw.call(this, t, e, i), this.type = "value", this.angle = 0, this.name = "", this.model } function Id(t, e, i) { this._model = t, this.dimensions = [], this._indicatorAxes = p(t.getIndicatorModels(), function (t, e) { var i = "indicator_" + e, n = new Md(i, new Gb); return n.name = t.get("name"), n.model = t, t.axis = n, this.dimensions.push(i), n }, this), this.resize(t, i), this.cx, this.cy, this.r, this.r0, this.startAngle } function Dd(t, e) { return s({ show: e }, t) } function Td(t) { return _(t) || (t = [+t, +t]), t } function Ad(t, e, i) { this.dimension = "single", this.dimensions = ["single"], this._axis = null, this._rect, this._init(t, e, i), this.model = t } function Cd(t, e) { var i = []; return t.eachComponent("singleAxis", function (n, r) { var a = new Ad(n, t, e); a.name = "single_" + r, a.resize(n, e), n.coordinateSystem = a, i.push(a) }), t.eachSeries(function (e) { if ("singleAxis" === e.get("coordinateSystem")) { var i = t.queryComponents({ mainType: "singleAxis", index: e.get("singleAxisIndex"), id: e.get("singleAxisId") })[0]; e.coordinateSystem = i && i.coordinateSystem } }), i } function kd(t, e) { e = e || {}; var i = t.coordinateSystem, n = t.axis, r = {}, a = n.position, o = n.orient, s = i.getRect(), l = [s.x, s.x + s.width, s.y, s.y + s.height], u = { horizontal: { top: l[2], bottom: l[3] }, vertical: { left: l[0], right: l[1] } }; r.position = ["vertical" === o ? u.vertical[a] : l[0], "horizontal" === o ? u.horizontal[a] : l[3]]; var h = { horizontal: 0, vertical: 1 }; r.rotation = Math.PI / 2 * h[o]; var c = { top: -1, bottom: 1, right: 1, left: -1 }; r.labelDirection = r.tickDirection = r.nameDirection = c[a], t.get("axisTick.inside") && (r.tickDirection = -r.tickDirection), A(e.labelInside, t.get("axisLabel.inside")) && (r.labelDirection = -r.labelDirection); var d = e.rotate; return null == d && (d = t.get("axisLabel.rotate")), r.labelRotation = "top" === a ? -d : d, r.z2 = 1, r } function Pd(t, e) { return e.type || (e.data ? "category" : "value") } function Ld(t, e, i, n, r) { var a = t.axis; if (!a.scale.isBlank() && a.containData(e)) { if (!t.involveSeries) return void i.showPointer(t, e); var s = Od(e, t), l = s.payloadBatch, u = s.snapToValue; l[0] && null == r.seriesIndex && o(r, l[0]), !n && t.snap && a.containData(u) && null != u && (e = u), i.showPointer(t, e, l, r), i.showTooltip(t, s, u) } } function Od(t, e) { var i = e.axis, n = i.dim, r = t, a = [], o = Number.MAX_VALUE, s = -1; return gM(e.seriesModels, function (e) { var l, u, h = e.getData().mapDimension(n, !0); if (e.getAxisTooltipData) { var c = e.getAxisTooltipData(h, t, i); u = c.dataIndices, l = c.nestestValue } else { if (u = e.getData().indicesOfNearest(h[0], t, "category" === i.type ? .5 : null), !u.length) return; l = e.getData().get(h[0], u[0]) } if (null != l && isFinite(l)) { var d = t - l, f = Math.abs(d); o >= f && ((o > f || d >= 0 && 0 > s) && (o = f, s = d, r = l, a.length = 0), gM(u, function (t) { a.push({ seriesIndex: e.seriesIndex, dataIndexInside: t, dataIndex: e.getData().getRawIndex(t) }) })) } }), { payloadBatch: a, snapToValue: r } } function zd(t, e, i, n) { t[e.key] = { value: i, payloadBatch: n } } function Ed(t, e, i, n) { var r = i.payloadBatch, a = e.axis, o = a.model, s = e.axisPointerModel; if (e.triggerTooltip && r.length) { var l = e.coordSys.model, u = Dc(l), h = t.map[u]; h || (h = t.map[u] = { coordSysId: l.id, coordSysIndex: l.componentIndex, coordSysType: l.type, coordSysMainType: l.mainType, dataByAxis: [] }, t.list.push(h)), h.dataByAxis.push({ axisDim: a.dim, axisIndex: o.componentIndex, axisType: o.type, axisId: o.id, value: n, valueLabelOpt: { precision: s.get("label.precision"), formatter: s.get("label.formatter") }, seriesDataIndices: r.slice() }) } } function Bd(t, e, i) { var n = i.axesInfo = []; gM(e, function (e, i) { var r = e.axisPointerModel.option, a = t[i]; a ? (!e.useHandle && (r.status = "show"), r.value = a.value, r.seriesDataIndices = (a.payloadBatch || []).slice()) : !e.useHandle && (r.status = "hide"), "show" === r.status && n.push({ axisDim: e.axis.dim, axisIndex: e.axis.model.componentIndex, value: r.value }) }) } function Rd(t, e, i, n) { if (Gd(e) || !t.list.length) return void n({ type: "hideTip" }); var r = ((t.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {}; n({ type: "showTip", escapeConnect: !0, x: e[0], y: e[1], tooltipOption: i.tooltipOption, position: i.position, dataIndexInside: r.dataIndexInside, dataIndex: r.dataIndex, seriesIndex: r.seriesIndex, dataByCoordSys: t.list }) } function Nd(t, e, i) { var n = i.getZr(), r = "axisPointerLastHighlights", a = vM(n)[r] || {}, o = vM(n)[r] = {}; gM(t, function (t) { var e = t.axisPointerModel.option; "show" === e.status && gM(e.seriesDataIndices, function (t) { var e = t.seriesIndex + " | " + t.dataIndex; o[e] = t }) }); var s = [], l = []; f(a, function (t, e) { !o[e] && l.push(t) }), f(o, function (t, e) { !a[e] && s.push(t) }), l.length && i.dispatchAction({ type: "downplay", escapeConnect: !0, batch: l }), s.length && i.dispatchAction({ type: "highlight", escapeConnect: !0, batch: s }) } function Fd(t, e) { for (var i = 0; i < (t || []).length; i++) { var n = t[i]; if (e.axis.dim === n.axisDim && e.axis.model.componentIndex === n.axisIndex) return n } } function Vd(t) { var e = t.axis.model, i = {}, n = i.axisDim = t.axis.dim; return i.axisIndex = i[n + "AxisIndex"] = e.componentIndex, i.axisName = i[n + "AxisName"] = e.name, i.axisId = i[n + "AxisId"] = e.id, i } function Gd(t) { return !t || null == t[0] || isNaN(t[0]) || null == t[1] || isNaN(t[1]) } function Hd(t, e, i) { if (!Gp.node) { var n = e.getZr(); xM(n).records || (xM(n).records = {}), Wd(n, e); var r = xM(n).records[t] || (xM(n).records[t] = {}); r.handler = i } } function Wd(t, e) { function i(i, n) { t.on(i, function (i) { var r = Yd(e); _M(xM(t).records, function (t) { t && n(t, i, r.dispatchAction) }), Xd(r.pendings, e) }) } xM(t).initialized || (xM(t).initialized = !0, i("click", x(jd, "click")), i("mousemove", x(jd, "mousemove")), i("globalout", Ud)) } function Xd(t, e) { var i, n = t.showTip.length, r = t.hideTip.length; n ? i = t.showTip[n - 1] : r && (i = t.hideTip[r - 1]), i && (i.dispatchAction = null, e.dispatchAction(i)) } function Ud(t, e, i) { t.handler("leave", null, i) } function jd(t, e, i, n) { e.handler(t, i, n) } function Yd(t) { var e = { showTip: [], hideTip: [] }, i = function (n) { var r = e[n.type]; r ? r.push(n) : (n.dispatchAction = i, t.dispatchAction(n)) }; return { dispatchAction: i, pendings: e } } function qd(t, e) { if (!Gp.node) { var i = e.getZr(), n = (xM(i).records || {})[t]; n && (xM(i).records[t] = null) } } function Zd() { } function Kd(t, e, i, n) { $d(wM(i).lastProp, n) || (wM(i).lastProp = n, e ? Oa(i, n, t) : (i.stopAnimation(), i.attr(n))) } function $d(t, e) { if (S(t) && S(e)) { var i = !0; return f(e, function (e, n) { i = i && $d(t[n], e) }), !!i } return t === e } function Qd(t, e) { t[e.get("label.show") ? "show" : "hide"]() } function Jd(t) { return { position: t.position.slice(), rotation: t.rotation || 0 } } function tf(t, e, i) { var n = e.get("z"), r = e.get("zlevel"); t && t.traverse(function (t) { "group" !== t.type && (null != n && (t.z = n), null != r && (t.zlevel = r), t.silent = i) }) } function ef(t) { var e, i = t.get("type"), n = t.getModel(i + "Style"); return "line" === i ? (e = n.getLineStyle(), e.fill = null) : "shadow" === i && (e = n.getAreaStyle(), e.stroke = null), e } function nf(t, e, i, n, r) { var a = i.get("value"), o = af(a, e.axis, e.ecModel, i.get("seriesDataIndices"), { precision: i.get("label.precision"), formatter: i.get("label.formatter") }), s = i.getModel("label"), l = Qy(s.get("padding") || 0), u = s.getFont(), h = Bi(o, u), c = r.position, d = h.width + l[1] + l[3], f = h.height + l[0] + l[2], p = r.align; "right" === p && (c[0] -= d), "center" === p && (c[0] -= d / 2); var g = r.verticalAlign; "bottom" === g && (c[1] -= f), "middle" === g && (c[1] -= f / 2), rf(c, d, f, n); var m = s.get("backgroundColor"); m && "auto" !== m || (m = e.get("axisLine.lineStyle.color")), t.label = { shape: { x: 0, y: 0, width: d, height: f, r: s.get("borderRadius") }, position: c.slice(), style: { text: o, textFont: u, textFill: s.getTextColor(), textPosition: "inside", fill: m, stroke: s.get("borderColor") || "transparent", lineWidth: s.get("borderWidth") || 0, shadowBlur: s.get("shadowBlur"), shadowColor: s.get("shadowColor"), shadowOffsetX: s.get("shadowOffsetX"), shadowOffsetY: s.get("shadowOffsetY") }, z2: 10 } } function rf(t, e, i, n) { var r = n.getWidth(), a = n.getHeight(); t[0] = Math.min(t[0] + e, r) - e, t[1] = Math.min(t[1] + i, a) - i, t[0] = Math.max(t[0], 0), t[1] = Math.max(t[1], 0) } function af(t, e, i, n, r) { t = e.scale.parse(t); var a = e.scale.getLabel(t, { precision: r.precision }), o = r.formatter; if (o) { var s = { value: ch(e, t), seriesData: [] }; f(n, function (t) { var e = i.getSeriesByIndex(t.seriesIndex), n = t.dataIndexInside, r = e && e.getDataParams(n); r && s.seriesData.push(r) }), w(o) ? a = o.replace("{value}", a) : b(o) && (a = o(s)) } return a } function of(t, e, i) { var n = Me(); return Ce(n, n, i.rotation), Ae(n, n, i.position), Ba([t.dataToCoord(e), (i.labelOffset || 0) + (i.labelDirection || 1) * (i.labelMargin || 0)], n) } function sf(t, e, i, n, r, a) { var o = qw.innerTextLayout(i.rotation, 0, i.labelDirection); i.labelMargin = r.get("label.margin"), nf(e, n, r, a, { position: of(n.axis, t, i), align: o.textAlign, verticalAlign: o.textVerticalAlign }) } function lf(t, e, i) { return i = i || 0, { x1: t[i], y1: t[1 - i], x2: e[i], y2: e[1 - i] } } function uf(t, e, i) { return i = i || 0, { x: t[i], y: t[1 - i], width: e[i], height: e[1 - i] } } function hf(t, e) { var i = {}; return i[e.dim + "AxisIndex"] = e.index, t.getCartesian(i) } function cf(t) { return "x" === t.dim ? 0 : 1 } function df(t) { return t.isHorizontal() ? 0 : 1 } function ff(t, e) { var i = t.getRect(); return [i[TM[e]], i[TM[e]] + i[AM[e]]] } function pf(t, e, i) { var n = new by({ shape: { x: t.x - 10, y: t.y - 10, width: 0, height: t.height + 20 } }); return za(n, { shape: { width: t.width + 20, height: t.height + 20 } }, e, i), n } function gf(t, e, i) { if (t.count()) for (var n, r = e.coordinateSystem, a = e.getLayerSeries(), o = t.mapDimension("single"), s = t.mapDimension("value"), l = p(a, function (e) { return p(e.indices, function (e) { var i = r.dataToPoint(t.get(o, e)); return i[1] = t.get(s, e), i }) }), u = mf(l), h = u.y0, c = i / u.max, d = a.length, f = a[0].indices.length, g = 0; f > g; ++g) { n = h[g] * c, t.setItemLayout(a[0].indices[g], { layerIndex: 0, x: l[0][g][0], y0: n, y: l[0][g][1] * c }); for (var m = 1; d > m; ++m)n += l[m - 1][g][1] * c, t.setItemLayout(a[m].indices[g], { layerIndex: m, x: l[m][g][0], y0: n, y: l[m][g][1] * c }) } } function mf(t) { for (var e, i = t.length, n = t[0].length, r = [], a = [], o = 0, s = {}, l = 0; n > l; ++l) { for (var u = 0, e = 0; i > u; ++u)e += t[u][l][1]; e > o && (o = e), r.push(e) } for (var h = 0; n > h; ++h)a[h] = (o - r[h]) / 2; o = 0; for (var c = 0; n > c; ++c) { var d = r[c] + a[c]; d > o && (o = d) } return s.y0 = a, s.max = o, s } function vf(t, e, i, n) { var r = t.getItemLayout(e), a = i.get("symbolRepeat"), o = i.get("symbolClip"), s = i.get("symbolPosition") || "start", l = i.get("symbolRotate"), u = (l || 0) * Math.PI / 180 || 0, h = i.get("symbolPatternSize") || 2, c = i.isAnimationEnabled(), d = { dataIndex: e, layout: r, itemModel: i, symbolType: t.getItemVisual(e, "symbol") || "circle", color: t.getItemVisual(e, "color"), symbolClip: o, symbolRepeat: a, symbolRepeatDirection: i.get("symbolRepeatDirection"), symbolPatternSize: h, rotation: u, animationModel: c ? i : null, hoverAnimation: c && i.get("hoverAnimation"), z2: i.getShallow("z", !0) || 0 }; yf(i, a, r, n, d), _f(t, e, r, a, o, d.boundingLength, d.pxSign, h, n, d), bf(i, d.symbolScale, u, n, d); var f = d.symbolSize, p = i.get("symbolOffset"); return _(p) && (p = [Ka(p[0], f[0]), Ka(p[1], f[1])]), wf(i, f, r, a, o, p, s, d.valueLineWidth, d.boundingLength, d.repeatCutLength, n, d), d } function yf(t, e, i, n, r) { var a, o = n.valueDim, s = t.get("symbolBoundingData"), l = n.coordSys.getOtherAxis(n.coordSys.getBaseAxis()), u = l.toGlobalCoord(l.dataToCoord(0)), h = 1 - +(i[o.wh] <= 0); if (_(s)) { var c = [xf(l, s[0]) - u, xf(l, s[1]) - u]; c[1] < c[0] && c.reverse(), a = c[h] } else a = null != s ? xf(l, s) - u : e ? n.coordSysExtent[o.index][h] - u : i[o.wh]; r.boundingLength = a, e && (r.repeatCutLength = i[o.wh]), r.pxSign = a > 0 ? 1 : 0 > a ? -1 : 0 } function xf(t, e) { return t.toGlobalCoord(t.dataToCoord(t.scale.parse(e))) } function _f(t, e, i, n, r, a, o, s, l, u) { var h = l.valueDim, c = l.categoryDim, d = Math.abs(i[c.wh]), f = t.getItemVisual(e, "symbolSize"); _(f) ? f = f.slice() : (null == f && (f = "100%"), f = [f, f]), f[c.index] = Ka(f[c.index], d), f[h.index] = Ka(f[h.index], n ? d : Math.abs(a)), u.symbolSize = f; var p = u.symbolScale = [f[0] / s, f[1] / s]; p[h.index] *= (l.isHorizontal ? -1 : 1) * o } function bf(t, e, i, n, r) { var a = t.get(BM) || 0; a && (NM.attr({ scale: e.slice(), rotation: i }), NM.updateTransform(), a /= NM.getLineScale(), a *= e[n.valueDim.index]), r.valueLineWidth = a } function wf(t, e, i, n, r, a, s, l, u, h, c, d) { var f = c.categoryDim, p = c.valueDim, g = d.pxSign, m = Math.max(e[p.index] + l, 0), v = m; if (n) { var y = Math.abs(u), x = A(t.get("symbolMargin"), "15%") + "", _ = !1; x.lastIndexOf("!") === x.length - 1 && (_ = !0, x = x.slice(0, x.length - 1)), x = Ka(x, e[p.index]); var b = Math.max(m + 2 * x, 0), w = _ ? 0 : 2 * x, S = co(n), M = S ? n : Ff((y + w) / b), I = y - M * m; x = I / 2 / (_ ? M : M - 1), b = m + 2 * x, w = _ ? 0 : 2 * x, S || "fixed" === n || (M = h ? Ff((Math.abs(h) + w) / b) : 0), v = M * b - w, d.repeatTimes = M, d.symbolMargin = x } var D = g * (v / 2), T = d.pathPosition = []; T[f.index] = i[f.wh] / 2, T[p.index] = "start" === s ? D : "end" === s ? u - D : u / 2, a && (T[0] += a[0], T[1] += a[1]); var C = d.bundlePosition = []; C[f.index] = i[f.xy], C[p.index] = i[p.xy]; var k = d.barRectShape = o({}, i); k[p.wh] = g * Math.max(Math.abs(i[p.wh]), Math.abs(T[p.index] + D)), k[f.wh] = i[f.wh]; var P = d.clipShape = {}; P[f.xy] = -i[f.xy], P[f.wh] = c.ecSize[f.wh], P[p.xy] = 0, P[p.wh] = i[p.wh] } function Sf(t) { var e = t.symbolPatternSize, i = vh(t.symbolType, -e / 2, -e / 2, e, e, t.color); return i.attr({ culling: !0 }), "image" !== i.type && i.setStyle({ strokeNoScale: !0 }), i } function Mf(t, e, i, n) { function r(t) { var e = h.slice(), n = i.pxSign, r = t; return ("start" === i.symbolRepeatDirection ? n > 0 : 0 > n) && (r = d - 1 - t), e[c.index] = p * (r - d / 2 + .5) + h[c.index], { position: e, scale: i.symbolScale.slice(), rotation: i.rotation } } function a() { Bf(t, function (t) { t.trigger("emphasis") }) } function o() { Bf(t, function (t) { t.trigger("normal") }) } var s = t.__pictorialBundle, l = i.symbolSize, u = i.valueLineWidth, h = i.pathPosition, c = e.valueDim, d = i.repeatTimes || 0, f = 0, p = l[e.valueDim.index] + u + 2 * i.symbolMargin; for (Bf(t, function (t) { t.__pictorialAnimationIndex = f, t.__pictorialRepeatTimes = d, d > f ? Rf(t, null, r(f), i, n) : Rf(t, null, { scale: [0, 0] }, i, n, function () { s.remove(t) }), Pf(t, i), f++ }); d > f; f++) { var g = Sf(i); g.__pictorialAnimationIndex = f, g.__pictorialRepeatTimes = d, s.add(g); var m = r(f); Rf(g, { position: m.position, scale: [0, 0] }, { scale: m.scale, rotation: m.rotation }, i, n), g.on("mouseover", a).on("mouseout", o), Pf(g, i) } } function If(t, e, i, n) { function r() { this.trigger("emphasis") } function a() { this.trigger("normal") } var o = t.__pictorialBundle, s = t.__pictorialMainPath; s ? Rf(s, null, { position: i.pathPosition.slice(), scale: i.symbolScale.slice(), rotation: i.rotation }, i, n) : (s = t.__pictorialMainPath = Sf(i), o.add(s), Rf(s, { position: i.pathPosition.slice(), scale: [0, 0], rotation: i.rotation }, { scale: i.symbolScale.slice() }, i, n), s.on("mouseover", r).on("mouseout", a)), Pf(s, i) } function Df(t, e, i) { var n = o({}, e.barRectShape), r = t.__pictorialBarRect; r ? Rf(r, null, { shape: n }, e, i) : (r = t.__pictorialBarRect = new by({ z2: 2, shape: n, silent: !0, style: { stroke: "transparent", fill: "transparent", lineWidth: 0 } }), t.add(r)) } function Tf(t, e, i, n) { if (i.symbolClip) { var r = t.__pictorialClipPath, a = o({}, i.clipShape), s = e.valueDim, l = i.animationModel, u = i.dataIndex; if (r) Oa(r, { shape: a }, l, u); else { a[s.wh] = 0, r = new by({ shape: a }), t.__pictorialBundle.setClipPath(r), t.__pictorialClipPath = r; var h = {}; h[s.wh] = i.clipShape[s.wh], Vy[n ? "updateProps" : "initProps"](r, { shape: h }, l, u) } } } function Af(t, e) { var i = t.getItemModel(e); return i.getAnimationDelayParams = Cf, i.isAnimationEnabled = kf, i } function Cf(t) { return { index: t.__pictorialAnimationIndex, count: t.__pictorialRepeatTimes } } function kf() { return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation") } function Pf(t, e) { t.off("emphasis").off("normal"); var i = e.symbolScale.slice(); e.hoverAnimation && t.on("emphasis", function () { this.animateTo({ scale: [1.1 * i[0], 1.1 * i[1]] }, 400, "elasticOut") }).on("normal", function () { this.animateTo({ scale: i.slice() }, 400, "elasticOut") }) } function Lf(t, e, i, n) { var r = new $g, a = new $g; return r.add(a), r.__pictorialBundle = a, a.attr("position", i.bundlePosition.slice()), i.symbolRepeat ? Mf(r, e, i) : If(r, e, i), Df(r, i, n), Tf(r, e, i, n), r.__pictorialShapeStr = Ef(t, i), r.__pictorialSymbolMeta = i, r } function Of(t, e, i) { var n = i.animationModel, r = i.dataIndex, a = t.__pictorialBundle; Oa(a, { position: i.bundlePosition.slice() }, n, r), i.symbolRepeat ? Mf(t, e, i, !0) : If(t, e, i, !0), Df(t, i, !0), Tf(t, e, i, !0) } function zf(t, e, i, n) { var r = n.__pictorialBarRect; r && (r.style.text = null); var a = []; Bf(n, function (t) { a.push(t) }), n.__pictorialMainPath && a.push(n.__pictorialMainPath), n.__pictorialClipPath && (i = null), f(a, function (t) { Oa(t, { scale: [0, 0] }, i, e, function () { n.parent && n.parent.remove(n) }) }), t.setItemGraphicEl(e, null) } function Ef(t, e) { return [t.getItemVisual(e.dataIndex, "symbol") || "none", !!e.symbolRepeat, !!e.symbolClip].join(":") } function Bf(t, e, i) { f(t.__pictorialBundle.children(), function (n) { n !== t.__pictorialBarRect && e.call(i, n) }) } function Rf(t, e, i, n, r, a) { e && t.attr(e), n.symbolClip && !r ? i && t.attr(i) : i && Vy[r ? "updateProps" : "initProps"](t, i, n.animationModel, n.dataIndex, a) } function Nf(t, e, i) { var n = i.color, r = i.dataIndex, a = i.itemModel, o = a.getModel("itemStyle").getItemStyle(["color"]), l = a.getModel("emphasis.itemStyle").getItemStyle(), u = a.getShallow("cursor"); Bf(t, function (t) { t.setColor(n), t.setStyle(s({ fill: n, opacity: i.opacity }, o)), _a(t, l), u && (t.cursor = u), t.z2 = i.z2 }); var h = {}, c = e.valueDim.posDesc[+(i.boundingLength > 0)], d = t.__pictorialBarRect; Jh(d.style, h, a, n, e.seriesModel, r, c), _a(d, h) } function Ff(t) { var e = Math.round(t); return Math.abs(t - e) < 1e-4 ? e : Math.ceil(t) } function Vf(t, e, i) { var n, r = {}, a = "toggleSelected" === t; return i.eachComponent("legend", function (i) { a && null != n ? i[n ? "select" : "unSelect"](e.name) : (i[t](e.name), n = i.isSelected(e.name)); var o = i.getData(); f(o, function (t) { var e = t.get("name"); if ("\n" !== e && "" !== e) { var n = i.isSelected(e); r[e] = r.hasOwnProperty(e) ? r[e] && n : n } }) }), { name: e.name, selected: r } } function Gf(t, e) { var i = Qy(e.get("padding")), n = e.getItemStyle(["color", "opacity"]); n.fill = e.get("backgroundColor"); var t = new by({ shape: { x: t.x - i[3], y: t.y - i[0], width: t.width + i[1] + i[3], height: t.height + i[0] + i[2], r: e.get("borderRadius") }, style: n, silent: !0, z2: -1 }); return t } function Hf(t, e) { e.dispatchAction({ type: "legendToggleSelect", name: t }) } function Wf(t, e, i, n) { var r = i.getZr().storage.getDisplayList()[0]; r && r.useHoverLayer || i.dispatchAction({ type: "highlight", seriesName: t, name: e, excludeSeriesId: n }) } function Xf(t, e, i, n) { var r = i.getZr().storage.getDisplayList()[0]; r && r.useHoverLayer || i.dispatchAction({ type: "downplay", seriesName: t, name: e, excludeSeriesId: n }) } function Uf(t, e, i) { var n = t.getOrient(), r = [1, 1]; r[n.index] = 0, Do(e, i, { type: "box", ignoreSize: r }) } function jf(t) { var e = "cubic-bezier(0.23, 1, 0.32, 1)", i = "left " + t + "s " + e + ",top " + t + "s " + e; return p(QM, function (t) { return t + "transition:" + i }).join(";") } function Yf(t) { var e = [], i = t.get("fontSize"), n = t.getTextColor(); return n && e.push("color:" + n), e.push("font:" + t.getFont()), i && e.push("line-height:" + Math.round(3 * i / 2) + "px"), KM(["decoration", "align"], function (i) { var n = t.get(i); n && e.push("text-" + i + ":" + n) }), e.join(";") } function qf(t) { var e = [], i = t.get("transitionDuration"), n = t.get("backgroundColor"), r = t.getModel("textStyle"), a = t.get("padding"); return i && e.push(jf(i)), n && (Gp.canvasSupported ? e.push("background-Color:" + n) : (e.push("background-Color:#" + Ze(n)), e.push("filter:alpha(opacity=70)"))), KM(["width", "color", "radius"], function (i) { var n = "border-" + i, r = $M(n), a = t.get(r); null != a && e.push(n + ":" + a + ("color" === i ? "" : "px")) }), e.push(Yf(r)), null != a && e.push("padding:" + Qy(a).join("px ") + "px"), e.join(";") + ";" } function Zf(t, e) { if (Gp.wxa) return null; var i = document.createElement("div"), n = this._zr = e.getZr(); this.el = i, this._x = e.getWidth() / 2, this._y = e.getHeight() / 2, t.appendChild(i), this._container = t, this._show = !1, this._hideTimeout; var r = this; i.onmouseenter = function () { r._enterable && (clearTimeout(r._hideTimeout), r._show = !0), r._inContent = !0 }, i.onmousemove = function (e) { if (e = e || window.event, !r._enterable) { var i = n.handler; ge(t, e, !0), i.dispatch("mousemove", e) } }, i.onmouseleave = function () { r._enterable && r._show && r.hideLater(r._hideDelay), r._inContent = !1 } } function Kf(t) { this._zr = t.getZr(), this._show = !1, this._hideTimeout } function $f(t) { for (var e = t.pop(); t.length;) { var i = t.pop(); i && (Ha.isInstance(i) && (i = i.get("tooltip", !0)), "string" == typeof i && (i = { formatter: i }), e = new Ha(i, e, e.ecModel)) } return e } function Qf(t, e) { return t.dispatchAction || y(e.dispatchAction, e) } function Jf(t, e, i, n, r, a, o) { var s = i.getOuterSize(), l = s.width, u = s.height; return null != a && (t + l + a > n ? t -= l + a : t += a), null != o && (e + u + o > r ? e -= u + o : e += o), [t, e] } function tp(t, e, i, n, r) { var a = i.getOuterSize(), o = a.width, s = a.height; return t = Math.min(t + o, n) - o, e = Math.min(e + s, r) - s, t = Math.max(t, 0), e = Math.max(e, 0), [t, e] } function ep(t, e, i) { var n = i[0], r = i[1], a = 5, o = 0, s = 0, l = e.width, u = e.height; switch (t) { case "inside": o = e.x + l / 2 - n / 2, s = e.y + u / 2 - r / 2; break; case "top": o = e.x + l / 2 - n / 2, s = e.y - r - a; break; case "bottom": o = e.x + l / 2 - n / 2, s = e.y + u + a; break; case "left": o = e.x - n - a, s = e.y + u / 2 - r / 2; break; case "right": o = e.x + l + a, s = e.y + u / 2 - r / 2 }return [o, s] } function ip(t) { return "center" === t || "middle" === t } function np(t) { Rn(t, "label", ["show"]) } function rp(t) { return !(isNaN(parseFloat(t.x)) && isNaN(parseFloat(t.y))) } function ap(t) { return !isNaN(parseFloat(t.x)) && !isNaN(parseFloat(t.y)) } function op(t, e, i, n, r, a) { var o = [], s = zu(e, n), l = s ? e.getCalculationInfo("stackResultDimension") : n, u = dp(e, l, t), h = e.indicesOfNearest(l, u)[0]; o[r] = e.get(i, h), o[a] = e.get(n, h); var c = Ja(e.get(n, h)); return c = Math.min(c, 20), c >= 0 && (o[a] = +o[a].toFixed(c)), o } function sp(t, e) { var i = t.getData(), r = t.coordinateSystem; if (e && !ap(e) && !_(e.coord) && r) { var a = r.dimensions, o = lp(e, i, r, t); if (e = n(e), e.type && uI[e.type] && o.baseAxis && o.valueAxis) { var s = sI(a, o.baseAxis.dim), l = sI(a, o.valueAxis.dim); e.coord = uI[e.type](i, o.baseDataDim, o.valueDataDim, s, l), e.value = e.coord[l] } else { for (var u = [null != e.xAxis ? e.xAxis : e.radiusAxis, null != e.yAxis ? e.yAxis : e.angleAxis], h = 0; 2 > h; h++)uI[u[h]] && (u[h] = dp(i, i.mapDimension(a[h]), u[h])); e.coord = u } } return e } function lp(t, e, i, n) { var r = {}; return null != t.valueIndex || null != t.valueDim ? (r.valueDataDim = null != t.valueIndex ? e.getDimension(t.valueIndex) : t.valueDim, r.valueAxis = i.getAxis(up(n, r.valueDataDim)), r.baseAxis = i.getOtherAxis(r.valueAxis), r.baseDataDim = e.mapDimension(r.baseAxis.dim)) : (r.baseAxis = n.getBaseAxis(), r.valueAxis = i.getOtherAxis(r.baseAxis), r.baseDataDim = e.mapDimension(r.baseAxis.dim), r.valueDataDim = e.mapDimension(r.valueAxis.dim)), r } function up(t, e) { var i = t.getData(), n = i.dimensions; e = i.getDimension(e); for (var r = 0; r < n.length; r++) { var a = i.getDimensionInfo(n[r]); if (a.name === e) return a.coordDim } } function hp(t, e) { return t && t.containData && e.coord && !rp(e) ? t.containData(e.coord) : !0 } function cp(t, e, i, n) { return 2 > n ? t.coord && t.coord[n] : t.value } function dp(t, e, i) { if ("average" === i) { var n = 0, r = 0; return t.each(e, function (t) { isNaN(t) || (n += t, r++) }), n / r } return "median" === i ? t.getMedian(e) : t.getDataExtent(e, !0)["max" === i ? 1 : 0] } function fp(t, e, i) { var n = e.coordinateSystem; t.each(function (r) { var a, o = t.getItemModel(r), s = Ka(o.get("x"), i.getWidth()), l = Ka(o.get("y"), i.getHeight()); if (isNaN(s) || isNaN(l)) { if (e.getMarkerPosition) a = e.getMarkerPosition(t.getValues(t.dimensions, r)); else if (n) { var u = t.get(n.dimensions[0], r), h = t.get(n.dimensions[1], r); a = n.dataToPoint([u, h]) } } else a = [s, l]; isNaN(s) || (a[0] = s), isNaN(l) || (a[1] = l), t.setItemLayout(r, a) }) } function pp(t, e, i) { var n; n = t ? p(t && t.dimensions, function (t) { var i = e.getData().getDimensionInfo(e.getData().mapDimension(t)) || {}; return s({ name: t }, i) }) : [{ name: "value", type: "float" }]; var r = new Lb(n, i), a = p(i.get("data"), x(sp, e)); return t && (a = m(a, x(hp, t))), r.initData(a, null, t ? cp : function (t) { return t.value }), r } function gp(t) { return isNaN(+t.cpx1) || isNaN(+t.cpy1) } function mp(t) { return "_" + t + "Type" } function vp(t, e, i) { var n = e.getItemVisual(i, "color"), r = e.getItemVisual(i, t), a = e.getItemVisual(i, t + "Size"); if (r && "none" !== r) { _(a) || (a = [a, a]); var o = vh(r, -a[0] / 2, -a[1] / 2, a[0], a[1], n); return o.name = t, o } } function yp(t) { var e = new fI({ name: "line" }); return xp(e.shape, t), e } function xp(t, e) { var i = e[0], n = e[1], r = e[2]; t.x1 = i[0], t.y1 = i[1], t.x2 = n[0], t.y2 = n[1], t.percent = 1, r ? (t.cpx1 = r[0], t.cpy1 = r[1]) : (t.cpx1 = 0 / 0, t.cpy1 = 0 / 0) } function _p() { var t = this, e = t.childOfName("fromSymbol"), i = t.childOfName("toSymbol"), n = t.childOfName("label"); if (e || i || !n.ignore) { for (var r = 1, a = this.parent; a;)a.scale && (r /= a.scale[0]), a = a.parent; var o = t.childOfName("line"); if (this.__dirty || o.__dirty) { var s = o.shape.percent, l = o.pointAt(0), u = o.pointAt(s), h = Y([], u, l); if (te(h, h), e) { e.attr("position", l); var c = o.tangentAt(0); e.attr("rotation", Math.PI / 2 - Math.atan2(c[1], c[0])), e.attr("scale", [r * s, r * s]) } if (i) { i.attr("position", u); var c = o.tangentAt(1); i.attr("rotation", -Math.PI / 2 - Math.atan2(c[1], c[0])), i.attr("scale", [r * s, r * s]) } if (!n.ignore) { n.attr("position", u); var d, f, p, g = 5 * r; if ("end" === n.__position) d = [h[0] * g + u[0], h[1] * g + u[1]], f = h[0] > .8 ? "left" : h[0] < -.8 ? "right" : "center", p = h[1] > .8 ? "top" : h[1] < -.8 ? "bottom" : "middle"; else if ("middle" === n.__position) { var m = s / 2, c = o.tangentAt(m), v = [c[1], -c[0]], y = o.pointAt(m); v[1] > 0 && (v[0] = -v[0], v[1] = -v[1]), d = [y[0] + v[0] * g, y[1] + v[1] * g], f = "center", p = "bottom"; var x = -Math.atan2(c[1], c[0]); u[0] < l[0] && (x = Math.PI + x), n.attr("rotation", x) } else d = [-h[0] * g + l[0], -h[1] * g + l[1]], f = h[0] > .8 ? "right" : h[0] < -.8 ? "left" : "center", p = h[1] > .8 ? "bottom" : h[1] < -.8 ? "top" : "middle"; n.attr({ style: { textVerticalAlign: n.__verticalAlign || p, textAlign: n.__textAlign || f }, position: d, scale: [r, r] }) } } } } function bp(t, e, i) { $g.call(this), this._createLine(t, e, i) } function wp(t) { this._ctor = t || bp, this.group = new $g } function Sp(t, e, i, n) { var r = e.getItemLayout(i); if (Tp(r)) { var a = new t._ctor(e, i, n); e.setItemGraphicEl(i, a), t.group.add(a) } } function Mp(t, e, i, n, r, a) { var o = e.getItemGraphicEl(n); return Tp(i.getItemLayout(r)) ? (o ? o.updateData(i, r, a) : o = new t._ctor(i, r, a), i.setItemGraphicEl(r, o), void t.group.add(o)) : void t.group.remove(o) } function Ip(t) { var e = t.hostModel; return { lineStyle: e.getModel("lineStyle").getLineStyle(), hoverLineStyle: e.getModel("emphasis.lineStyle").getLineStyle(), labelModel: e.getModel("label"), hoverLabelModel: e.getModel("emphasis.label") } } function Dp(t) { return isNaN(t[0]) || isNaN(t[1]) } function Tp(t) { return !Dp(t[0]) && !Dp(t[1]) } function Ap(t) { return !isNaN(t) && !isFinite(t) } function Cp(t, e, i, n) { var r = 1 - t, a = n.dimensions[t]; return Ap(e[r]) && Ap(i[r]) && e[t] === i[t] && n.getAxis(a).containData(e[t]) } function kp(t, e) { if ("cartesian2d" === t.type) { var i = e[0].coord, n = e[1].coord; if (i && n && (Cp(1, i, n, t) || Cp(0, i, n, t))) return !0 } return hp(t, e[0]) && hp(t, e[1]) } function Pp(t, e, i, n, r) { var a, o = n.coordinateSystem, s = t.getItemModel(e), l = Ka(s.get("x"), r.getWidth()), u = Ka(s.get("y"), r.getHeight()); if (isNaN(l) || isNaN(u)) { if (n.getMarkerPosition) a = n.getMarkerPosition(t.getValues(t.dimensions, e)); else { var h = o.dimensions, c = t.get(h[0], e), d = t.get(h[1], e); a = o.dataToPoint([c, d]) } if ("cartesian2d" === o.type) { var f = o.getAxis("x"), p = o.getAxis("y"), h = o.dimensions; Ap(t.get(h[0], e)) ? a[0] = f.toGlobalCoord(f.getExtent()[i ? 0 : 1]) : Ap(t.get(h[1], e)) && (a[1] = p.toGlobalCoord(p.getExtent()[i ? 0 : 1])) } isNaN(l) || (a[0] = l), isNaN(u) || (a[1] = u) } else a = [l, u]; t.setItemLayout(e, a) } function Lp(t, e, i) { var n; n = t ? p(t && t.dimensions, function (t) { var i = e.getData().getDimensionInfo(e.getData().mapDimension(t)) || {}; return s({ name: t }, i) }) : [{ name: "value", type: "float" }]; var r = new Lb(n, i), a = new Lb(n, i), o = new Lb([], i), l = p(i.get("data"), x(vI, e, t, i)); t && (l = m(l, x(kp, t))); var u = t ? cp : function (t) { return t.value }; return r.initData(p(l, function (t) { return t[0] }), null, u), a.initData(p(l, function (t) { return t[1] }), null, u), o.initData(p(l, function (t) { return t[2] })), o.hasItemOption = !0, { from: r, to: a, line: o } } function Op(t) { return !isNaN(t) && !isFinite(t) } function zp(t, e, i) { var n = 1 - t; return Op(e[n]) && Op(i[n]) } function Ep(t, e) { var i = e.coord[0], n = e.coord[1]; return "cartesian2d" === t.type && i && n && (zp(1, i, n, t) || zp(0, i, n, t)) ? !0 : hp(t, { coord: i, x: e.x0, y: e.y0 }) || hp(t, { coord: n, x: e.x1, y: e.y1 }) } function Bp(t, e, i, n, r) { var a, o = n.coordinateSystem, s = t.getItemModel(e), l = Ka(s.get(i[0]), r.getWidth()), u = Ka(s.get(i[1]), r.getHeight()); if (isNaN(l) || isNaN(u)) { if (n.getMarkerPosition) a = n.getMarkerPosition(t.getValues(i, e)); else { var h = t.get(i[0], e), c = t.get(i[1], e), d = [h, c]; o.clampData && o.clampData(d, d), a = o.dataToPoint(d, !0) } if ("cartesian2d" === o.type) { var f = o.getAxis("x"), p = o.getAxis("y"), h = t.get(i[0], e), c = t.get(i[1], e); Op(h) ? a[0] = f.toGlobalCoord(f.getExtent()["x0" === i[0] ? 0 : 1]) : Op(c) && (a[1] = p.toGlobalCoord(p.getExtent()["y0" === i[1] ? 0 : 1])) } isNaN(l) || (a[0] = l), isNaN(u) || (a[1] = u) } else a = [l, u]; return a } function Rp(t, e, i) { var n, r, a = ["x0", "y0", "x1", "y1"]; t ? (n = p(t && t.dimensions, function (t) { var i = e.getData(), n = i.getDimensionInfo(i.mapDimension(t)) || {}; return s({ name: t }, n) }), r = new Lb(p(a, function (t, e) { return { name: t, type: n[e % 2].type } }), i)) : (n = [{ name: "value", type: "float" }], r = new Lb(n, i)); var o = p(i.get("data"), x(yI, e, t, i)); t && (o = m(o, x(Ep, t))); var l = t ? function (t, e, i, n) { return t.coord[Math.floor(n / 2)][n % 2] } : function (t) { return t.value }; return r.initData(o, null, l), r.hasItemOption = !0, r } var Np = 2311, Fp = function () { return Np++ }, Vp = {}; Vp = "object" == typeof wx && "function" == typeof wx.getSystemInfoSync ? { browser: {}, os: {}, node: !1, wxa: !0, canvasSupported: !0, svgSupported: !1, touchEventsSupported: !0, domSupported: !1 } : "undefined" == typeof document && "undefined" != typeof self ? { browser: {}, os: {}, node: !1, worker: !0, canvasSupported: !0, domSupported: !1 } : "undefined" == typeof navigator ? { browser: {}, os: {}, node: !0, worker: !1, canvasSupported: !0, svgSupported: !0, domSupported: !1 } : e(navigator.userAgent); var Gp = Vp, Hp = { "[object Function]": 1, "[object RegExp]": 1, "[object Date]": 1, "[object Error]": 1, "[object CanvasGradient]": 1, "[object CanvasPattern]": 1, "[object Image]": 1, "[object Canvas]": 1 }, Wp = { "[object Int8Array]": 1, "[object Uint8Array]": 1, "[object Uint8ClampedArray]": 1, "[object Int16Array]": 1, "[object Uint16Array]": 1, "[object Int32Array]": 1, "[object Uint32Array]": 1, "[object Float32Array]": 1, "[object Float64Array]": 1 }, Xp = Object.prototype.toString, Up = Array.prototype, jp = Up.forEach, Yp = Up.filter, qp = Up.slice, Zp = Up.map, Kp = Up.reduce, $p = {}, Qp = function () { return $p.createCanvas() }; $p.createCanvas = function () { return document.createElement("canvas") }; var Jp, tg = "__ec_primitive__"; R.prototype = { constructor: R, get: function (t) { return this.data.hasOwnProperty(t) ? this.data[t] : null }, set: function (t, e) { return this.data[t] = e }, each: function (t, e) { void 0 !== e && (t = y(t, e)); for (var i in this.data) this.data.hasOwnProperty(i) && t(this.data[i], i) }, removeKey: function (t) { delete this.data[t] } }; var eg = (Object.freeze || Object)({ $override: i, clone: n, merge: r, mergeAll: a, extend: o, defaults: s, createCanvas: Qp, getContext: l, indexOf: u, inherits: h, mixin: c, isArrayLike: d, each: f, map: p, reduce: g, filter: m, find: v, bind: y, curry: x, isArray: _, isFunction: b, isString: w, isObject: S, isBuiltInObject: M, isTypedArray: I, isDom: D, eqNaN: T, retrieve: A, retrieve2: C, retrieve3: k, slice: P, normalizeCssArray: L, assert: O, trim: z, setAsPrimitive: E, isPrimitive: B, createHashMap: N, concatArray: F, noop: V }), ig = "undefined" == typeof Float32Array ? Array : Float32Array, ng = q, rg = Z, ag = ee, og = ie, sg = (Object.freeze || Object)({ create: G, copy: H, clone: W, set: X, add: U, scaleAndAdd: j, sub: Y, len: q, length: ng, lenSquare: Z, lengthSquare: rg, mul: K, div: $, dot: Q, scale: J, normalize: te, distance: ee, dist: ag, distanceSquare: ie, distSquare: og, negate: ne, lerp: re, applyTransform: ae, min: oe, max: se }); le.prototype = {
    constructor: le, _dragStart: function (t) {
      var e = t.target; e && e.draggable && (this._draggingTarget = e, e.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this.dispatchToElement(ue(e, t), "dragstart", t.event))
    }, _drag: function (t) { var e = this._draggingTarget; if (e) { var i = t.offsetX, n = t.offsetY, r = i - this._x, a = n - this._y; this._x = i, this._y = n, e.drift(r, a, t), this.dispatchToElement(ue(e, t), "drag", t.event); var o = this.findHover(i, n, e).target, s = this._dropTarget; this._dropTarget = o, e !== o && (s && o !== s && this.dispatchToElement(ue(s, t), "dragleave", t.event), o && o !== s && this.dispatchToElement(ue(o, t), "dragenter", t.event)) } }, _dragEnd: function (t) { var e = this._draggingTarget; e && (e.dragging = !1), this.dispatchToElement(ue(e, t), "dragend", t.event), this._dropTarget && this.dispatchToElement(ue(this._dropTarget, t), "drop", t.event), this._draggingTarget = null, this._dropTarget = null }
  }; var lg = Array.prototype.slice, ug = function (t) { this._$handlers = {}, this._$eventProcessor = t }; ug.prototype = { constructor: ug, one: function (t, e, i, n) { return ce(this, t, e, i, n, !0) }, on: function (t, e, i, n) { return ce(this, t, e, i, n, !1) }, isSilent: function (t) { var e = this._$handlers; return !e[t] || !e[t].length }, off: function (t, e) { var i = this._$handlers; if (!t) return this._$handlers = {}, this; if (e) { if (i[t]) { for (var n = [], r = 0, a = i[t].length; a > r; r++)i[t][r].h !== e && n.push(i[t][r]); i[t] = n } i[t] && 0 === i[t].length && delete i[t] } else delete i[t]; return this }, trigger: function (t) { var e = this._$handlers[t], i = this._$eventProcessor; if (e) { var n = arguments, r = n.length; r > 3 && (n = lg.call(n, 1)); for (var a = e.length, o = 0; a > o;) { var s = e[o]; if (i && i.filter && null != s.query && !i.filter(t, s.query)) o++; else { switch (r) { case 1: s.h.call(s.ctx); break; case 2: s.h.call(s.ctx, n[1]); break; case 3: s.h.call(s.ctx, n[1], n[2]); break; default: s.h.apply(s.ctx, n) }s.one ? (e.splice(o, 1), a--) : o++ } } } return i && i.afterTrigger && i.afterTrigger(t), this }, triggerWithContext: function (t) { var e = this._$handlers[t], i = this._$eventProcessor; if (e) { var n = arguments, r = n.length; r > 4 && (n = lg.call(n, 1, n.length - 1)); for (var a = n[n.length - 1], o = e.length, s = 0; o > s;) { var l = e[s]; if (i && i.filter && null != l.query && !i.filter(t, l.query)) s++; else { switch (r) { case 1: l.h.call(a); break; case 2: l.h.call(a, n[1]); break; case 3: l.h.call(a, n[1], n[2]); break; default: l.h.apply(a, n) }l.one ? (e.splice(s, 1), o--) : s++ } } } return i && i.afterTrigger && i.afterTrigger(t), this } }; var hg = "undefined" != typeof window && !!window.addEventListener, cg = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, dg = hg ? function (t) { t.preventDefault(), t.stopPropagation(), t.cancelBubble = !0 } : function (t) { t.returnValue = !1, t.cancelBubble = !0 }, fg = function () { this._track = [] }; fg.prototype = { constructor: fg, recognize: function (t, e, i) { return this._doTrack(t, e, i), this._recognize(t) }, clear: function () { return this._track.length = 0, this }, _doTrack: function (t, e, i) { var n = t.touches; if (n) { for (var r = { points: [], touches: [], target: e, event: t }, a = 0, o = n.length; o > a; a++) { var s = n[a], l = fe(i, s, {}); r.points.push([l.zrX, l.zrY]), r.touches.push(s) } this._track.push(r) } }, _recognize: function (t) { for (var e in pg) if (pg.hasOwnProperty(e)) { var i = pg[e](this._track, t); if (i) return i } } }; var pg = { pinch: function (t, e) { var i = t.length; if (i) { var n = (t[i - 1] || {}).points, r = (t[i - 2] || {}).points || n; if (r && r.length > 1 && n && n.length > 1) { var a = ye(n) / ye(r); !isFinite(a) && (a = 1), e.pinchScale = a; var o = xe(n); return e.pinchX = o[0], e.pinchY = o[1], { type: "pinch", target: t[0].target, event: e } } } } }, gg = "silent"; we.prototype.dispose = function () { }; var mg = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"], vg = function (t, e, i, n) { ug.call(this), this.storage = t, this.painter = e, this.painterRoot = n, i = i || new we, this.proxy = null, this._hovered = {}, this._lastTouchMoment, this._lastX, this._lastY, this._gestureMgr, le.call(this), this.setHandlerProxy(i) }; vg.prototype = { constructor: vg, setHandlerProxy: function (t) { this.proxy && this.proxy.dispose(), t && (f(mg, function (e) { t.on && t.on(e, this[e], this) }, this), t.handler = this), this.proxy = t }, mousemove: function (t) { var e = t.zrX, i = t.zrY, n = this._hovered, r = n.target; r && !r.__zr && (n = this.findHover(n.x, n.y), r = n.target); var a = this._hovered = this.findHover(e, i), o = a.target, s = this.proxy; s.setCursor && s.setCursor(o ? o.cursor : "default"), r && o !== r && this.dispatchToElement(n, "mouseout", t), this.dispatchToElement(a, "mousemove", t), o && o !== r && this.dispatchToElement(a, "mouseover", t) }, mouseout: function (t) { this.dispatchToElement(this._hovered, "mouseout", t); var e, i = t.toElement || t.relatedTarget; do i = i && i.parentNode; while (i && 9 !== i.nodeType && !(e = i === this.painterRoot)); !e && this.trigger("globalout", { event: t }) }, resize: function () { this._hovered = {} }, dispatch: function (t, e) { var i = this[t]; i && i.call(this, e) }, dispose: function () { this.proxy.dispose(), this.storage = this.proxy = this.painter = null }, setCursorStyle: function (t) { var e = this.proxy; e.setCursor && e.setCursor(t) }, dispatchToElement: function (t, e, i) { t = t || {}; var n = t.target; if (!n || !n.silent) { for (var r = "on" + e, a = _e(e, t, i); n && (n[r] && (a.cancelBubble = n[r].call(n, a)), n.trigger(e, a), n = n.parent, !a.cancelBubble);); a.cancelBubble || (this.trigger(e, a), this.painter && this.painter.eachOtherLayer(function (t) { "function" == typeof t[r] && t[r].call(t, a), t.trigger && t.trigger(e, a) })) } }, findHover: function (t, e, i) { for (var n = this.storage.getDisplayList(), r = { x: t, y: e }, a = n.length - 1; a >= 0; a--) { var o; if (n[a] !== i && !n[a].ignore && (o = Se(n[a], t, e)) && (!r.topTarget && (r.topTarget = n[a]), o !== gg)) { r.target = n[a]; break } } return r }, processGesture: function (t, e) { this._gestureMgr || (this._gestureMgr = new fg); var i = this._gestureMgr; "start" === e && i.clear(); var n = i.recognize(t, this.findHover(t.zrX, t.zrY, null).target, this.proxy.dom); if ("end" === e && i.clear(), n) { var r = n.type; t.gestureEvent = r, this.dispatchToElement({ target: n.target }, r, n.event) } } }, f(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function (t) { vg.prototype[t] = function (e) { var i = this.findHover(e.zrX, e.zrY), n = i.target; if ("mousedown" === t) this._downEl = n, this._downPoint = [e.zrX, e.zrY], this._upEl = n; else if ("mouseup" === t) this._upEl = n; else if ("click" === t) { if (this._downEl !== this._upEl || !this._downPoint || ag(this._downPoint, [e.zrX, e.zrY]) > 4) return; this._downPoint = null } this.dispatchToElement(i, t, e) } }), c(vg, ug), c(vg, le); var yg = "undefined" == typeof Float32Array ? Array : Float32Array, xg = (Object.freeze || Object)({ create: Me, identity: Ie, copy: De, mul: Te, translate: Ae, rotate: Ce, scale: ke, invert: Pe, clone: Le }), _g = Ie, bg = 5e-5, wg = function (t) { t = t || {}, t.position || (this.position = [0, 0]), null == t.rotation && (this.rotation = 0), t.scale || (this.scale = [1, 1]), this.origin = this.origin || null }, Sg = wg.prototype; Sg.transform = null, Sg.needLocalTransform = function () { return Oe(this.rotation) || Oe(this.position[0]) || Oe(this.position[1]) || Oe(this.scale[0] - 1) || Oe(this.scale[1] - 1) }; var Mg = []; Sg.updateTransform = function () { var t = this.parent, e = t && t.transform, i = this.needLocalTransform(), n = this.transform; if (!i && !e) return void (n && _g(n)); n = n || Me(), i ? this.getLocalTransform(n) : _g(n), e && (i ? Te(n, t.transform, n) : De(n, t.transform)), this.transform = n; var r = this.globalScaleRatio; if (null != r && 1 !== r) { this.getGlobalScale(Mg); var a = Mg[0] < 0 ? -1 : 1, o = Mg[1] < 0 ? -1 : 1, s = ((Mg[0] - a) * r + a) / Mg[0] || 0, l = ((Mg[1] - o) * r + o) / Mg[1] || 0; n[0] *= s, n[1] *= s, n[2] *= l, n[3] *= l } this.invTransform = this.invTransform || Me(), Pe(this.invTransform, n) }, Sg.getLocalTransform = function (t) { return wg.getLocalTransform(this, t) }, Sg.setTransform = function (t) { var e = this.transform, i = t.dpr || 1; e ? t.setTransform(i * e[0], i * e[1], i * e[2], i * e[3], i * e[4], i * e[5]) : t.setTransform(i, 0, 0, i, 0, 0) }, Sg.restoreTransform = function (t) { var e = t.dpr || 1; t.setTransform(e, 0, 0, e, 0, 0) }; var Ig = [], Dg = Me(); Sg.setLocalTransform = function (t) { if (t) { var e = t[0] * t[0] + t[1] * t[1], i = t[2] * t[2] + t[3] * t[3], n = this.position, r = this.scale; Oe(e - 1) && (e = Math.sqrt(e)), Oe(i - 1) && (i = Math.sqrt(i)), t[0] < 0 && (e = -e), t[3] < 0 && (i = -i), n[0] = t[4], n[1] = t[5], r[0] = e, r[1] = i, this.rotation = Math.atan2(-t[1] / i, t[0] / e) } }, Sg.decomposeTransform = function () { if (this.transform) { var t = this.parent, e = this.transform; t && t.transform && (Te(Ig, t.invTransform, e), e = Ig); var i = this.origin; i && (i[0] || i[1]) && (Dg[4] = i[0], Dg[5] = i[1], Te(Ig, e, Dg), Ig[4] -= i[0], Ig[5] -= i[1], e = Ig), this.setLocalTransform(e) } }, Sg.getGlobalScale = function (t) { var e = this.transform; return t = t || [], e ? (t[0] = Math.sqrt(e[0] * e[0] + e[1] * e[1]), t[1] = Math.sqrt(e[2] * e[2] + e[3] * e[3]), e[0] < 0 && (t[0] = -t[0]), e[3] < 0 && (t[1] = -t[1]), t) : (t[0] = 1, t[1] = 1, t) }, Sg.transformCoordToLocal = function (t, e) { var i = [t, e], n = this.invTransform; return n && ae(i, i, n), i }, Sg.transformCoordToGlobal = function (t, e) { var i = [t, e], n = this.transform; return n && ae(i, i, n), i }, wg.getLocalTransform = function (t, e) { e = e || [], _g(e); var i = t.origin, n = t.scale || [1, 1], r = t.rotation || 0, a = t.position || [0, 0]; return i && (e[4] -= i[0], e[5] -= i[1]), ke(e, e, n), r && Ce(e, e, r), i && (e[4] += i[0], e[5] += i[1]), e[4] += a[0], e[5] += a[1], e }; var Tg = { linear: function (t) { return t }, quadraticIn: function (t) { return t * t }, quadraticOut: function (t) { return t * (2 - t) }, quadraticInOut: function (t) { return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1) }, cubicIn: function (t) { return t * t * t }, cubicOut: function (t) { return --t * t * t + 1 }, cubicInOut: function (t) { return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2) }, quarticIn: function (t) { return t * t * t * t }, quarticOut: function (t) { return 1 - --t * t * t * t }, quarticInOut: function (t) { return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2) }, quinticIn: function (t) { return t * t * t * t * t }, quinticOut: function (t) { return --t * t * t * t * t + 1 }, quinticInOut: function (t) { return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2) }, sinusoidalIn: function (t) { return 1 - Math.cos(t * Math.PI / 2) }, sinusoidalOut: function (t) { return Math.sin(t * Math.PI / 2) }, sinusoidalInOut: function (t) { return .5 * (1 - Math.cos(Math.PI * t)) }, exponentialIn: function (t) { return 0 === t ? 0 : Math.pow(1024, t - 1) }, exponentialOut: function (t) { return 1 === t ? 1 : 1 - Math.pow(2, -10 * t) }, exponentialInOut: function (t) { return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (-Math.pow(2, -10 * (t - 1)) + 2) }, circularIn: function (t) { return 1 - Math.sqrt(1 - t * t) }, circularOut: function (t) { return Math.sqrt(1 - --t * t) }, circularInOut: function (t) { return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1) }, elasticIn: function (t) { var e, i = .1, n = .4; return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), -(i * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n))) }, elasticOut: function (t) { var e, i = .1, n = .4; return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin(2 * (t - e) * Math.PI / n) + 1) }, elasticInOut: function (t) { var e, i = .1, n = .4; return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? -.5 * i * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n) : i * Math.pow(2, -10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n) * .5 + 1) }, backIn: function (t) { var e = 1.70158; return t * t * ((e + 1) * t - e) }, backOut: function (t) { var e = 1.70158; return --t * t * ((e + 1) * t + e) + 1 }, backInOut: function (t) { var e = 2.5949095; return (t *= 2) < 1 ? .5 * t * t * ((e + 1) * t - e) : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2) }, bounceIn: function (t) { return 1 - Tg.bounceOut(1 - t) }, bounceOut: function (t) { return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375 }, bounceInOut: function (t) { return .5 > t ? .5 * Tg.bounceIn(2 * t) : .5 * Tg.bounceOut(2 * t - 1) + .5 } }; ze.prototype = { constructor: ze, step: function (t, e) { if (this._initialized || (this._startTime = t + this._delay, this._initialized = !0), this._paused) return void (this._pausedTime += e); var i = (t - this._startTime - this._pausedTime) / this._life; if (!(0 > i)) { i = Math.min(i, 1); var n = this.easing, r = "string" == typeof n ? Tg[n] : n, a = "function" == typeof r ? r(i) : i; return this.fire("frame", a), 1 === i ? this.loop ? (this.restart(t), "restart") : (this._needsRemove = !0, "destroy") : null } }, restart: function (t) { var e = (t - this._startTime - this._pausedTime) % this._life; this._startTime = t - e + this.gap, this._pausedTime = 0, this._needsRemove = !1 }, fire: function (t, e) { t = "on" + t, this[t] && this[t](this._target, e) }, pause: function () { this._paused = !0 }, resume: function () { this._paused = !1 } }; var Ag = function () { this.head = null, this.tail = null, this._len = 0 }, Cg = Ag.prototype; Cg.insert = function (t) { var e = new kg(t); return this.insertEntry(e), e }, Cg.insertEntry = function (t) { this.head ? (this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++ }, Cg.remove = function (t) { var e = t.prev, i = t.next; e ? e.next = i : this.head = i, i ? i.prev = e : this.tail = e, t.next = t.prev = null, this._len-- }, Cg.len = function () { return this._len }, Cg.clear = function () { this.head = this.tail = null, this._len = 0 }; var kg = function (t) { this.value = t, this.next, this.prev }, Pg = function (t) { this._list = new Ag, this._map = {}, this._maxSize = t || 10, this._lastRemovedEntry = null }, Lg = Pg.prototype; Lg.put = function (t, e) { var i = this._list, n = this._map, r = null; if (null == n[t]) { var a = i.len(), o = this._lastRemovedEntry; if (a >= this._maxSize && a > 0) { var s = i.head; i.remove(s), delete n[s.key], r = s.value, this._lastRemovedEntry = s } o ? o.value = e : o = new kg(e), o.key = t, i.insertEntry(o), n[t] = o } return r }, Lg.get = function (t) { var e = this._map[t], i = this._list; return null != e ? (e !== i.tail && (i.remove(e), i.insertEntry(e)), e.value) : void 0 }, Lg.clear = function () { this._list.clear(), this._map = {} }; var Og = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] }, zg = new Pg(20), Eg = null, Bg = Ke, Rg = $e, Ng = (Object.freeze || Object)({ parse: Ue, lift: qe, toHex: Ze, fastLerp: Ke, fastMapToColor: Bg, lerp: $e, mapToColor: Rg, modifyHSL: Qe, modifyAlpha: Je, stringify: ti }), Fg = Array.prototype.slice, Vg = function (t, e, i, n) { this._tracks = {}, this._target = t, this._loop = e || !1, this._getter = i || ei, this._setter = n || ii, this._clipCount = 0, this._delay = 0, this._doneList = [], this._onframeList = [], this._clipList = [] }; Vg.prototype = { when: function (t, e) { var i = this._tracks; for (var n in e) if (e.hasOwnProperty(n)) { if (!i[n]) { i[n] = []; var r = this._getter(this._target, n); if (null == r) continue; 0 !== t && i[n].push({ time: 0, value: hi(r) }) } i[n].push({ time: t, value: e[n] }) } return this }, during: function (t) { return this._onframeList.push(t), this }, pause: function () { for (var t = 0; t < this._clipList.length; t++)this._clipList[t].pause(); this._paused = !0 }, resume: function () { for (var t = 0; t < this._clipList.length; t++)this._clipList[t].resume(); this._paused = !1 }, isPaused: function () { return !!this._paused }, _doneCallback: function () { this._tracks = {}, this._clipList.length = 0; for (var t = this._doneList, e = t.length, i = 0; e > i; i++)t[i].call(this) }, start: function (t, e) { var i, n = this, r = 0, a = function () { r-- , r || n._doneCallback() }; for (var o in this._tracks) if (this._tracks.hasOwnProperty(o)) { var s = fi(this, t, a, this._tracks[o], o, e); s && (this._clipList.push(s), r++ , this.animation && this.animation.addClip(s), i = s) } if (i) { var l = i.onframe; i.onframe = function (t, e) { l(t, e); for (var i = 0; i < n._onframeList.length; i++)n._onframeList[i](t, e) } } return r || this._doneCallback(), this }, stop: function (t) { for (var e = this._clipList, i = this.animation, n = 0; n < e.length; n++) { var r = e[n]; t && r.onframe(this._target, 1), i && i.removeClip(r) } e.length = 0 }, delay: function (t) { return this._delay = t, this }, done: function (t) { return t && this._doneList.push(t), this }, getClips: function () { return this._clipList } }; var Gg = 1; "undefined" != typeof window && (Gg = Math.max(window.devicePixelRatio || 1, 1)); var Hg = 0, Wg = Gg, Xg = function () { }; 1 === Hg ? Xg = function () { for (var t in arguments) throw new Error(arguments[t]) } : Hg > 1 && (Xg = function () { for (var t in arguments) console.log(arguments[t]) }); var Ug = Xg, jg = function () { this.animators = [] }; jg.prototype = { constructor: jg, animate: function (t, e) { var i, n = !1, r = this, a = this.__zr; if (t) { var o = t.split("."), s = r; n = "shape" === o[0]; for (var l = 0, h = o.length; h > l; l++)s && (s = s[o[l]]); s && (i = s) } else i = r; if (!i) return void Ug('Property "' + t + '" is not existed in element ' + r.id); var c = r.animators, d = new Vg(i, e); return d.during(function () { r.dirty(n) }).done(function () { c.splice(u(c, d), 1) }), c.push(d), a && a.animation.addAnimator(d), d }, stopAnimation: function (t) { for (var e = this.animators, i = e.length, n = 0; i > n; n++)e[n].stop(t); return e.length = 0, this }, animateTo: function (t, e, i, n, r, a) { pi(this, t, e, i, n, r, a) }, animateFrom: function (t, e, i, n, r, a) { pi(this, t, e, i, n, r, a, !0) } }; var Yg = function (t) { wg.call(this, t), ug.call(this, t), jg.call(this, t), this.id = t.id || Fp() }; Yg.prototype = { type: "element", name: "", __zr: null, ignore: !1, clipPath: null, isGroup: !1, drift: function (t, e) { switch (this.draggable) { case "horizontal": e = 0; break; case "vertical": t = 0 }var i = this.transform; i || (i = this.transform = [1, 0, 0, 1, 0, 0]), i[4] += t, i[5] += e, this.decomposeTransform(), this.dirty(!1) }, beforeUpdate: function () { }, afterUpdate: function () { }, update: function () { this.updateTransform() }, traverse: function () { }, attrKV: function (t, e) { if ("position" === t || "scale" === t || "origin" === t) { if (e) { var i = this[t]; i || (i = this[t] = []), i[0] = e[0], i[1] = e[1] } } else this[t] = e }, hide: function () { this.ignore = !0, this.__zr && this.__zr.refresh() }, show: function () { this.ignore = !1, this.__zr && this.__zr.refresh() }, attr: function (t, e) { if ("string" == typeof t) this.attrKV(t, e); else if (S(t)) for (var i in t) t.hasOwnProperty(i) && this.attrKV(i, t[i]); return this.dirty(!1), this }, setClipPath: function (t) { var e = this.__zr; e && t.addSelfToZr(e), this.clipPath && this.clipPath !== t && this.removeClipPath(), this.clipPath = t, t.__zr = e, t.__clipTarget = this, this.dirty(!1) }, removeClipPath: function () { var t = this.clipPath; t && (t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__clipTarget = null, this.clipPath = null, this.dirty(!1)) }, addSelfToZr: function (t) { this.__zr = t; var e = this.animators; if (e) for (var i = 0; i < e.length; i++)t.animation.addAnimator(e[i]); this.clipPath && this.clipPath.addSelfToZr(t) }, removeSelfFromZr: function (t) { this.__zr = null; var e = this.animators; if (e) for (var i = 0; i < e.length; i++)t.animation.removeAnimator(e[i]); this.clipPath && this.clipPath.removeSelfFromZr(t) } }, c(Yg, jg), c(Yg, wg), c(Yg, ug); var qg = ae, Zg = Math.min, Kg = Math.max; vi.prototype = { constructor: vi, union: function (t) { var e = Zg(t.x, this.x), i = Zg(t.y, this.y); this.width = Kg(t.x + t.width, this.x + this.width) - e, this.height = Kg(t.y + t.height, this.y + this.height) - i, this.x = e, this.y = i }, applyTransform: function () { var t = [], e = [], i = [], n = []; return function (r) { if (r) { t[0] = i[0] = this.x, t[1] = n[1] = this.y, e[0] = n[0] = this.x + this.width, e[1] = i[1] = this.y + this.height, qg(t, t, r), qg(e, e, r), qg(i, i, r), qg(n, n, r), this.x = Zg(t[0], e[0], i[0], n[0]), this.y = Zg(t[1], e[1], i[1], n[1]); var a = Kg(t[0], e[0], i[0], n[0]), o = Kg(t[1], e[1], i[1], n[1]); this.width = a - this.x, this.height = o - this.y } } }(), calculateTransform: function (t) { var e = this, i = t.width / e.width, n = t.height / e.height, r = Me(); return Ae(r, r, [-e.x, -e.y]), ke(r, r, [i, n]), Ae(r, r, [t.x, t.y]), r }, intersect: function (t) { if (!t) return !1; t instanceof vi || (t = vi.create(t)); var e = this, i = e.x, n = e.x + e.width, r = e.y, a = e.y + e.height, o = t.x, s = t.x + t.width, l = t.y, u = t.y + t.height; return !(o > n || i > s || l > a || r > u) }, contain: function (t, e) { var i = this; return t >= i.x && t <= i.x + i.width && e >= i.y && e <= i.y + i.height }, clone: function () { return new vi(this.x, this.y, this.width, this.height) }, copy: function (t) { this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height }, plain: function () { return { x: this.x, y: this.y, width: this.width, height: this.height } } }, vi.create = function (t) { return new vi(t.x, t.y, t.width, t.height) }; var $g = function (t) { t = t || {}, Yg.call(this, t); for (var e in t) t.hasOwnProperty(e) && (this[e] = t[e]); this._children = [], this.__storage = null, this.__dirty = !0 }; $g.prototype = { constructor: $g, isGroup: !0, type: "group", silent: !1, children: function () { return this._children.slice() }, childAt: function (t) { return this._children[t] }, childOfName: function (t) { for (var e = this._children, i = 0; i < e.length; i++)if (e[i].name === t) return e[i] }, childCount: function () { return this._children.length }, add: function (t) { return t && t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), this }, addBefore: function (t, e) { if (t && t !== this && t.parent !== this && e && e.parent === this) { var i = this._children, n = i.indexOf(e); n >= 0 && (i.splice(n, 0, t), this._doAdd(t)) } return this }, _doAdd: function (t) { t.parent && t.parent.remove(t), t.parent = this; var e = this.__storage, i = this.__zr; e && e !== t.__storage && (e.addToStorage(t), t instanceof $g && t.addChildrenToStorage(e)), i && i.refresh() }, remove: function (t) { var e = this.__zr, i = this.__storage, n = this._children, r = u(n, t); return 0 > r ? this : (n.splice(r, 1), t.parent = null, i && (i.delFromStorage(t), t instanceof $g && t.delChildrenFromStorage(i)), e && e.refresh(), this) }, removeAll: function () { var t, e, i = this._children, n = this.__storage; for (e = 0; e < i.length; e++)t = i[e], n && (n.delFromStorage(t), t instanceof $g && t.delChildrenFromStorage(n)), t.parent = null; return i.length = 0, this }, eachChild: function (t, e) { for (var i = this._children, n = 0; n < i.length; n++) { var r = i[n]; t.call(e, r, n) } return this }, traverse: function (t, e) { for (var i = 0; i < this._children.length; i++) { var n = this._children[i]; t.call(e, n), "group" === n.type && n.traverse(t, e) } return this }, addChildrenToStorage: function (t) { for (var e = 0; e < this._children.length; e++) { var i = this._children[e]; t.addToStorage(i), i instanceof $g && i.addChildrenToStorage(t) } }, delChildrenFromStorage: function (t) { for (var e = 0; e < this._children.length; e++) { var i = this._children[e]; t.delFromStorage(i), i instanceof $g && i.delChildrenFromStorage(t) } }, dirty: function () { return this.__dirty = !0, this.__zr && this.__zr.refresh(), this }, getBoundingRect: function (t) { for (var e = null, i = new vi(0, 0, 0, 0), n = t || this._children, r = [], a = 0; a < n.length; a++) { var o = n[a]; if (!o.ignore && !o.invisible) { var s = o.getBoundingRect(), l = o.getLocalTransform(r); l ? (i.copy(s), i.applyTransform(l), e = e || i.clone(), e.union(i)) : (e = e || s.clone(), e.union(s)) } } return e || i } }, h($g, Yg); var Qg = 32, Jg = 7, tm = function () { this._roots = [], this._displayList = [], this._displayListLen = 0 }; tm.prototype = { constructor: tm, traverse: function (t, e) { for (var i = 0; i < this._roots.length; i++)this._roots[i].traverse(t, e) }, getDisplayList: function (t, e) { return e = e || !1, t && this.updateDisplayList(e), this._displayList }, updateDisplayList: function (t) { this._displayListLen = 0; for (var e = this._roots, i = this._displayList, n = 0, r = e.length; r > n; n++)this._updateAndAddDisplayable(e[n], null, t); i.length = this._displayListLen, Gp.canvasSupported && Ii(i, Di) }, _updateAndAddDisplayable: function (t, e, i) { if (!t.ignore || i) { t.beforeUpdate(), t.__dirty && t.update(), t.afterUpdate(); var n = t.clipPath; if (n) { e = e ? e.slice() : []; for (var r = n, a = t; r;)r.parent = a, r.updateTransform(), e.push(r), a = r, r = r.clipPath } if (t.isGroup) { for (var o = t._children, s = 0; s < o.length; s++) { var l = o[s]; t.__dirty && (l.__dirty = !0), this._updateAndAddDisplayable(l, e, i) } t.__dirty = !1 } else t.__clipPaths = e, this._displayList[this._displayListLen++] = t } }, addRoot: function (t) { t.__storage !== this && (t instanceof $g && t.addChildrenToStorage(this), this.addToStorage(t), this._roots.push(t)) }, delRoot: function (t) { if (null == t) { for (var e = 0; e < this._roots.length; e++) { var i = this._roots[e]; i instanceof $g && i.delChildrenFromStorage(this) } return this._roots = [], this._displayList = [], void (this._displayListLen = 0) } if (t instanceof Array) for (var e = 0, n = t.length; n > e; e++)this.delRoot(t[e]); else { var r = u(this._roots, t); r >= 0 && (this.delFromStorage(t), this._roots.splice(r, 1), t instanceof $g && t.delChildrenFromStorage(this)) } }, addToStorage: function (t) { return t && (t.__storage = this, t.dirty(!1)), this }, delFromStorage: function (t) { return t && (t.__storage = null), this }, dispose: function () { this._renderList = this._roots = null }, displayableSortFunc: Di }; var em = { shadowBlur: 1, shadowOffsetX: 1, shadowOffsetY: 1, textShadowBlur: 1, textShadowOffsetX: 1, textShadowOffsetY: 1, textBoxShadowBlur: 1, textBoxShadowOffsetX: 1, textBoxShadowOffsetY: 1 }, im = function (t, e, i) { return em.hasOwnProperty(e) ? i *= t.dpr : i }, nm = { NONE: 0, STYLE_BIND: 1, PLAIN_TEXT: 2 }, rm = 9, am = [["shadowBlur", 0], ["shadowOffsetX", 0], ["shadowOffsetY", 0], ["shadowColor", "#000"], ["lineCap", "butt"], ["lineJoin", "miter"], ["miterLimit", 10]], om = function (t) { this.extendFrom(t, !1) }; om.prototype = { constructor: om, fill: "#000", stroke: null, opacity: 1, fillOpacity: null, strokeOpacity: null, lineDash: null, lineDashOffset: 0, shadowBlur: 0, shadowOffsetX: 0, shadowOffsetY: 0, lineWidth: 1, strokeNoScale: !1, text: null, font: null, textFont: null, fontStyle: null, fontWeight: null, fontSize: null, fontFamily: null, textTag: null, textFill: "#000", textStroke: null, textWidth: null, textHeight: null, textStrokeWidth: 0, textLineHeight: null, textPosition: "inside", textRect: null, textOffset: null, textAlign: null, textVerticalAlign: null, textDistance: 5, textShadowColor: "transparent", textShadowBlur: 0, textShadowOffsetX: 0, textShadowOffsetY: 0, textBoxShadowColor: "transparent", textBoxShadowBlur: 0, textBoxShadowOffsetX: 0, textBoxShadowOffsetY: 0, transformText: !1, textRotation: 0, textOrigin: null, textBackgroundColor: null, textBorderColor: null, textBorderWidth: 0, textBorderRadius: 0, textPadding: null, rich: null, truncate: null, blend: null, bind: function (t, e, i) { var n = this, r = i && i.style, a = !r || t.__attrCachedBy !== nm.STYLE_BIND; t.__attrCachedBy = nm.STYLE_BIND; for (var o = 0; o < am.length; o++) { var s = am[o], l = s[0]; (a || n[l] !== r[l]) && (t[l] = im(t, l, n[l] || s[1])) } if ((a || n.fill !== r.fill) && (t.fillStyle = n.fill), (a || n.stroke !== r.stroke) && (t.strokeStyle = n.stroke), (a || n.opacity !== r.opacity) && (t.globalAlpha = null == n.opacity ? 1 : n.opacity), (a || n.blend !== r.blend) && (t.globalCompositeOperation = n.blend || "source-over"), this.hasStroke()) { var u = n.lineWidth; t.lineWidth = u / (this.strokeNoScale && e && e.getLineScale ? e.getLineScale() : 1) } }, hasFill: function () { var t = this.fill; return null != t && "none" !== t }, hasStroke: function () { var t = this.stroke; return null != t && "none" !== t && this.lineWidth > 0 }, extendFrom: function (t, e) { if (t) for (var i in t) !t.hasOwnProperty(i) || e !== !0 && (e === !1 ? this.hasOwnProperty(i) : null == t[i]) || (this[i] = t[i]) }, set: function (t, e) { "string" == typeof t ? this[t] = e : this.extendFrom(t, !0) }, clone: function () { var t = new this.constructor; return t.extendFrom(this, !0), t }, getGradient: function (t, e, i) { for (var n = "radial" === e.type ? Ai : Ti, r = n(t, e, i), a = e.colorStops, o = 0; o < a.length; o++)r.addColorStop(a[o].offset, a[o].color); return r } }; for (var sm = om.prototype, lm = 0; lm < am.length; lm++) { var um = am[lm]; um[0] in sm || (sm[um[0]] = um[1]) } om.getGradient = sm.getGradient; var hm = function (t, e) { this.image = t, this.repeat = e, this.type = "pattern" }; hm.prototype.getCanvasPattern = function (t) { return t.createPattern(this.image, this.repeat || "repeat") }; var cm = function (t, e, i) { var n; i = i || Wg, "string" == typeof t ? n = ki(t, e, i) : S(t) && (n = t, t = n.id), this.id = t, this.dom = n; var r = n.style; r && (n.onselectstart = Ci, r["-webkit-user-select"] = "none", r["user-select"] = "none", r["-webkit-touch-callout"] = "none", r["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)", r.padding = 0, r.margin = 0, r["border-width"] = 0), this.domBack = null, this.ctxBack = null, this.painter = e, this.config = null, this.clearColor = 0, this.motionBlur = !1, this.lastFrameAlpha = .7, this.dpr = i }; cm.prototype = { constructor: cm, __dirty: !0, __used: !1, __drawIndex: 0, __startIndex: 0, __endIndex: 0, incremental: !1, getElementCount: function () { return this.__endIndex - this.__startIndex }, initContext: function () { this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr }, createBackBuffer: function () { var t = this.dpr; this.domBack = ki("back-" + this.id, this.painter, t), this.ctxBack = this.domBack.getContext("2d"), 1 !== t && this.ctxBack.scale(t, t) }, resize: function (t, e) { var i = this.dpr, n = this.dom, r = n.style, a = this.domBack; r && (r.width = t + "px", r.height = e + "px"), n.width = t * i, n.height = e * i, a && (a.width = t * i, a.height = e * i, 1 !== i && this.ctxBack.scale(i, i)) }, clear: function (t, e) { var i = this.dom, n = this.ctx, r = i.width, a = i.height, e = e || this.clearColor, o = this.motionBlur && !t, s = this.lastFrameAlpha, l = this.dpr; if (o && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(i, 0, 0, r / l, a / l)), n.clearRect(0, 0, r, a), e && "transparent" !== e) { var u; e.colorStops ? (u = e.__canvasGradient || om.getGradient(n, e, { x: 0, y: 0, width: r, height: a }), e.__canvasGradient = u) : e.image && (u = hm.prototype.getCanvasPattern.call(e, n)), n.save(), n.fillStyle = u || e, n.fillRect(0, 0, r, a), n.restore() } if (o) { var h = this.domBack; n.save(), n.globalAlpha = s, n.drawImage(h, 0, 0, r, a), n.restore() } } }; var dm = "undefined" != typeof window && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (t) { setTimeout(t, 16) }, fm = new Pg(50), pm = {}, gm = 0, mm = 5e3, vm = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g, ym = "12px sans-serif", xm = {}; xm.measureText = function (t, e) { var i = l(); return i.font = e || ym, i.measureText(t) }; var _m = ym, bm = { left: 1, right: 1, center: 1 }, wm = { top: 1, bottom: 1, middle: 1 }, Sm = [["textShadowBlur", "shadowBlur", 0], ["textShadowOffsetX", "shadowOffsetX", 0], ["textShadowOffsetY", "shadowOffsetY", 0], ["textShadowColor", "shadowColor", "transparent"]], Mm = new vi, Im = function () { }; Im.prototype = { constructor: Im, drawRectText: function (t, e) { var i = this.style; e = i.textRect || e, this.__dirty && Ji(i, !0); var n = i.text; if (null != n && (n += ""), vn(n, i)) { t.save(); var r = this.transform; i.transformText ? this.setTransform(t) : r && (Mm.copy(e), Mm.applyTransform(r), e = Mm), en(this, t, n, i, e, rm), t.restore() } } }, yn.prototype = {
    constructor: yn, type: "displayable", __dirty: !0, invisible: !1, z: 0, z2: 0, zlevel: 0, draggable: !1, dragging: !1, silent: !1, culling: !1, cursor: "pointer", rectHover: !1, progressive: !1, incremental: !1, globalScaleRatio: 1, beforeBrush: function () { }, afterBrush: function () { }, brush: function () { }, getBoundingRect: function () { }, contain: function (t, e) { return this.rectContain(t, e) }, traverse: function (t, e) { t.call(e, this) }, rectContain: function (t, e) { var i = this.transformCoordToLocal(t, e), n = this.getBoundingRect(); return n.contain(i[0], i[1]) }, dirty: function () {
    this.__dirty = this.__dirtyText = !0, this._rect = null, this.__zr && this.__zr.refresh()
    }, animateStyle: function (t) { return this.animate("style", t) }, attrKV: function (t, e) { "style" !== t ? Yg.prototype.attrKV.call(this, t, e) : this.style.set(e) }, setStyle: function (t, e) { return this.style.set(t, e), this.dirty(!1), this }, useStyle: function (t) { return this.style = new om(t, this), this.dirty(!1), this }
  }, h(yn, Yg), c(yn, Im), xn.prototype = { constructor: xn, type: "image", brush: function (t, e) { var i = this.style, n = i.image; i.bind(t, this, e); var r = this._image = Li(n, this._image, this, this.onload); if (r && zi(r)) { var a = i.x || 0, o = i.y || 0, s = i.width, l = i.height, u = r.width / r.height; if (null == s && null != l ? s = l * u : null == l && null != s ? l = s / u : null == s && null == l && (s = r.width, l = r.height), this.setTransform(t), i.sWidth && i.sHeight) { var h = i.sx || 0, c = i.sy || 0; t.drawImage(r, h, c, i.sWidth, i.sHeight, a, o, s, l) } else if (i.sx && i.sy) { var h = i.sx, c = i.sy, d = s - h, f = l - c; t.drawImage(r, h, c, d, f, a, o, s, l) } else t.drawImage(r, a, o, s, l); null != i.text && (this.restoreTransform(t), this.drawRectText(t, this.getBoundingRect())) } }, getBoundingRect: function () { var t = this.style; return this._rect || (this._rect = new vi(t.x || 0, t.y || 0, t.width || 0, t.height || 0)), this._rect } }, h(xn, yn); var Dm = 1e5, Tm = 314159, Am = .01, Cm = .001, km = new vi(0, 0, 0, 0), Pm = new vi(0, 0, 0, 0), Lm = function (t, e, i) { this.type = "canvas"; var n = !t.nodeName || "CANVAS" === t.nodeName.toUpperCase(); this._opts = i = o({}, i || {}), this.dpr = i.devicePixelRatio || Wg, this._singleCanvas = n, this.root = t; var r = t.style; r && (r["-webkit-tap-highlight-color"] = "transparent", r["-webkit-user-select"] = r["user-select"] = r["-webkit-touch-callout"] = "none", t.innerHTML = ""), this.storage = e; var a = this._zlevelList = [], s = this._layers = {}; if (this._layerConfig = {}, this._needsManuallyCompositing = !1, n) { var l = t.width, u = t.height; null != i.width && (l = i.width), null != i.height && (u = i.height), this.dpr = i.devicePixelRatio || 1, t.width = l * this.dpr, t.height = u * this.dpr, this._width = l, this._height = u; var h = new cm(t, this, this.dpr); h.__builtin__ = !0, h.initContext(), s[Tm] = h, h.zlevel = Tm, a.push(Tm), this._domRoot = t } else { this._width = this._getSize(0), this._height = this._getSize(1); var c = this._domRoot = In(this._width, this._height); t.appendChild(c) } this._hoverlayer = null, this._hoverElements = [] }; Lm.prototype = { constructor: Lm, getType: function () { return "canvas" }, isSingleCanvas: function () { return this._singleCanvas }, getViewportRoot: function () { return this._domRoot }, getViewportRootOffset: function () { var t = this.getViewportRoot(); return t ? { offsetLeft: t.offsetLeft || 0, offsetTop: t.offsetTop || 0 } : void 0 }, refresh: function (t) { var e = this.storage.getDisplayList(!0), i = this._zlevelList; this._redrawId = Math.random(), this._paintList(e, t, this._redrawId); for (var n = 0; n < i.length; n++) { var r = i[n], a = this._layers[r]; if (!a.__builtin__ && a.refresh) { var o = 0 === n ? this._backgroundColor : null; a.refresh(o) } } return this.refreshHover(), this }, addHover: function (t, e) { if (!t.__hoverMir) { var i = new t.constructor({ style: t.style, shape: t.shape, z: t.z, z2: t.z2, silent: t.silent }); return i.__from = t, t.__hoverMir = i, e && i.setStyle(e), this._hoverElements.push(i), i } }, removeHover: function (t) { var e = t.__hoverMir, i = this._hoverElements, n = u(i, e); n >= 0 && i.splice(n, 1), t.__hoverMir = null }, clearHover: function () { for (var t = this._hoverElements, e = 0; e < t.length; e++) { var i = t[e].__from; i && (i.__hoverMir = null) } t.length = 0 }, refreshHover: function () { var t = this._hoverElements, e = t.length, i = this._hoverlayer; if (i && i.clear(), e) { Ii(t, this.storage.displayableSortFunc), i || (i = this._hoverlayer = this.getLayer(Dm)); var n = {}; i.ctx.save(); for (var r = 0; e > r;) { var a = t[r], o = a.__from; o && o.__zr ? (r++ , o.invisible || (a.transform = o.transform, a.invTransform = o.invTransform, a.__clipPaths = o.__clipPaths, this._doPaintEl(a, i, !0, n))) : (t.splice(r, 1), o.__hoverMir = null, e--) } i.ctx.restore() } }, getHoverLayer: function () { return this.getLayer(Dm) }, _paintList: function (t, e, i) { if (this._redrawId === i) { e = e || !1, this._updateLayerStatus(t); var n = this._doPaintList(t, e); if (this._needsManuallyCompositing && this._compositeManually(), !n) { var r = this; dm(function () { r._paintList(t, e, i) }) } } }, _compositeManually: function () { var t = this.getLayer(Tm).ctx, e = this._domRoot.width, i = this._domRoot.height; t.clearRect(0, 0, e, i), this.eachBuiltinLayer(function (n) { n.virtual && t.drawImage(n.dom, 0, 0, e, i) }) }, _doPaintList: function (t, e) { for (var i = [], n = 0; n < this._zlevelList.length; n++) { var r = this._zlevelList[n], a = this._layers[r]; a.__builtin__ && a !== this._hoverlayer && (a.__dirty || e) && i.push(a) } for (var o = !0, s = 0; s < i.length; s++) { var a = i[s], l = a.ctx, u = {}; l.save(); var h = e ? a.__startIndex : a.__drawIndex, c = !e && a.incremental && Date.now, d = c && Date.now(), p = a.zlevel === this._zlevelList[0] ? this._backgroundColor : null; if (a.__startIndex === a.__endIndex) a.clear(!1, p); else if (h === a.__startIndex) { var g = t[h]; g.incremental && g.notClear && !e || a.clear(!1, p) } -1 === h && (console.error("For some unknown reason. drawIndex is -1"), h = a.__startIndex); for (var m = h; m < a.__endIndex; m++) { var v = t[m]; if (this._doPaintEl(v, a, e, u), v.__dirty = v.__dirtyText = !1, c) { var y = Date.now() - d; if (y > 15) break } } a.__drawIndex = m, a.__drawIndex < a.__endIndex && (o = !1), u.prevElClipPaths && l.restore(), l.restore() } return Gp.wxa && f(this._layers, function (t) { t && t.ctx && t.ctx.draw && t.ctx.draw() }), o }, _doPaintEl: function (t, e, i, n) { var r = e.ctx, a = t.transform; if (!(!e.__dirty && !i || t.invisible || 0 === t.style.opacity || a && !a[0] && !a[3] || t.culling && wn(t, this._width, this._height))) { var o = t.__clipPaths; (!n.prevElClipPaths || Sn(o, n.prevElClipPaths)) && (n.prevElClipPaths && (e.ctx.restore(), n.prevElClipPaths = null, n.prevEl = null), o && (r.save(), Mn(o, r), n.prevElClipPaths = o)), t.beforeBrush && t.beforeBrush(r), t.brush(r, n.prevEl || null), n.prevEl = t, t.afterBrush && t.afterBrush(r) } }, getLayer: function (t, e) { this._singleCanvas && !this._needsManuallyCompositing && (t = Tm); var i = this._layers[t]; return i || (i = new cm("zr_" + t, this, this.dpr), i.zlevel = t, i.__builtin__ = !0, this._layerConfig[t] && r(i, this._layerConfig[t], !0), e && (i.virtual = e), this.insertLayer(t, i), i.initContext()), i }, insertLayer: function (t, e) { var i = this._layers, n = this._zlevelList, r = n.length, a = null, o = -1, s = this._domRoot; if (i[t]) return void Ug("ZLevel " + t + " has been used already"); if (!bn(e)) return void Ug("Layer of zlevel " + t + " is not valid"); if (r > 0 && t > n[0]) { for (o = 0; r - 1 > o && !(n[o] < t && n[o + 1] > t); o++); a = i[n[o]] } if (n.splice(o + 1, 0, t), i[t] = e, !e.virtual) if (a) { var l = a.dom; l.nextSibling ? s.insertBefore(e.dom, l.nextSibling) : s.appendChild(e.dom) } else s.firstChild ? s.insertBefore(e.dom, s.firstChild) : s.appendChild(e.dom) }, eachLayer: function (t, e) { var i, n, r = this._zlevelList; for (n = 0; n < r.length; n++)i = r[n], t.call(e, this._layers[i], i) }, eachBuiltinLayer: function (t, e) { var i, n, r, a = this._zlevelList; for (r = 0; r < a.length; r++)n = a[r], i = this._layers[n], i.__builtin__ && t.call(e, i, n) }, eachOtherLayer: function (t, e) { var i, n, r, a = this._zlevelList; for (r = 0; r < a.length; r++)n = a[r], i = this._layers[n], i.__builtin__ || t.call(e, i, n) }, getLayers: function () { return this._layers }, _updateLayerStatus: function (t) { function e(t) { r && (r.__endIndex !== t && (r.__dirty = !0), r.__endIndex = t) } if (this.eachBuiltinLayer(function (t) { t.__dirty = t.__used = !1 }), this._singleCanvas) for (var i = 1; i < t.length; i++) { var n = t[i]; if (n.zlevel !== t[i - 1].zlevel || n.incremental) { this._needsManuallyCompositing = !0; break } } for (var r = null, a = 0, i = 0; i < t.length; i++) { var o, n = t[i], s = n.zlevel; n.incremental ? (o = this.getLayer(s + Cm, this._needsManuallyCompositing), o.incremental = !0, a = 1) : o = this.getLayer(s + (a > 0 ? Am : 0), this._needsManuallyCompositing), o.__builtin__ || Ug("ZLevel " + s + " has been used by unkown layer " + o.id), o !== r && (o.__used = !0, o.__startIndex !== i && (o.__dirty = !0), o.__startIndex = i, o.__drawIndex = o.incremental ? -1 : i, e(i), r = o), n.__dirty && (o.__dirty = !0, o.incremental && o.__drawIndex < 0 && (o.__drawIndex = i)) } e(i), this.eachBuiltinLayer(function (t) { !t.__used && t.getElementCount() > 0 && (t.__dirty = !0, t.__startIndex = t.__endIndex = t.__drawIndex = 0), t.__dirty && t.__drawIndex < 0 && (t.__drawIndex = t.__startIndex) }) }, clear: function () { return this.eachBuiltinLayer(this._clearLayer), this }, _clearLayer: function (t) { t.clear() }, setBackgroundColor: function (t) { this._backgroundColor = t }, configLayer: function (t, e) { if (e) { var i = this._layerConfig; i[t] ? r(i[t], e, !0) : i[t] = e; for (var n = 0; n < this._zlevelList.length; n++) { var a = this._zlevelList[n]; if (a === t || a === t + Am) { var o = this._layers[a]; r(o, i[t], !0) } } } }, delLayer: function (t) { var e = this._layers, i = this._zlevelList, n = e[t]; n && (n.dom.parentNode.removeChild(n.dom), delete e[t], i.splice(u(i, t), 1)) }, resize: function (t, e) { if (this._domRoot.style) { var i = this._domRoot; i.style.display = "none"; var n = this._opts; if (null != t && (n.width = t), null != e && (n.height = e), t = this._getSize(0), e = this._getSize(1), i.style.display = "", this._width !== t || e !== this._height) { i.style.width = t + "px", i.style.height = e + "px"; for (var r in this._layers) this._layers.hasOwnProperty(r) && this._layers[r].resize(t, e); f(this._progressiveLayers, function (i) { i.resize(t, e) }), this.refresh(!0) } this._width = t, this._height = e } else { if (null == t || null == e) return; this._width = t, this._height = e, this.getLayer(Tm).resize(t, e) } return this }, clearLayer: function (t) { var e = this._layers[t]; e && e.clear() }, dispose: function () { this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null }, getRenderedCanvas: function (t) { if (t = t || {}, this._singleCanvas && !this._compositeManually) return this._layers[Tm].dom; var e = new cm("image", this, t.pixelRatio || this.dpr); if (e.initContext(), e.clear(!1, t.backgroundColor || this._backgroundColor), t.pixelRatio <= this.dpr) { this.refresh(); var i = e.dom.width, n = e.dom.height, r = e.ctx; this.eachLayer(function (t) { t.__builtin__ ? r.drawImage(t.dom, 0, 0, i, n) : t.renderToCanvas && (e.ctx.save(), t.renderToCanvas(e.ctx), e.ctx.restore()) }) } else for (var a = {}, o = this.storage.getDisplayList(!0), s = 0; s < o.length; s++) { var l = o[s]; this._doPaintEl(l, e, !0, a) } return e.dom }, getWidth: function () { return this._width }, getHeight: function () { return this._height }, _getSize: function (t) { var e = this._opts, i = ["width", "height"][t], n = ["clientWidth", "clientHeight"][t], r = ["paddingLeft", "paddingTop"][t], a = ["paddingRight", "paddingBottom"][t]; if (null != e[i] && "auto" !== e[i]) return parseFloat(e[i]); var o = this.root, s = document.defaultView.getComputedStyle(o); return (o[n] || _n(s[i]) || _n(o.style[i])) - (_n(s[r]) || 0) - (_n(s[a]) || 0) | 0 }, pathToImage: function (t, e) { e = e || this.dpr; var i = document.createElement("canvas"), n = i.getContext("2d"), r = t.getBoundingRect(), a = t.style, o = a.shadowBlur * e, s = a.shadowOffsetX * e, l = a.shadowOffsetY * e, u = a.hasStroke() ? a.lineWidth : 0, h = Math.max(u / 2, -s + o), c = Math.max(u / 2, s + o), d = Math.max(u / 2, -l + o), f = Math.max(u / 2, l + o), p = r.width + h + c, g = r.height + d + f; i.width = p * e, i.height = g * e, n.scale(e, e), n.clearRect(0, 0, p, g), n.dpr = e; var m = { position: t.position, rotation: t.rotation, scale: t.scale }; t.position = [h - r.x, d - r.y], t.rotation = 0, t.scale = [1, 1], t.updateTransform(), t && t.brush(n); var v = xn, y = new v({ style: { x: 0, y: 0, image: i } }); return null != m.position && (y.position = t.position = m.position), null != m.rotation && (y.rotation = t.rotation = m.rotation), null != m.scale && (y.scale = t.scale = m.scale), y } }; var Om = function (t) { t = t || {}, this.stage = t.stage || {}, this.onframe = t.onframe || function () { }, this._clips = [], this._running = !1, this._time, this._pausedTime, this._pauseStart, this._paused = !1, ug.call(this) }; Om.prototype = { constructor: Om, addClip: function (t) { this._clips.push(t) }, addAnimator: function (t) { t.animation = this; for (var e = t.getClips(), i = 0; i < e.length; i++)this.addClip(e[i]) }, removeClip: function (t) { var e = u(this._clips, t); e >= 0 && this._clips.splice(e, 1) }, removeAnimator: function (t) { for (var e = t.getClips(), i = 0; i < e.length; i++)this.removeClip(e[i]); t.animation = null }, _update: function () { for (var t = (new Date).getTime() - this._pausedTime, e = t - this._time, i = this._clips, n = i.length, r = [], a = [], o = 0; n > o; o++) { var s = i[o], l = s.step(t, e); l && (r.push(l), a.push(s)) } for (var o = 0; n > o;)i[o]._needsRemove ? (i[o] = i[n - 1], i.pop(), n--) : o++; n = r.length; for (var o = 0; n > o; o++)a[o].fire(r[o]); this._time = t, this.onframe(e), this.trigger("frame", e), this.stage.update && this.stage.update() }, _startLoop: function () { function t() { e._running && (dm(t), !e._paused && e._update()) } var e = this; this._running = !0, dm(t) }, start: function () { this._time = (new Date).getTime(), this._pausedTime = 0, this._startLoop() }, stop: function () { this._running = !1 }, pause: function () { this._paused || (this._pauseStart = (new Date).getTime(), this._paused = !0) }, resume: function () { this._paused && (this._pausedTime += (new Date).getTime() - this._pauseStart, this._paused = !1) }, clear: function () { this._clips = [] }, isFinished: function () { return !this._clips.length }, animate: function (t, e) { e = e || {}; var i = new Vg(t, e.loop, e.getter, e.setter); return this.addAnimator(i), i } }, c(Om, ug); var zm = 300, Em = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"], Bm = ["touchstart", "touchend", "touchmove"], Rm = { pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1 }, Nm = p(Em, function (t) { var e = t.replace("mouse", "pointer"); return Rm[e] ? e : t }), Fm = { mousemove: function (t) { t = ge(this.dom, t), this.trigger("mousemove", t) }, mouseout: function (t) { t = ge(this.dom, t); var e = t.toElement || t.relatedTarget; if (e !== this.dom) for (; e && 9 !== e.nodeType;) { if (e === this.dom) return; e = e.parentNode } this.trigger("mouseout", t) }, touchstart: function (t) { t = ge(this.dom, t), t.zrByTouch = !0, this._lastTouchMoment = new Date, this.handler.processGesture(this, t, "start"), Fm.mousemove.call(this, t), Fm.mousedown.call(this, t), Tn(this) }, touchmove: function (t) { t = ge(this.dom, t), t.zrByTouch = !0, this.handler.processGesture(this, t, "change"), Fm.mousemove.call(this, t), Tn(this) }, touchend: function (t) { t = ge(this.dom, t), t.zrByTouch = !0, this.handler.processGesture(this, t, "end"), Fm.mouseup.call(this, t), +new Date - this._lastTouchMoment < zm && Fm.click.call(this, t), Tn(this) }, pointerdown: function (t) { Fm.mousedown.call(this, t) }, pointermove: function (t) { An(t) || Fm.mousemove.call(this, t) }, pointerup: function (t) { Fm.mouseup.call(this, t) }, pointerout: function (t) { An(t) || Fm.mouseout.call(this, t) } }; f(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function (t) { Fm[t] = function (e) { e = ge(this.dom, e), this.trigger(t, e) } }); var Vm = kn.prototype; Vm.dispose = function () { for (var t = Em.concat(Bm), e = 0; e < t.length; e++) { var i = t[e]; ve(this.dom, Dn(i), this._handlers[i]) } }, Vm.setCursor = function (t) { this.dom.style && (this.dom.style.cursor = t || "default") }, c(kn, ug); var Gm = !Gp.canvasSupported, Hm = { canvas: Lm }, Wm = {}, Xm = "4.0.7", Um = function (t, e, i) { i = i || {}, this.dom = e, this.id = t; var n = this, r = new tm, a = i.renderer; if (Gm) { if (!Hm.vml) throw new Error("You need to require 'zrender/vml/vml' to support IE8"); a = "vml" } else a && Hm[a] || (a = "canvas"); var o = new Hm[a](e, r, i, t); this.storage = r, this.painter = o; var s = Gp.node || Gp.worker ? null : new kn(o.getViewportRoot()); this.handler = new vg(r, o, s, o.root), this.animation = new Om({ stage: { update: y(this.flush, this) } }), this.animation.start(), this._needsRefresh; var l = r.delFromStorage, u = r.addToStorage; r.delFromStorage = function (t) { l.call(r, t), t && t.removeSelfFromZr(n) }, r.addToStorage = function (t) { u.call(r, t), t.addSelfToZr(n) } }; Um.prototype = { constructor: Um, getId: function () { return this.id }, add: function (t) { this.storage.addRoot(t), this._needsRefresh = !0 }, remove: function (t) { this.storage.delRoot(t), this._needsRefresh = !0 }, configLayer: function (t, e) { this.painter.configLayer && this.painter.configLayer(t, e), this._needsRefresh = !0 }, setBackgroundColor: function (t) { this.painter.setBackgroundColor && this.painter.setBackgroundColor(t), this._needsRefresh = !0 }, refreshImmediately: function () { this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1 }, refresh: function () { this._needsRefresh = !0 }, flush: function () { var t; this._needsRefresh && (t = !0, this.refreshImmediately()), this._needsRefreshHover && (t = !0, this.refreshHoverImmediately()), t && this.trigger("rendered") }, addHover: function (t, e) { if (this.painter.addHover) { var i = this.painter.addHover(t, e); return this.refreshHover(), i } }, removeHover: function (t) { this.painter.removeHover && (this.painter.removeHover(t), this.refreshHover()) }, clearHover: function () { this.painter.clearHover && (this.painter.clearHover(), this.refreshHover()) }, refreshHover: function () { this._needsRefreshHover = !0 }, refreshHoverImmediately: function () { this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.refreshHover() }, resize: function (t) { t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize() }, clearAnimation: function () { this.animation.clear() }, getWidth: function () { return this.painter.getWidth() }, getHeight: function () { return this.painter.getHeight() }, pathToImage: function (t, e) { return this.painter.pathToImage(t, e) }, setCursorStyle: function (t) { this.handler.setCursorStyle(t) }, findHover: function (t, e) { return this.handler.findHover(t, e) }, on: function (t, e, i) { this.handler.on(t, e, i) }, off: function (t, e) { this.handler.off(t, e) }, trigger: function (t, e) { this.handler.trigger(t, e) }, clear: function () { this.storage.delRoot(), this.painter.clear() }, dispose: function () { this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, En(this.id) } }; var jm = (Object.freeze || Object)({ version: Xm, init: Pn, dispose: Ln, getInstance: On, registerPainter: zn }), Ym = f, qm = S, Zm = _, Km = "series\x00", $m = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"], Qm = 0, Jm = ".", tv = "___EC__COMPONENT__CONTAINER___", ev = 0, iv = function (t) { for (var e = 0; e < t.length; e++)t[e][1] || (t[e][1] = t[e][0]); return function (e, i, n) { for (var r = {}, a = 0; a < t.length; a++) { var o = t[a][1]; if (!(i && u(i, o) >= 0 || n && u(n, o) < 0)) { var s = e.getShallow(o); null != s && (r[t[a][0]] = s) } } return r } }, nv = iv([["lineWidth", "width"], ["stroke", "color"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]), rv = { getLineStyle: function (t) { var e = nv(this, t), i = this.getLineDash(e.lineWidth); return i && (e.lineDash = i), e }, getLineDash: function (t) { null == t && (t = 1); var e = this.get("type"), i = Math.max(t, 2), n = 4 * t; return "solid" === e || null == e ? null : "dashed" === e ? [n, n] : [i, i] } }, av = iv([["fill", "color"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["opacity"], ["shadowColor"]]), ov = { getAreaStyle: function (t, e) { return av(this, t, e) } }, sv = Math.pow, lv = Math.sqrt, uv = 1e-8, hv = 1e-4, cv = lv(3), dv = 1 / 3, fv = G(), pv = G(), gv = G(), mv = Math.min, vv = Math.max, yv = Math.sin, xv = Math.cos, _v = 2 * Math.PI, bv = G(), wv = G(), Sv = G(), Mv = [], Iv = [], Dv = { M: 1, L: 2, C: 3, Q: 4, A: 5, Z: 6, R: 7 }, Tv = [], Av = [], Cv = [], kv = [], Pv = Math.min, Lv = Math.max, Ov = Math.cos, zv = Math.sin, Ev = Math.sqrt, Bv = Math.abs, Rv = "undefined" != typeof Float32Array, Nv = function (t) { this._saveData = !t, this._saveData && (this.data = []), this._ctx = null }; Nv.prototype = { constructor: Nv, _xi: 0, _yi: 0, _x0: 0, _y0: 0, _ux: 0, _uy: 0, _len: 0, _lineDash: null, _dashOffset: 0, _dashIdx: 0, _dashSum: 0, setScale: function (t, e) { this._ux = Bv(1 / Wg / t) || 0, this._uy = Bv(1 / Wg / e) || 0 }, getContext: function () { return this._ctx }, beginPath: function (t) { return this._ctx = t, t && t.beginPath(), t && (this.dpr = t.dpr), this._saveData && (this._len = 0), this._lineDash && (this._lineDash = null, this._dashOffset = 0), this }, moveTo: function (t, e) { return this.addData(Dv.M, t, e), this._ctx && this._ctx.moveTo(t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this }, lineTo: function (t, e) { var i = Bv(t - this._xi) > this._ux || Bv(e - this._yi) > this._uy || this._len < 5; return this.addData(Dv.L, t, e), this._ctx && i && (this._needsDash() ? this._dashedLineTo(t, e) : this._ctx.lineTo(t, e)), i && (this._xi = t, this._yi = e), this }, bezierCurveTo: function (t, e, i, n, r, a) { return this.addData(Dv.C, t, e, i, n, r, a), this._ctx && (this._needsDash() ? this._dashedBezierTo(t, e, i, n, r, a) : this._ctx.bezierCurveTo(t, e, i, n, r, a)), this._xi = r, this._yi = a, this }, quadraticCurveTo: function (t, e, i, n) { return this.addData(Dv.Q, t, e, i, n), this._ctx && (this._needsDash() ? this._dashedQuadraticTo(t, e, i, n) : this._ctx.quadraticCurveTo(t, e, i, n)), this._xi = i, this._yi = n, this }, arc: function (t, e, i, n, r, a) { return this.addData(Dv.A, t, e, i, i, n, r - n, 0, a ? 0 : 1), this._ctx && this._ctx.arc(t, e, i, n, r, a), this._xi = Ov(r) * i + t, this._yi = zv(r) * i + e, this }, arcTo: function (t, e, i, n, r) { return this._ctx && this._ctx.arcTo(t, e, i, n, r), this }, rect: function (t, e, i, n) { return this._ctx && this._ctx.rect(t, e, i, n), this.addData(Dv.R, t, e, i, n), this }, closePath: function () { this.addData(Dv.Z); var t = this._ctx, e = this._x0, i = this._y0; return t && (this._needsDash() && this._dashedLineTo(e, i), t.closePath()), this._xi = e, this._yi = i, this }, fill: function (t) { t && t.fill(), this.toStatic() }, stroke: function (t) { t && t.stroke(), this.toStatic() }, setLineDash: function (t) { if (t instanceof Array) { this._lineDash = t, this._dashIdx = 0; for (var e = 0, i = 0; i < t.length; i++)e += t[i]; this._dashSum = e } return this }, setLineDashOffset: function (t) { return this._dashOffset = t, this }, len: function () { return this._len }, setData: function (t) { var e = t.length; this.data && this.data.length === e || !Rv || (this.data = new Float32Array(e)); for (var i = 0; e > i; i++)this.data[i] = t[i]; this._len = e }, appendPath: function (t) { t instanceof Array || (t = [t]); for (var e = t.length, i = 0, n = this._len, r = 0; e > r; r++)i += t[r].len(); Rv && this.data instanceof Float32Array && (this.data = new Float32Array(n + i)); for (var r = 0; e > r; r++)for (var a = t[r].data, o = 0; o < a.length; o++)this.data[n++] = a[o]; this._len = n }, addData: function (t) { if (this._saveData) { var e = this.data; this._len + arguments.length > e.length && (this._expandData(), e = this.data); for (var i = 0; i < arguments.length; i++)e[this._len++] = arguments[i]; this._prevCmd = t } }, _expandData: function () { if (!(this.data instanceof Array)) { for (var t = [], e = 0; e < this._len; e++)t[e] = this.data[e]; this.data = t } }, _needsDash: function () { return this._lineDash }, _dashedLineTo: function (t, e) { var i, n, r = this._dashSum, a = this._dashOffset, o = this._lineDash, s = this._ctx, l = this._xi, u = this._yi, h = t - l, c = e - u, d = Ev(h * h + c * c), f = l, p = u, g = o.length; for (h /= d, c /= d, 0 > a && (a = r + a), a %= r, f -= a * h, p -= a * c; h > 0 && t >= f || 0 > h && f >= t || 0 === h && (c > 0 && e >= p || 0 > c && p >= e);)n = this._dashIdx, i = o[n], f += h * i, p += c * i, this._dashIdx = (n + 1) % g, h > 0 && l > f || 0 > h && f > l || c > 0 && u > p || 0 > c && p > u || s[n % 2 ? "moveTo" : "lineTo"](h >= 0 ? Pv(f, t) : Lv(f, t), c >= 0 ? Pv(p, e) : Lv(p, e)); h = f - t, c = p - e, this._dashOffset = -Ev(h * h + c * c) }, _dashedBezierTo: function (t, e, i, n, r, a) { var o, s, l, u, h, c = this._dashSum, d = this._dashOffset, f = this._lineDash, p = this._ctx, g = this._xi, m = this._yi, v = sr, y = 0, x = this._dashIdx, _ = f.length, b = 0; for (0 > d && (d = c + d), d %= c, o = 0; 1 > o; o += .1)s = v(g, t, i, r, o + .1) - v(g, t, i, r, o), l = v(m, e, n, a, o + .1) - v(m, e, n, a, o), y += Ev(s * s + l * l); for (; _ > x && (b += f[x], !(b > d)); x++); for (o = (b - d) / y; 1 >= o;)u = v(g, t, i, r, o), h = v(m, e, n, a, o), x % 2 ? p.moveTo(u, h) : p.lineTo(u, h), o += f[x] / y, x = (x + 1) % _; x % 2 !== 0 && p.lineTo(r, a), s = r - u, l = a - h, this._dashOffset = -Ev(s * s + l * l) }, _dashedQuadraticTo: function (t, e, i, n) { var r = i, a = n; i = (i + 2 * t) / 3, n = (n + 2 * e) / 3, t = (this._xi + 2 * t) / 3, e = (this._yi + 2 * e) / 3, this._dashedBezierTo(t, e, i, n, r, a) }, toStatic: function () { var t = this.data; t instanceof Array && (t.length = this._len, Rv && (this.data = new Float32Array(t))) }, getBoundingRect: function () { Tv[0] = Tv[1] = Cv[0] = Cv[1] = Number.MAX_VALUE, Av[0] = Av[1] = kv[0] = kv[1] = -Number.MAX_VALUE; for (var t = this.data, e = 0, i = 0, n = 0, r = 0, a = 0; a < t.length;) { var o = t[a++]; switch (1 === a && (e = t[a], i = t[a + 1], n = e, r = i), o) { case Dv.M: n = t[a++], r = t[a++], e = n, i = r, Cv[0] = n, Cv[1] = r, kv[0] = n, kv[1] = r; break; case Dv.L: _r(e, i, t[a], t[a + 1], Cv, kv), e = t[a++], i = t[a++]; break; case Dv.C: br(e, i, t[a++], t[a++], t[a++], t[a++], t[a], t[a + 1], Cv, kv), e = t[a++], i = t[a++]; break; case Dv.Q: wr(e, i, t[a++], t[a++], t[a], t[a + 1], Cv, kv), e = t[a++], i = t[a++]; break; case Dv.A: var s = t[a++], l = t[a++], u = t[a++], h = t[a++], c = t[a++], d = t[a++] + c; a += 1; var f = 1 - t[a++]; 1 === a && (n = Ov(c) * u + s, r = zv(c) * h + l), Sr(s, l, u, h, c, d, f, Cv, kv), e = Ov(d) * u + s, i = zv(d) * h + l; break; case Dv.R: n = e = t[a++], r = i = t[a++]; var p = t[a++], g = t[a++]; _r(n, r, n + p, r + g, Cv, kv); break; case Dv.Z: e = n, i = r }oe(Tv, Tv, Cv), se(Av, Av, kv) } return 0 === a && (Tv[0] = Tv[1] = Av[0] = Av[1] = 0), new vi(Tv[0], Tv[1], Av[0] - Tv[0], Av[1] - Tv[1]) }, rebuildPath: function (t) { for (var e, i, n, r, a, o, s = this.data, l = this._ux, u = this._uy, h = this._len, c = 0; h > c;) { var d = s[c++]; switch (1 === c && (n = s[c], r = s[c + 1], e = n, i = r), d) { case Dv.M: e = n = s[c++], i = r = s[c++], t.moveTo(n, r); break; case Dv.L: a = s[c++], o = s[c++], (Bv(a - n) > l || Bv(o - r) > u || c === h - 1) && (t.lineTo(a, o), n = a, r = o); break; case Dv.C: t.bezierCurveTo(s[c++], s[c++], s[c++], s[c++], s[c++], s[c++]), n = s[c - 2], r = s[c - 1]; break; case Dv.Q: t.quadraticCurveTo(s[c++], s[c++], s[c++], s[c++]), n = s[c - 2], r = s[c - 1]; break; case Dv.A: var f = s[c++], p = s[c++], g = s[c++], m = s[c++], v = s[c++], y = s[c++], x = s[c++], _ = s[c++], b = g > m ? g : m, w = g > m ? 1 : g / m, S = g > m ? m / g : 1, M = Math.abs(g - m) > .001, I = v + y; M ? (t.translate(f, p), t.rotate(x), t.scale(w, S), t.arc(0, 0, b, v, I, 1 - _), t.scale(1 / w, 1 / S), t.rotate(-x), t.translate(-f, -p)) : t.arc(f, p, b, v, I, 1 - _), 1 === c && (e = Ov(v) * g + f, i = zv(v) * m + p), n = Ov(I) * g + f, r = zv(I) * m + p; break; case Dv.R: e = n = s[c], i = r = s[c + 1], t.rect(s[c++], s[c++], s[c++], s[c++]); break; case Dv.Z: t.closePath(), n = e, r = i } } } }, Nv.CMD = Dv; var Fv = 2 * Math.PI, Vv = 2 * Math.PI, Gv = Nv.CMD, Hv = 2 * Math.PI, Wv = 1e-4, Xv = [-1, -1, -1], Uv = [-1, -1], jv = hm.prototype.getCanvasPattern, Yv = Math.abs, qv = new Nv(!0); Nr.prototype = { constructor: Nr, type: "path", __dirtyPath: !0, strokeContainThreshold: 5, subPixelOptimize: !1, brush: function (t, e) { var i = this.style, n = this.path || qv, r = i.hasStroke(), a = i.hasFill(), o = i.fill, s = i.stroke, l = a && !!o.colorStops, u = r && !!s.colorStops, h = a && !!o.image, c = r && !!s.image; if (i.bind(t, this, e), this.setTransform(t), this.__dirty) { var d; l && (d = d || this.getBoundingRect(), this._fillGradient = i.getGradient(t, o, d)), u && (d = d || this.getBoundingRect(), this._strokeGradient = i.getGradient(t, s, d)) } l ? t.fillStyle = this._fillGradient : h && (t.fillStyle = jv.call(o, t)), u ? t.strokeStyle = this._strokeGradient : c && (t.strokeStyle = jv.call(s, t)); var f = i.lineDash, p = i.lineDashOffset, g = !!t.setLineDash, m = this.getGlobalScale(); if (n.setScale(m[0], m[1]), this.__dirtyPath || f && !g && r ? (n.beginPath(t), f && !g && (n.setLineDash(f), n.setLineDashOffset(p)), this.buildPath(n, this.shape, !1), this.path && (this.__dirtyPath = !1)) : (t.beginPath(), this.path.rebuildPath(t)), a) if (null != i.fillOpacity) { var v = t.globalAlpha; t.globalAlpha = i.fillOpacity * i.opacity, n.fill(t), t.globalAlpha = v } else n.fill(t); if (f && g && (t.setLineDash(f), t.lineDashOffset = p), r) if (null != i.strokeOpacity) { var v = t.globalAlpha; t.globalAlpha = i.strokeOpacity * i.opacity, n.stroke(t), t.globalAlpha = v } else n.stroke(t); f && g && t.setLineDash([]), null != i.text && (this.restoreTransform(t), this.drawRectText(t, this.getBoundingRect())) }, buildPath: function () { }, createPathProxy: function () { this.path = new Nv }, getBoundingRect: function () { var t = this._rect, e = this.style, i = !t; if (i) { var n = this.path; n || (n = this.path = new Nv), this.__dirtyPath && (n.beginPath(), this.buildPath(n, this.shape, !1)), t = n.getBoundingRect() } if (this._rect = t, e.hasStroke()) { var r = this._rectWithStroke || (this._rectWithStroke = t.clone()); if (this.__dirty || i) { r.copy(t); var a = e.lineWidth, o = e.strokeNoScale ? this.getLineScale() : 1; e.hasFill() || (a = Math.max(a, this.strokeContainThreshold || 4)), o > 1e-10 && (r.width += a / o, r.height += a / o, r.x -= a / o / 2, r.y -= a / o / 2) } return r } return t }, contain: function (t, e) { var i = this.transformCoordToLocal(t, e), n = this.getBoundingRect(), r = this.style; if (t = i[0], e = i[1], n.contain(t, e)) { var a = this.path.data; if (r.hasStroke()) { var o = r.lineWidth, s = r.strokeNoScale ? this.getLineScale() : 1; if (s > 1e-10 && (r.hasFill() || (o = Math.max(o, this.strokeContainThreshold)), Rr(a, o / s, t, e))) return !0 } if (r.hasFill()) return Br(a, t, e) } return !1 }, dirty: function (t) { null == t && (t = !0), t && (this.__dirtyPath = t, this._rect = null), this.__dirty = this.__dirtyText = !0, this.__zr && this.__zr.refresh(), this.__clipTarget && this.__clipTarget.dirty() }, animateShape: function (t) { return this.animate("shape", t) }, attrKV: function (t, e) { "shape" === t ? (this.setShape(e), this.__dirtyPath = !0, this._rect = null) : yn.prototype.attrKV.call(this, t, e) }, setShape: function (t, e) { var i = this.shape; if (i) { if (S(t)) for (var n in t) t.hasOwnProperty(n) && (i[n] = t[n]); else i[t] = e; this.dirty(!0) } return this }, getLineScale: function () { var t = this.transform; return t && Yv(t[0] - 1) > 1e-10 && Yv(t[3] - 1) > 1e-10 ? Math.sqrt(Yv(t[0] * t[3] - t[2] * t[1])) : 1 } }, Nr.extend = function (t) { var e = function (e) { Nr.call(this, e), t.style && this.style.extendFrom(t.style, !1); var i = t.shape; if (i) { this.shape = this.shape || {}; var n = this.shape; for (var r in i) !n.hasOwnProperty(r) && i.hasOwnProperty(r) && (n[r] = i[r]) } t.init && t.init.call(this, e) }; h(e, Nr); for (var i in t) "style" !== i && "shape" !== i && (e.prototype[i] = t[i]); return e }, h(Nr, yn); var Zv = Nv.CMD, Kv = [[], [], []], $v = Math.sqrt, Qv = Math.atan2, Jv = function (t, e) { var i, n, r, a, o, s, l = t.data, u = Zv.M, h = Zv.C, c = Zv.L, d = Zv.R, f = Zv.A, p = Zv.Q; for (r = 0, a = 0; r < l.length;) { switch (i = l[r++], a = r, n = 0, i) { case u: n = 1; break; case c: n = 1; break; case h: n = 3; break; case p: n = 2; break; case f: var g = e[4], m = e[5], v = $v(e[0] * e[0] + e[1] * e[1]), y = $v(e[2] * e[2] + e[3] * e[3]), x = Qv(-e[1] / y, e[0] / v); l[r] *= v, l[r++] += g, l[r] *= y, l[r++] += m, l[r++] *= v, l[r++] *= y, l[r++] += x, l[r++] += x, r += 2, a = r; break; case d: s[0] = l[r++], s[1] = l[r++], ae(s, s, e), l[a++] = s[0], l[a++] = s[1], s[0] += l[r++], s[1] += l[r++], ae(s, s, e), l[a++] = s[0], l[a++] = s[1] }for (o = 0; n > o; o++) { var s = Kv[o]; s[0] = l[r++], s[1] = l[r++], ae(s, s, e), l[a++] = s[0], l[a++] = s[1] } } }, ty = Math.sqrt, ey = Math.sin, iy = Math.cos, ny = Math.PI, ry = function (t) { return Math.sqrt(t[0] * t[0] + t[1] * t[1]) }, ay = function (t, e) { return (t[0] * e[0] + t[1] * e[1]) / (ry(t) * ry(e)) }, oy = function (t, e) { return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(ay(t, e)) }, sy = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/gi, ly = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g, uy = function (t) { yn.call(this, t) }; uy.prototype = { constructor: uy, type: "text", brush: function (t, e) { var i = this.style; this.__dirty && Ji(i, !0), i.fill = i.stroke = i.shadowBlur = i.shadowColor = i.shadowOffsetX = i.shadowOffsetY = null; var n = i.text; return null != n && (n += ""), vn(n, i) ? (this.setTransform(t), en(this, t, n, i, null, e), void this.restoreTransform(t)) : void (t.__attrCachedBy = nm.NONE) }, getBoundingRect: function () { var t = this.style; if (this.__dirty && Ji(t, !0), !this._rect) { var e = t.text; null != e ? e += "" : e = ""; var i = Bi(t.text + "", t.font, t.textAlign, t.textVerticalAlign, t.textPadding, t.textLineHeight, t.rich); if (i.x += t.x || 0, i.y += t.y || 0, fn(t.textStroke, t.textStrokeWidth)) { var n = t.textStrokeWidth; i.x -= n / 2, i.y -= n / 2, i.width += n, i.height += n } this._rect = i } return this._rect } }, h(uy, yn); var hy = Nr.extend({ type: "circle", shape: { cx: 0, cy: 0, r: 0 }, buildPath: function (t, e, i) { i && t.moveTo(e.cx + e.r, e.cy), t.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI, !0) } }), cy = [["shadowBlur", 0], ["shadowColor", "#000"], ["shadowOffsetX", 0], ["shadowOffsetY", 0]], dy = function (t) { return Gp.browser.ie && Gp.browser.version >= 11 ? function () { var e, i = this.__clipPaths, n = this.style; if (i) for (var r = 0; r < i.length; r++) { var a = i[r], o = a && a.shape, s = a && a.type; if (o && ("sector" === s && o.startAngle === o.endAngle || "rect" === s && (!o.width || !o.height))) { for (var l = 0; l < cy.length; l++)cy[l][2] = n[cy[l][0]], n[cy[l][0]] = cy[l][1]; e = !0; break } } if (t.apply(this, arguments), e) for (var l = 0; l < cy.length; l++)n[cy[l][0]] = cy[l][2] } : t }, fy = Nr.extend({ type: "sector", shape: { cx: 0, cy: 0, r0: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0 }, brush: dy(Nr.prototype.brush), buildPath: function (t, e) { var i = e.cx, n = e.cy, r = Math.max(e.r0 || 0, 0), a = Math.max(e.r, 0), o = e.startAngle, s = e.endAngle, l = e.clockwise, u = Math.cos(o), h = Math.sin(o); t.moveTo(u * r + i, h * r + n), t.lineTo(u * a + i, h * a + n), t.arc(i, n, a, o, s, !l), t.lineTo(Math.cos(s) * r + i, Math.sin(s) * r + n), 0 !== r && t.arc(i, n, r, s, o, l), t.closePath() } }), py = Nr.extend({ type: "ring", shape: { cx: 0, cy: 0, r: 0, r0: 0 }, buildPath: function (t, e) { var i = e.cx, n = e.cy, r = 2 * Math.PI; t.moveTo(i + e.r, n), t.arc(i, n, e.r, 0, r, !1), t.moveTo(i + e.r0, n), t.arc(i, n, e.r0, 0, r, !0) } }), gy = function (t, e) { for (var i = t.length, n = [], r = 0, a = 1; i > a; a++)r += ee(t[a - 1], t[a]); var o = r / 2; o = i > o ? i : o; for (var a = 0; o > a; a++) { var s, l, u, h = a / (o - 1) * (e ? i : i - 1), c = Math.floor(h), d = h - c, f = t[c % i]; e ? (s = t[(c - 1 + i) % i], l = t[(c + 1) % i], u = t[(c + 2) % i]) : (s = t[0 === c ? c : c - 1], l = t[c > i - 2 ? i - 1 : c + 1], u = t[c > i - 3 ? i - 1 : c + 2]); var p = d * d, g = d * p; n.push([Ur(s[0], f[0], l[0], u[0], d, p, g), Ur(s[1], f[1], l[1], u[1], d, p, g)]) } return n }, my = function (t, e, i, n) { var r, a, o, s, l = [], u = [], h = [], c = []; if (n) { o = [1 / 0, 1 / 0], s = [-1 / 0, -1 / 0]; for (var d = 0, f = t.length; f > d; d++)oe(o, o, t[d]), se(s, s, t[d]); oe(o, o, n[0]), se(s, s, n[1]) } for (var d = 0, f = t.length; f > d; d++) { var p = t[d]; if (i) r = t[d ? d - 1 : f - 1], a = t[(d + 1) % f]; else { if (0 === d || d === f - 1) { l.push(W(t[d])); continue } r = t[d - 1], a = t[d + 1] } Y(u, a, r), J(u, u, e); var g = ee(p, r), m = ee(p, a), v = g + m; 0 !== v && (g /= v, m /= v), J(h, u, -g), J(c, u, m); var y = U([], p, h), x = U([], p, c); n && (se(y, y, o), oe(y, y, s), se(x, x, o), oe(x, x, s)), l.push(y), l.push(x) } return i && l.push(l.shift()), l }, vy = Nr.extend({ type: "polygon", shape: { points: null, smooth: !1, smoothConstraint: null }, buildPath: function (t, e) { jr(t, e, !0) } }), yy = Nr.extend({ type: "polyline", shape: { points: null, smooth: !1, smoothConstraint: null }, style: { stroke: "#000", fill: null }, buildPath: function (t, e) { jr(t, e, !1) } }), xy = Math.round, _y = {}, by = Nr.extend({
    type: "rect", shape: { r: 0, x: 0, y: 0, width: 0, height: 0 }, buildPath: function (t, e) {
      var i, n, r, a; this.subPixelOptimize ? (qr(_y, e, this.style), i = _y.x, n = _y.y, r = _y.width, a = _y.height, _y.r = e.r, e = _y) : (i = e.x, n = e.y, r = e.width, a = e.height), e.r ? Qi(t, e) : t.rect(i, n, r, a), t.closePath()
    }
  }), wy = {}, Sy = Nr.extend({ type: "line", shape: { x1: 0, y1: 0, x2: 0, y2: 0, percent: 1 }, style: { stroke: "#000", fill: null }, buildPath: function (t, e) { var i, n, r, a; this.subPixelOptimize ? (Yr(wy, e, this.style), i = wy.x1, n = wy.y1, r = wy.x2, a = wy.y2) : (i = e.x1, n = e.y1, r = e.x2, a = e.y2); var o = e.percent; 0 !== o && (t.moveTo(i, n), 1 > o && (r = i * (1 - o) + r * o, a = n * (1 - o) + a * o), t.lineTo(r, a)) }, pointAt: function (t) { var e = this.shape; return [e.x1 * (1 - t) + e.x2 * t, e.y1 * (1 - t) + e.y2 * t] } }), My = [], Iy = Nr.extend({ type: "bezier-curve", shape: { x1: 0, y1: 0, x2: 0, y2: 0, cpx1: 0, cpy1: 0, percent: 1 }, style: { stroke: "#000", fill: null }, buildPath: function (t, e) { var i = e.x1, n = e.y1, r = e.x2, a = e.y2, o = e.cpx1, s = e.cpy1, l = e.cpx2, u = e.cpy2, h = e.percent; 0 !== h && (t.moveTo(i, n), null == l || null == u ? (1 > h && (vr(i, o, r, h, My), o = My[1], r = My[2], vr(n, s, a, h, My), s = My[1], a = My[2]), t.quadraticCurveTo(o, s, r, a)) : (1 > h && (cr(i, o, l, r, h, My), o = My[1], l = My[2], r = My[3], cr(n, s, u, a, h, My), s = My[1], u = My[2], a = My[3]), t.bezierCurveTo(o, s, l, u, r, a))) }, pointAt: function (t) { return Kr(this.shape, t, !1) }, tangentAt: function (t) { var e = Kr(this.shape, t, !0); return te(e, e) } }), Dy = Nr.extend({ type: "arc", shape: { cx: 0, cy: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0 }, style: { stroke: "#000", fill: null }, buildPath: function (t, e) { var i = e.cx, n = e.cy, r = Math.max(e.r, 0), a = e.startAngle, o = e.endAngle, s = e.clockwise, l = Math.cos(a), u = Math.sin(a); t.moveTo(l * r + i, u * r + n), t.arc(i, n, r, a, o, !s) } }), Ty = Nr.extend({ type: "compound", shape: { paths: null }, _updatePathDirty: function () { for (var t = this.__dirtyPath, e = this.shape.paths, i = 0; i < e.length; i++)t = t || e[i].__dirtyPath; this.__dirtyPath = t, this.__dirty = this.__dirty || t }, beforeBrush: function () { this._updatePathDirty(); for (var t = this.shape.paths || [], e = this.getGlobalScale(), i = 0; i < t.length; i++)t[i].path || t[i].createPathProxy(), t[i].path.setScale(e[0], e[1]) }, buildPath: function (t, e) { for (var i = e.paths || [], n = 0; n < i.length; n++)i[n].buildPath(t, i[n].shape, !0) }, afterBrush: function () { for (var t = this.shape.paths || [], e = 0; e < t.length; e++)t[e].__dirtyPath = !1 }, getBoundingRect: function () { return this._updatePathDirty(), Nr.prototype.getBoundingRect.call(this) } }), Ay = function (t) { this.colorStops = t || [] }; Ay.prototype = { constructor: Ay, addColorStop: function (t, e) { this.colorStops.push({ offset: t, color: e }) } }; var Cy = function (t, e, i, n, r, a) { this.x = null == t ? 0 : t, this.y = null == e ? 0 : e, this.x2 = null == i ? 1 : i, this.y2 = null == n ? 0 : n, this.type = "linear", this.global = a || !1, Ay.call(this, r) }; Cy.prototype = { constructor: Cy }, h(Cy, Ay); var ky = function (t, e, i, n, r) { this.x = null == t ? .5 : t, this.y = null == e ? .5 : e, this.r = null == i ? .5 : i, this.type = "radial", this.global = r || !1, Ay.call(this, n) }; ky.prototype = { constructor: ky }, h(ky, Ay), $r.prototype.incremental = !0, $r.prototype.clearDisplaybles = function () { this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.dirty(), this.notClear = !1 }, $r.prototype.addDisplayable = function (t, e) { e ? this._temporaryDisplayables.push(t) : this._displayables.push(t), this.dirty() }, $r.prototype.addDisplayables = function (t, e) { e = e || !1; for (var i = 0; i < t.length; i++)this.addDisplayable(t[i], e) }, $r.prototype.eachPendingDisplayable = function (t) { for (var e = this._cursor; e < this._displayables.length; e++)t && t(this._displayables[e]); for (var e = 0; e < this._temporaryDisplayables.length; e++)t && t(this._temporaryDisplayables[e]) }, $r.prototype.update = function () { this.updateTransform(); for (var t = this._cursor; t < this._displayables.length; t++) { var e = this._displayables[t]; e.parent = this, e.update(), e.parent = null } for (var t = 0; t < this._temporaryDisplayables.length; t++) { var e = this._temporaryDisplayables[t]; e.parent = this, e.update(), e.parent = null } }, $r.prototype.brush = function (t) { for (var e = this._cursor; e < this._displayables.length; e++) { var i = this._displayables[e]; i.beforeBrush && i.beforeBrush(t), i.brush(t, e === this._cursor ? null : this._displayables[e - 1]), i.afterBrush && i.afterBrush(t) } this._cursor = e; for (var e = 0; e < this._temporaryDisplayables.length; e++) { var i = this._temporaryDisplayables[e]; i.beforeBrush && i.beforeBrush(t), i.brush(t, 0 === e ? null : this._temporaryDisplayables[e - 1]), i.afterBrush && i.afterBrush(t) } this._temporaryDisplayables = [], this.notClear = !0 }; var Py = []; $r.prototype.getBoundingRect = function () { if (!this._rect) { for (var t = new vi(1 / 0, 1 / 0, -1 / 0, -1 / 0), e = 0; e < this._displayables.length; e++) { var i = this._displayables[e], n = i.getBoundingRect().clone(); i.needLocalTransform() && n.applyTransform(i.getLocalTransform(Py)), t.union(n) } this._rect = t } return this._rect }, $r.prototype.contain = function (t, e) { var i = this.transformCoordToLocal(t, e), n = this.getBoundingRect(); if (n.contain(i[0], i[1])) for (var r = 0; r < this._displayables.length; r++) { var a = this._displayables[r]; if (a.contain(t, e)) return !0 } return !1 }, h($r, yn); var Ly = Math.round, Oy = Math.max, zy = Math.min, Ey = {}, By = 1, Ry = Xr, Ny = N(), Fy = 0, Vy = (Object.freeze || Object)({ Z2_EMPHASIS_LIFT: By, extendShape: Qr, extendPath: Jr, makePath: ta, makeImage: ea, mergePath: Ry, resizePath: na, subPixelOptimizeLine: ra, subPixelOptimizeRect: aa, subPixelOptimize: oa, setElementHoverStyle: pa, isInEmphasis: ga, setHoverStyle: _a, setAsHoverStyleTrigger: ba, setLabelStyle: wa, setTextStyle: Sa, setText: Ma, getFont: Pa, updateProps: Oa, initProps: za, getTransform: Ea, applyTransform: Ba, transformDirection: Ra, groupTransition: Na, clipPointsByRect: Fa, clipRectByRect: Va, createIcon: Ga, Group: $g, Image: xn, Text: uy, Circle: hy, Sector: fy, Ring: py, Polygon: vy, Polyline: yy, Rect: by, Line: Sy, BezierCurve: Iy, Arc: Dy, IncrementalDisplayable: $r, CompoundPath: Ty, LinearGradient: Cy, RadialGradient: ky, BoundingRect: vi }), Gy = ["textStyle", "color"], Hy = { getTextColor: function (t) { var e = this.ecModel; return this.getShallow("color") || (!t && e ? e.get(Gy) : null) }, getFont: function () { return Pa({ fontStyle: this.getShallow("fontStyle"), fontWeight: this.getShallow("fontWeight"), fontSize: this.getShallow("fontSize"), fontFamily: this.getShallow("fontFamily") }, this.ecModel) }, getTextRect: function (t) { return Bi(t, this.getFont(), this.getShallow("align"), this.getShallow("verticalAlign") || this.getShallow("baseline"), this.getShallow("padding"), this.getShallow("lineHeight"), this.getShallow("rich"), this.getShallow("truncateText")) } }, Wy = iv([["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"], ["textPosition"], ["textAlign"]]), Xy = { getItemStyle: function (t, e) { var i = Wy(this, t, e), n = this.getBorderLineDash(); return n && (i.lineDash = n), i }, getBorderLineDash: function () { var t = this.get("borderType"); return "solid" === t || null == t ? null : "dashed" === t ? [5, 5] : [1, 1] } }, Uy = c, jy = Un(); Ha.prototype = { constructor: Ha, init: null, mergeOption: function (t) { r(this.option, t, !0) }, get: function (t, e) { return null == t ? this.option : Wa(this.option, this.parsePath(t), !e && Xa(this, t)) }, getShallow: function (t, e) { var i = this.option, n = null == i ? i : i[t], r = !e && Xa(this, t); return null == n && r && (n = r.getShallow(t)), n }, getModel: function (t, e) { var i, n = null == t ? this.option : Wa(this.option, t = this.parsePath(t)); return e = e || (i = Xa(this, t)) && i.getModel(t), new Ha(n, e, this.ecModel) }, isEmpty: function () { return null == this.option }, restoreData: function () { }, clone: function () { var t = this.constructor; return new t(n(this.option)) }, setReadOnly: function () { }, parsePath: function (t) { return "string" == typeof t && (t = t.split(".")), t }, customizeGetParent: function (t) { jy(this).getParent = t }, isAnimationEnabled: function () { if (!Gp.node) { if (null != this.option.animation) return !!this.option.animation; if (this.parentModel) return this.parentModel.isAnimationEnabled() } } }, tr(Ha), er(Ha), Uy(Ha, rv), Uy(Ha, ov), Uy(Ha, Hy), Uy(Ha, Xy); var Yy = 0, qy = 1e-4, Zy = 9007199254740991, Ky = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/, $y = (Object.freeze || Object)({ linearMap: Za, parsePercent: Ka, round: $a, asc: Qa, getPrecision: Ja, getPrecisionSafe: to, getPixelPrecision: eo, getPercentWithPrecision: io, MAX_SAFE_INTEGER: Zy, remRadian: no, isRadianAroundZero: ro, parseDate: ao, quantity: oo, nice: lo, quantile: uo, reformIntervals: ho, isNumeric: co }), Qy = L, Jy = /([&<>"'])/g, tx = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, ex = ["a", "b", "c", "d", "e", "f", "g"], ix = function (t, e) { return "{" + t + (null == e ? "" : e) + "}" }, nx = Hi, rx = (Object.freeze || Object)({ addCommas: fo, toCamelCase: po, normalizeCssArray: Qy, encodeHTML: go, formatTpl: mo, formatTplSimple: vo, getTooltipMarker: yo, formatTime: _o, capitalFirst: bo, truncateText: nx, getTextBoundingRect: wo, getTextRect: So }), ax = f, ox = ["left", "right", "top", "bottom", "width", "height"], sx = [["width", "left", "right"], ["height", "top", "bottom"]], lx = Mo, ux = (x(Mo, "vertical"), x(Mo, "horizontal"), { getBoxLayoutParams: function () { return { left: this.get("left"), top: this.get("top"), right: this.get("right"), bottom: this.get("bottom"), width: this.get("width"), height: this.get("height") } } }), hx = Un(), cx = Ha.extend({ type: "component", id: "", name: "", mainType: "", subType: "", componentIndex: 0, defaultOption: null, ecModel: null, dependentModels: [], uid: null, layoutMode: null, $constructor: function (t, e, i, n) { Ha.call(this, t, e, i, n), this.uid = Ua("ec_cpt_model") }, init: function (t, e, i) { this.mergeDefaultAndTheme(t, i) }, mergeDefaultAndTheme: function (t, e) { var i = this.layoutMode, n = i ? To(t) : {}, a = e.getTheme(); r(t, a.get(this.mainType)), r(t, this.getDefaultOption()), i && Do(t, n, i) }, mergeOption: function (t) { r(this.option, t, !0); var e = this.layoutMode; e && Do(this.option, t, e) }, optionUpdated: function () { }, getDefaultOption: function () { var t = hx(this); if (!t.defaultOption) { for (var e = [], i = this.constructor; i;) { var n = i.prototype.defaultOption; n && e.push(n), i = i.superClass } for (var a = {}, o = e.length - 1; o >= 0; o--)a = r(a, e[o], !0); t.defaultOption = a } return t.defaultOption }, getReferringComponents: function (t) { return this.ecModel.queryComponents({ mainType: t, index: this.get(t + "Index", !0), id: this.get(t + "Id", !0) }) } }); rr(cx, { registerWhenExtend: !0 }), ja(cx), Ya(cx, Co), c(cx, ux); var dx = ""; "undefined" != typeof navigator && (dx = navigator.platform || ""); var fx = { color: ["#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3"], gradientColor: ["#f6efa6", "#d88273", "#bf444c"], textStyle: { fontFamily: dx.match(/^Win/) ? "Microsoft YaHei" : "sans-serif", fontSize: 12, fontStyle: "normal", fontWeight: "normal" }, blendMode: null, animation: "auto", animationDuration: 1e3, animationDurationUpdate: 300, animationEasing: "exponentialOut", animationEasingUpdate: "cubicOut", animationThreshold: 2e3, progressiveThreshold: 3e3, progressive: 400, hoverLayerThreshold: 3e3, useUTC: !1 }, px = Un(), gx = { clearColorPalette: function () { px(this).colorIdx = 0, px(this).colorNameMap = {} }, getColorFromPalette: function (t, e, i) { e = e || this; var n = px(e), r = n.colorIdx || 0, a = n.colorNameMap = n.colorNameMap || {}; if (a.hasOwnProperty(t)) return a[t]; var o = Bn(this.get("color", !0)), s = this.get("colorLayer", !0), l = null != i && s ? ko(s, i) : o; if (l = l || o, l && l.length) { var u = l[r]; return t && (a[t] = u), n.colorIdx = (r + 1) % l.length, u } } }, mx = { cartesian2d: function (t, e, i, n) { var r = t.getReferringComponents("xAxis")[0], a = t.getReferringComponents("yAxis")[0]; e.coordSysDims = ["x", "y"], i.set("x", r), i.set("y", a), Lo(r) && (n.set("x", r), e.firstCategoryDimIndex = 0), Lo(a) && (n.set("y", a), e.firstCategoryDimIndex = 1) }, singleAxis: function (t, e, i, n) { var r = t.getReferringComponents("singleAxis")[0]; e.coordSysDims = ["single"], i.set("single", r), Lo(r) && (n.set("single", r), e.firstCategoryDimIndex = 0) }, polar: function (t, e, i, n) { var r = t.getReferringComponents("polar")[0], a = r.findAxisModel("radiusAxis"), o = r.findAxisModel("angleAxis"); e.coordSysDims = ["radius", "angle"], i.set("radius", a), i.set("angle", o), Lo(a) && (n.set("radius", a), e.firstCategoryDimIndex = 0), Lo(o) && (n.set("angle", o), e.firstCategoryDimIndex = 1) }, geo: function (t, e) { e.coordSysDims = ["lng", "lat"] }, parallel: function (t, e, i, n) { var r = t.ecModel, a = r.getComponent("parallel", t.get("parallelIndex")), o = e.coordSysDims = a.dimensions.slice(); f(a.parallelAxisIndex, function (t, a) { var s = r.getComponent("parallelAxis", t), l = o[a]; i.set(l, s), Lo(s) && null == e.firstCategoryDimIndex && (n.set(l, s), e.firstCategoryDimIndex = a) }) } }, vx = "original", yx = "arrayRows", xx = "objectRows", _x = "keyedColumns", bx = "unknown", Sx = "typedArray", Mx = "column", Ix = "row"; Oo.seriesDataToSource = function (t) { return new Oo({ data: t, sourceFormat: I(t) ? Sx : vx, fromDataset: !1 }) }, er(Oo); var Dx = Un(), Tx = "\x00_ec_inner", Ax = Ha.extend({ init: function (t, e, i, n) { i = i || {}, this.option = null, this._theme = new Ha(i), this._optionManager = n }, setOption: function (t, e) { O(!(Tx in t), "please use chart.getOption()"), this._optionManager.setOption(t, e), this.resetOption(null) }, resetOption: function (t) { var e = !1, i = this._optionManager; if (!t || "recreate" === t) { var n = i.mountOption("recreate" === t); this.option && "recreate" !== t ? (this.restoreData(), this.mergeOption(n)) : qo.call(this, n), e = !0 } if (("timeline" === t || "media" === t) && this.restoreData(), !t || "recreate" === t || "timeline" === t) { var r = i.getTimelineOption(this); r && (this.mergeOption(r), e = !0) } if (!t || "recreate" === t || "media" === t) { var a = i.getMediaOption(this, this._api); a.length && f(a, function (t) { this.mergeOption(t, e = !0) }, this) } return e }, mergeOption: function (t) { function e(e, n) { var r = Bn(t[e]), s = Vn(a.get(e), r); Gn(s), f(s, function (t) { var i = t.option; S(i) && (t.keyInfo.mainType = e, t.keyInfo.subType = Ko(e, i, t.exist)) }); var l = Zo(a, n); i[e] = [], a.set(e, []), f(s, function (t, n) { var r = t.exist, s = t.option; if (O(S(s) || r, "Empty component definition"), s) { var u = cx.getClass(e, t.keyInfo.subType, !0); if (r && r instanceof u) r.name = t.keyInfo.name, r.mergeOption(s, this), r.optionUpdated(s, !1); else { var h = o({ dependentModels: l, componentIndex: n }, t.keyInfo); r = new u(s, this, this, h), o(r, h), r.init(s, this, this, h), r.optionUpdated(null, !0) } } else r.mergeOption({}, this), r.optionUpdated({}, !1); a.get(e)[n] = r, i[e][n] = r.option }, this), "series" === e && $o(this, a.get("series")) } var i = this.option, a = this._componentsMap, s = []; Bo(this), f(t, function (t, e) { null != t && (cx.hasClass(e) ? e && s.push(e) : i[e] = null == i[e] ? n(t) : r(i[e], t, !0)) }), cx.topologicalTravel(s, cx.getAllClassMainTypes(), e, this), this._seriesIndicesMap = N(this._seriesIndices = this._seriesIndices || []) }, getOption: function () { var t = n(this.option); return f(t, function (e, i) { if (cx.hasClass(i)) { for (var e = Bn(e), n = e.length - 1; n >= 0; n--)Wn(e[n]) && e.splice(n, 1); t[i] = e } }), delete t[Tx], t }, getTheme: function () { return this._theme }, getComponent: function (t, e) { var i = this._componentsMap.get(t); return i ? i[e || 0] : void 0 }, queryComponents: function (t) { var e = t.mainType; if (!e) return []; var i = t.index, n = t.id, r = t.name, a = this._componentsMap.get(e); if (!a || !a.length) return []; var o; if (null != i) _(i) || (i = [i]), o = m(p(i, function (t) { return a[t] }), function (t) { return !!t }); else if (null != n) { var s = _(n); o = m(a, function (t) { return s && u(n, t.id) >= 0 || !s && t.id === n }) } else if (null != r) { var l = _(r); o = m(a, function (t) { return l && u(r, t.name) >= 0 || !l && t.name === r }) } else o = a.slice(); return Qo(o, t) }, findComponents: function (t) { function e(t) { var e = r + "Index", i = r + "Id", n = r + "Name"; return !t || null == t[e] && null == t[i] && null == t[n] ? null : { mainType: r, index: t[e], id: t[i], name: t[n] } } function i(e) { return t.filter ? m(e, t.filter) : e } var n = t.query, r = t.mainType, a = e(n), o = a ? this.queryComponents(a) : this._componentsMap.get(r); return i(Qo(o, t)) }, eachComponent: function (t, e, i) { var n = this._componentsMap; if ("function" == typeof t) i = e, e = t, n.each(function (t, n) { f(t, function (t, r) { e.call(i, n, t, r) }) }); else if (w(t)) f(n.get(t), e, i); else if (S(t)) { var r = this.findComponents(t); f(r, e, i) } }, getSeriesByName: function (t) { var e = this._componentsMap.get("series"); return m(e, function (e) { return e.name === t }) }, getSeriesByIndex: function (t) { return this._componentsMap.get("series")[t] }, getSeriesByType: function (t) { var e = this._componentsMap.get("series"); return m(e, function (e) { return e.subType === t }) }, getSeries: function () { return this._componentsMap.get("series").slice() }, getSeriesCount: function () { return this._componentsMap.get("series").length }, eachSeries: function (t, e) { f(this._seriesIndices, function (i) { var n = this._componentsMap.get("series")[i]; t.call(e, n, i) }, this) }, eachRawSeries: function (t, e) { f(this._componentsMap.get("series"), t, e) }, eachSeriesByType: function (t, e, i) { f(this._seriesIndices, function (n) { var r = this._componentsMap.get("series")[n]; r.subType === t && e.call(i, r, n) }, this) }, eachRawSeriesByType: function (t, e, i) { return f(this.getSeriesByType(t), e, i) }, isSeriesFiltered: function (t) { return null == this._seriesIndicesMap.get(t.componentIndex) }, getCurrentSeriesIndices: function () { return (this._seriesIndices || []).slice() }, filterSeries: function (t, e) { var i = m(this._componentsMap.get("series"), t, e); $o(this, i) }, restoreData: function (t) { var e = this._componentsMap; $o(this, e.get("series")); var i = []; e.each(function (t, e) { i.push(e) }), cx.topologicalTravel(i, cx.getAllClassMainTypes(), function (i) { f(e.get(i), function (e) { ("series" !== i || !jo(e, t)) && e.restoreData() }) }) } }); c(Ax, gx); var Cx = ["getDom", "getZr", "getWidth", "getHeight", "getDevicePixelRatio", "dispatchAction", "isDisposed", "on", "off", "getDataURL", "getConnectedDataURL", "getModel", "getOption", "getViewOfComponentModel", "getViewOfSeriesModel"], kx = {}; ts.prototype = { constructor: ts, create: function (t, e) { var i = []; f(kx, function (n) { var r = n.create(t, e); i = i.concat(r || []) }), this._coordinateSystems = i }, update: function (t, e) { f(this._coordinateSystems, function (i) { i.update && i.update(t, e) }) }, getCoordinateSystems: function () { return this._coordinateSystems.slice() } }, ts.register = function (t, e) { kx[t] = e }, ts.get = function (t) { return kx[t] }; var Px = f, Lx = n, Ox = p, zx = r, Ex = /^(min|max)?(.+)$/; es.prototype = { constructor: es, setOption: function (t, e) { t && f(Bn(t.series), function (t) { t && t.data && I(t.data) && E(t.data) }), t = Lx(t, !0); var i = this._optionBackup, n = is.call(this, t, e, !i); this._newBaseOption = n.baseOption, i ? (os(i.baseOption, n.baseOption), n.timelineOptions.length && (i.timelineOptions = n.timelineOptions), n.mediaList.length && (i.mediaList = n.mediaList), n.mediaDefault && (i.mediaDefault = n.mediaDefault)) : this._optionBackup = n }, mountOption: function (t) { var e = this._optionBackup; return this._timelineOptions = Ox(e.timelineOptions, Lx), this._mediaList = Ox(e.mediaList, Lx), this._mediaDefault = Lx(e.mediaDefault), this._currentMediaIndices = [], Lx(t ? e.baseOption : this._newBaseOption) }, getTimelineOption: function (t) { var e, i = this._timelineOptions; if (i.length) { var n = t.getComponent("timeline"); n && (e = Lx(i[n.getCurrentIndex()], !0)) } return e }, getMediaOption: function () { var t = this._api.getWidth(), e = this._api.getHeight(), i = this._mediaList, n = this._mediaDefault, r = [], a = []; if (!i.length && !n) return a; for (var o = 0, s = i.length; s > o; o++)ns(i[o].query, t, e) && r.push(o); return !r.length && n && (r = [-1]), r.length && !as(r, this._currentMediaIndices) && (a = Ox(r, function (t) { return Lx(-1 === t ? n.option : i[t].option) })), this._currentMediaIndices = r, a } }; var Bx = f, Rx = S, Nx = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"], Fx = function (t, e) { Bx(fs(t.series), function (t) { Rx(t) && ds(t) }); var i = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"]; e && i.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), Bx(i, function (e) { Bx(fs(t[e]), function (t) { t && (hs(t, "axisLabel"), hs(t.axisPointer, "label")) }) }), Bx(fs(t.parallel), function (t) { var e = t && t.parallelAxisDefault; hs(e, "axisLabel"), hs(e && e.axisPointer, "label") }), Bx(fs(t.calendar), function (t) { ls(t, "itemStyle"), hs(t, "dayLabel"), hs(t, "monthLabel"), hs(t, "yearLabel") }), Bx(fs(t.radar), function (t) { hs(t, "name") }), Bx(fs(t.geo), function (t) { Rx(t) && (cs(t), Bx(fs(t.regions), function (t) { cs(t) })) }), Bx(fs(t.timeline), function (t) { cs(t), ls(t, "label"), ls(t, "itemStyle"), ls(t, "controlStyle", !0); var e = t.data; _(e) && f(e, function (t) { S(t) && (ls(t, "label"), ls(t, "itemStyle")) }) }), Bx(fs(t.toolbox), function (t) { ls(t, "iconStyle"), Bx(t.feature, function (t) { ls(t, "iconStyle") }) }), hs(ps(t.axisPointer), "label"), hs(ps(t.tooltip).axisPointer, "label") }, Vx = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]], Gx = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], Hx = function (t, e) { Fx(t, e), t.series = Bn(t.series), f(t.series, function (t) { if (S(t)) { var e = t.type; if (("pie" === e || "gauge" === e) && null != t.clockWise && (t.clockwise = t.clockWise), "gauge" === e) { var i = gs(t, "pointer.color"); null != i && ms(t, "itemStyle.normal.color", i) } vs(t) } }), t.dataRange && (t.visualMap = t.dataRange), f(Gx, function (e) { var i = t[e]; i && (_(i) || (i = [i]), f(i, function (t) { vs(t) })) }) }, Wx = function (t) { var e = N(); t.eachSeries(function (t) { var i = t.get("stack"); if (i) { var n = e.get(i) || e.set(i, []), r = t.getData(), a = { stackResultDimension: r.getCalculationInfo("stackResultDimension"), stackedOverDimension: r.getCalculationInfo("stackedOverDimension"), stackedDimension: r.getCalculationInfo("stackedDimension"), stackedByDimension: r.getCalculationInfo("stackedByDimension"), isStackedByIndex: r.getCalculationInfo("isStackedByIndex"), data: r, seriesModel: t }; if (!a.stackedDimension || !a.isStackedByIndex && !a.stackedByDimension) return; n.length && r.setCalculationInfo("stackedOnSeries", n[n.length - 1].seriesModel), n.push(a) } }), e.each(ys) }, Xx = xs.prototype; Xx.pure = !1, Xx.persistent = !0, Xx.getSource = function () { return this._source }; var Ux = { arrayRows_column: { pure: !0, count: function () { return Math.max(0, this._data.length - this._source.startIndex) }, getItem: function (t) { return this._data[t + this._source.startIndex] }, appendData: ws }, arrayRows_row: { pure: !0, count: function () { var t = this._data[0]; return t ? Math.max(0, t.length - this._source.startIndex) : 0 }, getItem: function (t) { t += this._source.startIndex; for (var e = [], i = this._data, n = 0; n < i.length; n++) { var r = i[n]; e.push(r ? r[t] : null) } return e }, appendData: function () { throw new Error('Do not support appendData when set seriesLayoutBy: "row".') } }, objectRows: { pure: !0, count: _s, getItem: bs, appendData: ws }, keyedColumns: { pure: !0, count: function () { var t = this._source.dimensionsDefine[0].name, e = this._data[t]; return e ? e.length : 0 }, getItem: function (t) { for (var e = [], i = this._source.dimensionsDefine, n = 0; n < i.length; n++) { var r = this._data[i[n].name]; e.push(r ? r[t] : null) } return e }, appendData: function (t) { var e = this._data; f(t, function (t, i) { for (var n = e[i] || (e[i] = []), r = 0; r < (t || []).length; r++)n.push(t[r]) }) } }, original: { count: _s, getItem: bs, appendData: ws }, typedArray: { persistent: !1, pure: !0, count: function () { return this._data ? this._data.length / this._dimSize : 0 }, getItem: function (t, e) { t -= this._offset, e = e || []; for (var i = this._dimSize * t, n = 0; n < this._dimSize; n++)e[n] = this._data[i + n]; return e }, appendData: function (t) { this._data = t }, clean: function () { this._offset += this.count(), this._data = null } } }, jx = { arrayRows: Ss, objectRows: function (t, e, i, n) { return null != i ? t[n] : t }, keyedColumns: Ss, original: function (t, e, i) { var n = Nn(t); return null != i && n instanceof Array ? n[i] : n }, typedArray: Ss }, Yx = { arrayRows: Ms, objectRows: function (t, e) { return Is(t[e], this._dimensionInfos[e]) }, keyedColumns: Ms, original: function (t, e, i, n) { var r = t && (null == t.value ? t : t.value); return !this._rawData.pure && Fn(t) && (this.hasItemOption = !0), Is(r instanceof Array ? r[n] : r, this._dimensionInfos[e]) }, typedArray: function (t, e, i, n) { return t[n] } }, qx = /\{@(.+?)\}/g, Zx = { getDataParams: function (t, e) { var i = this.getData(e), n = this.getRawValue(t, e), r = i.getRawIndex(t), a = i.getName(t), o = i.getRawDataItem(t), s = i.getItemVisual(t, "color"), l = this.ecModel.getComponent("tooltip"), u = l && l.get("renderMode"), h = Kn(u), c = this.mainType, d = "series" === c; return { componentType: c, componentSubType: this.subType, componentIndex: this.componentIndex, seriesType: d ? this.subType : null, seriesIndex: this.seriesIndex, seriesId: d ? this.id : null, seriesName: d ? this.name : null, name: a, dataIndex: r, data: o, dataType: e, value: n, color: s, marker: yo({ color: s, renderMode: h }), $vars: ["seriesName", "name", "value"] } }, getFormattedLabel: function (t, e, i, n, r) { e = e || "normal"; var a = this.getData(i), o = a.getItemModel(t), s = this.getDataParams(t, i); null != n && s.value instanceof Array && (s.value = s.value[n]); var l = o.get("normal" === e ? [r || "label", "formatter"] : [e, r || "label", "formatter"]); if ("function" == typeof l) return s.status = e, l(s); if ("string" == typeof l) { var u = mo(l, s); return u.replace(qx, function (e, i) { var n = i.length; return "[" === i.charAt(0) && "]" === i.charAt(n - 1) && (i = +i.slice(1, n - 1)), Ds(a, t, i) }) } }, getRawValue: function (t, e) { return Ds(this.getData(e), t) }, formatTooltip: function () { } }, Kx = Cs.prototype; Kx.perform = function (t) { function e(t) { return !(t >= 1) && (t = 1), t } var i = this._upstream, n = t && t.skip; if (this._dirty && i) { var r = this.context; r.data = r.outputData = i.context.outputData } this.__pipeline && (this.__pipeline.currentTask = this); var a; this._plan && !n && (a = this._plan(this.context)); var o = e(this._modBy), s = this._modDataCount || 0, l = e(t && t.modBy), u = t && t.modDataCount || 0; (o !== l || s !== u) && (a = "reset"); var h; (this._dirty || "reset" === a) && (this._dirty = !1, h = Ps(this, n)), this._modBy = l, this._modDataCount = u; var c = t && t.step; if (this._dueEnd = i ? i._outputDueEnd : this._count ? this._count(this.context) : 1 / 0, this._progress) { var d = this._dueIndex, f = Math.min(null != c ? this._dueIndex + c : 1 / 0, this._dueEnd); if (!n && (h || f > d)) { var p = this._progress; if (_(p)) for (var g = 0; g < p.length; g++)ks(this, p[g], d, f, l, u); else ks(this, p, d, f, l, u) } this._dueIndex = f; var m = null != this._settedOutputEnd ? this._settedOutputEnd : f; this._outputDueEnd = m } else this._dueIndex = this._outputDueEnd = null != this._settedOutputEnd ? this._settedOutputEnd : this._dueEnd; return this.unfinished() }; var $x = function () { function t() { return i > n ? n++ : null } function e() { var t = n % o * r + Math.ceil(n / o), e = n >= i ? null : a > t ? t : n; return n++ , e } var i, n, r, a, o, s = { reset: function (l, u, h, c) { n = l, i = u, r = h, a = c, o = Math.ceil(a / r), s.next = r > 1 && a > 0 ? e : t } }; return s }(); Kx.dirty = function () { this._dirty = !0, this._onDirty && this._onDirty(this.context) }, Kx.unfinished = function () { return this._progress && this._dueIndex < this._dueEnd }, Kx.pipe = function (t) { (this._downstream !== t || this._dirty) && (this._downstream = t, t._upstream = this, t.dirty()) }, Kx.dispose = function () { this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0) }, Kx.getUpstream = function () { return this._upstream }, Kx.getDownstream = function () { return this._downstream }, Kx.setOutputEnd = function (t) { this._outputDueEnd = this._settedOutputEnd = t }; var Qx = Un(), Jx = cx.extend({ type: "series.__base__", seriesIndex: 0, coordinateSystem: null, defaultOption: null, legendDataProvider: null, visualColorAccessPath: "itemStyle.color", layoutMode: null, init: function (t, e, i) { this.seriesIndex = this.componentIndex, this.dataTask = As({ count: zs, reset: Es }), this.dataTask.context = { model: this }, this.mergeDefaultAndTheme(t, i), Ro(this); var n = this.getInitialData(t, i); Rs(n, this), this.dataTask.context.data = n, Qx(this).dataBeforeProcessed = n, Ls(this) }, mergeDefaultAndTheme: function (t, e) { var i = this.layoutMode, n = i ? To(t) : {}, a = this.subType; cx.hasClass(a) && (a += "Series"), r(t, e.getTheme().get(this.subType)), r(t, this.getDefaultOption()), Rn(t, "label", ["show"]), this.fillDataTextStyle(t.data), i && Do(t, n, i) }, mergeOption: function (t, e) { t = r(this.option, t, !0), this.fillDataTextStyle(t.data); var i = this.layoutMode; i && Do(this.option, t, i), Ro(this); var n = this.getInitialData(t, e); Rs(n, this), this.dataTask.dirty(), this.dataTask.context.data = n, Qx(this).dataBeforeProcessed = n, Ls(this) }, fillDataTextStyle: function (t) { if (t && !I(t)) for (var e = ["show"], i = 0; i < t.length; i++)t[i] && t[i].label && Rn(t[i], "label", e) }, getInitialData: function () { }, appendData: function (t) { var e = this.getRawData(); e.appendData(t.data) }, getData: function (t) { var e = Fs(this); if (e) { var i = e.context.data; return null == t ? i : i.getLinkedData(t) } return Qx(this).data }, setData: function (t) { var e = Fs(this); if (e) { var i = e.context; i.data !== t && e.modifyOutputEnd && e.setOutputEnd(t.count()), i.outputData = t, e !== this.dataTask && (i.data = t) } Qx(this).data = t }, getSource: function () { return Eo(this) }, getRawData: function () { return Qx(this).dataBeforeProcessed }, getBaseAxis: function () { var t = this.coordinateSystem; return t && t.getBaseAxis && t.getBaseAxis() }, formatTooltip: function (t, e, i, n) { function r(i) { function r(t, i) { var r = c.getDimensionInfo(i); if (r && r.otherDims.tooltip !== !1) { var d = r.type, f = "sub" + o.seriesIndex + "at" + h, p = yo({ color: y, type: "subItem", renderMode: n, markerId: f }), g = "string" == typeof p ? p : p.content, m = (a ? g + go(r.displayName || "-") + ": " : "") + go("ordinal" === d ? t + "" : "time" === d ? e ? "" : _o("yyyy/MM/dd hh:mm:ss", t) : fo(t)); m && s.push(m), l && (u[f] = y, ++h) } } var a = g(i, function (t, e, i) { var n = c.getDimensionInfo(i); return t |= n && n.tooltip !== !1 && null != n.displayName }, 0), s = []; d.length ? f(d, function (e) { r(Ds(c, t, e), e) }) : f(i, r); var p = a ? l ? "\n" : "<br/>" : "", m = p + s.join(p || ", "); return { renderMode: n, content: m, style: u } } function a(t) { return { renderMode: n, content: go(fo(t)), style: u } } var o = this; n = n || "html"; var s = "html" === n ? "<br/>" : "\n", l = "richText" === n, u = {}, h = 0, c = this.getData(), d = c.mapDimension("defaultedTooltip", !0), p = d.length, m = this.getRawValue(t), v = _(m), y = c.getItemVisual(t, "color"); S(y) && y.colorStops && (y = (y.colorStops[0] || {}).color), y = y || "transparent"; var x = p > 1 || v && !p ? r(m) : a(p ? Ds(c, t, d[0]) : v ? m[0] : m), b = x.content, w = o.seriesIndex + "at" + h, M = yo({ color: y, type: "item", renderMode: n, markerId: w }); u[w] = y, ++h; var I = c.getName(t), D = this.name; Hn(this) || (D = ""), D = D ? go(D) + (e ? ": " : s) : ""; var T = "string" == typeof M ? M : M.content, A = e ? T + D + b : D + T + (I ? go(I) + ": " + b : b); return { html: A, markers: u } }, isAnimationEnabled: function () { if (Gp.node) return !1; var t = this.getShallow("animation"); return t && this.getData().count() > this.getShallow("animationThreshold") && (t = !1), t }, restoreData: function () { this.dataTask.dirty() }, getColorFromPalette: function (t, e, i) { var n = this.ecModel, r = gx.getColorFromPalette.call(this, t, e, i); return r || (r = n.getColorFromPalette(t, e, i)), r }, coordDimToDataDim: function (t) { return this.getRawData().mapDimension(t, !0) }, getProgressive: function () { return this.get("progressive") }, getProgressiveThreshold: function () { return this.get("progressiveThreshold") }, getAxisTooltipData: null, getTooltipPosition: null, pipeTask: null, preventIncremental: null, pipelineContext: null }); c(Jx, Zx), c(Jx, gx); var t_ = function () { this.group = new $g, this.uid = Ua("viewComponent") }; t_.prototype = { constructor: t_, init: function () { }, render: function () { }, dispose: function () { }, filterForExposedEvent: null }; var e_ = t_.prototype; e_.updateView = e_.updateLayout = e_.updateVisual = function () { }, tr(t_), rr(t_, { registerWhenExtend: !0 }); var i_ = function () { var t = Un(); return function (e) { var i = t(e), n = e.pipelineContext, r = i.large, a = i.progressiveRender, o = i.large = n.large, s = i.progressiveRender = n.progressiveRender; return !!(r ^ o || a ^ s) && "reset" } }, n_ = Un(), r_ = i_(); Vs.prototype = { type: "chart", init: function () { }, render: function () { }, highlight: function (t, e, i, n) { Hs(t.getData(), n, "emphasis") }, downplay: function (t, e, i, n) { Hs(t.getData(), n, "normal") }, remove: function () { this.group.removeAll() }, dispose: function () { }, incrementalPrepareRender: null, incrementalRender: null, updateTransform: null, filterForExposedEvent: null }; var a_ = Vs.prototype; a_.updateView = a_.updateLayout = a_.updateVisual = function (t, e, i, n) { this.render(t, e, i, n) }, tr(Vs, ["dispose"]), rr(Vs, { registerWhenExtend: !0 }), Vs.markUpdateMethod = function (t, e) { n_(t).updateMethod = e }; var o_ = { incrementalPrepareRender: { progress: function (t, e) { e.view.incrementalRender(t, e.model, e.ecModel, e.api, e.payload) } }, render: { forceFirstProgress: !0, progress: function (t, e) { e.view.render(e.model, e.ecModel, e.api, e.payload) } } }, s_ = "\x00__throttleOriginMethod", l_ = "\x00__throttleRate", u_ = "\x00__throttleType", h_ = { createOnAllSeries: !0, performRawSeries: !0, reset: function (t, e) { var i = t.getData(), n = (t.visualColorAccessPath || "itemStyle.color").split("."), r = t.get(n) || t.getColorFromPalette(t.name, null, e.getSeriesCount()); if (i.setVisual("color", r), !e.isSeriesFiltered(t)) { "function" != typeof r || r instanceof Ay || i.each(function (e) { i.setItemVisual(e, "color", r(t.getDataParams(e))) }); var a = function (t, e) { var i = t.getItemModel(e), r = i.get(n, !0); null != r && t.setItemVisual(e, "color", r) }; return { dataEach: i.hasItemOption ? a : null } } } }, c_ = { toolbox: { brush: { title: { rect: "矩形选择", polygon: "圈选", lineX: "横向选择", lineY: "纵向选择", keep: "保持选择", clear: "清除选择" } }, dataView: { title: "数据视图", lang: ["数据视图", "关闭", "刷新"] }, dataZoom: { title: { zoom: "区域缩放", back: "区域缩放还原" } }, magicType: { title: { line: "切换为折线图", bar: "切换为柱状图", stack: "切换为堆叠", tiled: "切换为平铺" } }, restore: { title: "还原" }, saveAsImage: { title: "保存为图片", lang: ["右键另存为图片"] } }, series: { typeNames: { pie: "饼图", bar: "柱状图", line: "折线图", scatter: "散点图", effectScatter: "涟漪散点图", radar: "雷达图", tree: "树图", treemap: "矩形树图", boxplot: "箱型图", candlestick: "K线图", k: "K线图", heatmap: "热力图", map: "地图", parallel: "平行坐标图", lines: "线图", graph: "关系图", sankey: "桑基图", funnel: "漏斗图", gauge: "仪表盘图", pictorialBar: "象形柱图", themeRiver: "主题河流图", sunburst: "旭日图" } }, aria: { general: { withTitle: "这是一个关于“{title}”的图表。", withoutTitle: "这是一个图表，" }, series: { single: { prefix: "", withName: "图表类型是{seriesType}，表示{seriesName}。", withoutName: "图表类型是{seriesType}。" }, multiple: { prefix: "它由{seriesCount}个图表系列组成。", withName: "第{seriesId}个系列是一个表示{seriesName}的{seriesType}，", withoutName: "第{seriesId}个系列是一个{seriesType}，", separator: { middle: "；", end: "。" } } }, data: { allData: "其数据是——", partialData: "其中，前{displayCnt}项是——", withName: "{name}的数据是{value}", withoutName: "{value}", separator: { middle: "，", end: "" } } } }, d_ = function (t, e) {
    function i(t, e) {
      if ("string" != typeof t) return t;
      var i = t; return f(e, function (t, e) { i = i.replace(new RegExp("\\{\\s*" + e + "\\s*\\}", "g"), t) }), i
    } function n(t) { var e = o.get(t); if (null == e) { for (var i = t.split("."), n = c_.aria, r = 0; r < i.length; ++r)n = n[i[r]]; return n } return e } function r() { var t = e.getModel("title").option; return t && t.length && (t = t[0]), t && t.text } function a(t) { return c_.series.typeNames[t] || "自定义图" } var o = e.getModel("aria"); if (o.get("show")) { if (o.get("description")) return void t.setAttribute("aria-label", o.get("description")); var s = 0; e.eachSeries(function () { ++s }, this); var l, u = o.get("data.maxCount") || 10, h = o.get("series.maxCount") || 10, c = Math.min(s, h); if (!(1 > s)) { var d = r(); l = d ? i(n("general.withTitle"), { title: d }) : n("general.withoutTitle"); var p = [], g = s > 1 ? "series.multiple.prefix" : "series.single.prefix"; l += i(n(g), { seriesCount: s }), e.eachSeries(function (t, e) { if (c > e) { var r, o = t.get("name"), l = "series." + (s > 1 ? "multiple" : "single") + "."; r = n(o ? l + "withName" : l + "withoutName"), r = i(r, { seriesId: t.seriesIndex, seriesName: t.get("name"), seriesType: a(t.subType) }); var h = t.getData(); window.data = h, r += h.count() > u ? i(n("data.partialData"), { displayCnt: u }) : n("data.allData"); for (var d = [], f = 0; f < h.count(); f++)if (u > f) { var g = h.getName(f), m = Ds(h, f); d.push(i(n(g ? "data.withName" : "data.withoutName"), { name: g, value: m })) } r += d.join(n("data.separator.middle")) + n("data.separator.end"), p.push(r) } }), l += p.join(n("series.multiple.separator.middle")) + n("series.multiple.separator.end"), t.setAttribute("aria-label", l) } }
  }, f_ = Math.PI, p_ = function (t, e) { e = e || {}, s(e, { text: "loading", color: "#c23531", textColor: "#000", maskColor: "rgba(255, 255, 255, 0.8)", zlevel: 0 }); var i = new by({ style: { fill: e.maskColor }, zlevel: e.zlevel, z: 1e4 }), n = new Dy({ shape: { startAngle: -f_ / 2, endAngle: -f_ / 2 + .1, r: 10 }, style: { stroke: e.color, lineCap: "round", lineWidth: 5 }, zlevel: e.zlevel, z: 10001 }), r = new by({ style: { fill: "none", text: e.text, textPosition: "right", textDistance: 10, textFill: e.textColor }, zlevel: e.zlevel, z: 10001 }); n.animateShape(!0).when(1e3, { endAngle: 3 * f_ / 2 }).start("circularInOut"), n.animateShape(!0).when(1e3, { startAngle: 3 * f_ / 2 }).delay(300).start("circularInOut"); var a = new $g; return a.add(n), a.add(r), a.add(i), a.resize = function () { var e = t.getWidth() / 2, a = t.getHeight() / 2; n.setShape({ cx: e, cy: a }); var o = n.shape.r; r.setShape({ x: e - o, y: a - o, width: 2 * o, height: 2 * o }), i.setShape({ x: 0, y: 0, width: t.getWidth(), height: t.getHeight() }) }, a.resize(), a }, g_ = Ys.prototype; g_.restoreData = function (t, e) { t.restoreData(e), this._stageTaskMap.each(function (t) { var e = t.overallTask; e && e.dirty() }) }, g_.getPerformArgs = function (t, e) { if (t.__pipeline) { var i = this._pipelineMap.get(t.__pipeline.id), n = i.context, r = !e && i.progressiveEnabled && (!n || n.progressiveRender) && t.__idxInPipeline > i.blockIndex, a = r ? i.step : null, o = n && n.modDataCount, s = null != o ? Math.ceil(o / a) : null; return { step: a, modBy: s, modDataCount: o } } }, g_.getPipeline = function (t) { return this._pipelineMap.get(t) }, g_.updateStreamModes = function (t, e) { var i = this._pipelineMap.get(t.uid), n = t.getData(), r = n.count(), a = i.progressiveEnabled && e.incrementalPrepareRender && r >= i.threshold, o = t.get("large") && r >= t.get("largeThreshold"), s = "mod" === t.get("progressiveChunkMode") ? r : null; t.pipelineContext = i.context = { progressiveRender: a, modDataCount: s, large: o } }, g_.restorePipelines = function (t) { var e = this, i = e._pipelineMap = N(); t.eachSeries(function (t) { var n = t.getProgressive(), r = t.uid; i.set(r, { id: r, head: null, tail: null, threshold: t.getProgressiveThreshold(), progressiveEnabled: n && !(t.preventIncremental && t.preventIncremental()), blockIndex: -1, step: Math.round(n || 700), count: 0 }), al(e, t, t.dataTask) }) }, g_.prepareStageTasks = function () { var t = this._stageTaskMap, e = this.ecInstance.getModel(), i = this.api; f(this._allHandlers, function (n) { var r = t.get(n.uid) || t.set(n.uid, []); n.reset && Zs(this, n, r, e, i), n.overallReset && Ks(this, n, r, e, i) }, this) }, g_.prepareView = function (t, e, i, n) { var r = t.renderTask, a = r.context; a.model = e, a.ecModel = i, a.api = n, r.__block = !t.incrementalPrepareRender, al(this, e, r) }, g_.performDataProcessorTasks = function (t, e) { qs(this, this._dataProcessorHandlers, t, e, { block: !0 }) }, g_.performVisualTasks = function (t, e, i) { qs(this, this._visualHandlers, t, e, i) }, g_.performSeriesTasks = function (t) { var e; t.eachSeries(function (t) { e |= t.dataTask.perform() }), this.unfinished |= e }, g_.plan = function () { this._pipelineMap.each(function (t) { var e = t.tail; do { if (e.__block) { t.blockIndex = e.__idxInPipeline; break } e = e.getUpstream() } while (e) }) }; var m_ = g_.updatePayload = function (t, e) { "remain" !== e && (t.context.payload = e) }, v_ = nl(0); Ys.wrapStageHandler = function (t, e) { return b(t) && (t = { overallReset: t, seriesType: ol(t) }), t.uid = Ua("stageHandler"), e && (t.visualType = e), t }; var y_, x_ = {}, __ = {}; sl(x_, Ax), sl(__, Jo), x_.eachSeriesByType = x_.eachRawSeriesByType = function (t) { y_ = t }, x_.eachComponent = function (t) { "series" === t.mainType && t.subType && (y_ = t.subType) }; var b_ = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"], w_ = { color: b_, colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], b_] }, S_ = "#eee", M_ = function () { return { axisLine: { lineStyle: { color: S_ } }, axisTick: { lineStyle: { color: S_ } }, axisLabel: { textStyle: { color: S_ } }, splitLine: { lineStyle: { type: "dashed", color: "#aaa" } }, splitArea: { areaStyle: { color: S_ } } } }, I_ = ["#dd6b66", "#759aa0", "#e69d87", "#8dc1a9", "#ea7e53", "#eedd78", "#73a373", "#73b9bc", "#7289ab", "#91ca8c", "#f49f42"], D_ = { color: I_, backgroundColor: "#333", tooltip: { axisPointer: { lineStyle: { color: S_ }, crossStyle: { color: S_ } } }, legend: { textStyle: { color: S_ } }, textStyle: { color: S_ }, title: { textStyle: { color: S_ } }, toolbox: { iconStyle: { normal: { borderColor: S_ } } }, dataZoom: { textStyle: { color: S_ } }, visualMap: { textStyle: { color: S_ } }, timeline: { lineStyle: { color: S_ }, itemStyle: { normal: { color: I_[1] } }, label: { normal: { textStyle: { color: S_ } } }, controlStyle: { normal: { color: S_, borderColor: S_ } } }, timeAxis: M_(), logAxis: M_(), valueAxis: M_(), categoryAxis: M_(), line: { symbol: "circle" }, graph: { color: I_ }, gauge: { title: { textStyle: { color: S_ } } }, candlestick: { itemStyle: { normal: { color: "#FD1050", color0: "#0CF49B", borderColor: "#FD1050", borderColor0: "#0CF49B" } } } }; D_.categoryAxis.splitLine.show = !1, cx.extend({ type: "dataset", defaultOption: { seriesLayoutBy: Mx, sourceHeader: null, dimensions: null, source: null }, optionUpdated: function () { zo(this) } }), t_.extend({ type: "dataset" }); var T_ = Nr.extend({ type: "ellipse", shape: { cx: 0, cy: 0, rx: 0, ry: 0 }, buildPath: function (t, e) { var i = .5522848, n = e.cx, r = e.cy, a = e.rx, o = e.ry, s = a * i, l = o * i; t.moveTo(n - a, r), t.bezierCurveTo(n - a, r - l, n - s, r - o, n, r - o), t.bezierCurveTo(n + s, r - o, n + a, r - l, n + a, r), t.bezierCurveTo(n + a, r + l, n + s, r + o, n, r + o), t.bezierCurveTo(n - s, r + o, n - a, r + l, n - a, r), t.closePath() } }), A_ = /[\s,]+/; ul.prototype.parse = function (t, e) { e = e || {}; var i = ll(t); if (!i) throw new Error("Illegal svg"); var n = new $g; this._root = n; var r = i.getAttribute("viewBox") || "", a = parseFloat(i.getAttribute("width") || e.width), o = parseFloat(i.getAttribute("height") || e.height); isNaN(a) && (a = null), isNaN(o) && (o = null), fl(i, n, null, !0); for (var s = i.firstChild; s;)this._parseNode(s, n), s = s.nextSibling; var l, u; if (r) { var h = z(r).split(A_); h.length >= 4 && (l = { x: parseFloat(h[0] || 0), y: parseFloat(h[1] || 0), width: parseFloat(h[2]), height: parseFloat(h[3]) }) } if (l && null != a && null != o && (u = vl(l, a, o), !e.ignoreViewBox)) { var c = n; n = new $g, n.add(c), c.scale = u.scale.slice(), c.position = u.position.slice() } return e.ignoreRootClip || null == a || null == o || n.setClipPath(new by({ shape: { x: 0, y: 0, width: a, height: o } })), { root: n, width: a, height: o, viewBoxRect: l, viewBoxTransform: u } }, ul.prototype._parseNode = function (t, e) { var i = t.nodeName.toLowerCase(); "defs" === i ? this._isDefine = !0 : "text" === i && (this._isText = !0); var n; if (this._isDefine) { var r = k_[i]; if (r) { var a = r.call(this, t), o = t.getAttribute("id"); o && (this._defs[o] = a) } } else { var r = C_[i]; r && (n = r.call(this, t, e), e.add(n)) } for (var s = t.firstChild; s;)1 === s.nodeType && this._parseNode(s, n), 3 === s.nodeType && this._isText && this._parseText(s, n), s = s.nextSibling; "defs" === i ? this._isDefine = !1 : "text" === i && (this._isText = !1) }, ul.prototype._parseText = function (t, e) { if (1 === t.nodeType) { var i = t.getAttribute("dx") || 0, n = t.getAttribute("dy") || 0; this._textX += parseFloat(i), this._textY += parseFloat(n) } var r = new uy({ style: { text: t.textContent, transformText: !0 }, position: [this._textX || 0, this._textY || 0] }); cl(e, r), fl(t, r, this._defs); var a = r.style.fontSize; a && 9 > a && (r.style.fontSize = 9, r.scale = r.scale || [1, 1], r.scale[0] *= a / 9, r.scale[1] *= a / 9); var o = r.getBoundingRect(); return this._textX += o.width, e.add(r), r }; var C_ = { g: function (t, e) { var i = new $g; return cl(e, i), fl(t, i, this._defs), i }, rect: function (t, e) { var i = new by; return cl(e, i), fl(t, i, this._defs), i.setShape({ x: parseFloat(t.getAttribute("x") || 0), y: parseFloat(t.getAttribute("y") || 0), width: parseFloat(t.getAttribute("width") || 0), height: parseFloat(t.getAttribute("height") || 0) }), i }, circle: function (t, e) { var i = new hy; return cl(e, i), fl(t, i, this._defs), i.setShape({ cx: parseFloat(t.getAttribute("cx") || 0), cy: parseFloat(t.getAttribute("cy") || 0), r: parseFloat(t.getAttribute("r") || 0) }), i }, line: function (t, e) { var i = new Sy; return cl(e, i), fl(t, i, this._defs), i.setShape({ x1: parseFloat(t.getAttribute("x1") || 0), y1: parseFloat(t.getAttribute("y1") || 0), x2: parseFloat(t.getAttribute("x2") || 0), y2: parseFloat(t.getAttribute("y2") || 0) }), i }, ellipse: function (t, e) { var i = new T_; return cl(e, i), fl(t, i, this._defs), i.setShape({ cx: parseFloat(t.getAttribute("cx") || 0), cy: parseFloat(t.getAttribute("cy") || 0), rx: parseFloat(t.getAttribute("rx") || 0), ry: parseFloat(t.getAttribute("ry") || 0) }), i }, polygon: function (t, e) { var i = t.getAttribute("points"); i && (i = dl(i)); var n = new vy({ shape: { points: i || [] } }); return cl(e, n), fl(t, n, this._defs), n }, polyline: function (t, e) { var i = new Nr; cl(e, i), fl(t, i, this._defs); var n = t.getAttribute("points"); n && (n = dl(n)); var r = new yy({ shape: { points: n || [] } }); return r }, image: function (t, e) { var i = new xn; return cl(e, i), fl(t, i, this._defs), i.setStyle({ image: t.getAttribute("xlink:href"), x: t.getAttribute("x"), y: t.getAttribute("y"), width: t.getAttribute("width"), height: t.getAttribute("height") }), i }, text: function (t, e) { var i = t.getAttribute("x") || 0, n = t.getAttribute("y") || 0, r = t.getAttribute("dx") || 0, a = t.getAttribute("dy") || 0; this._textX = parseFloat(i) + parseFloat(r), this._textY = parseFloat(n) + parseFloat(a); var o = new $g; return cl(e, o), fl(t, o, this._defs), o }, tspan: function (t, e) { var i = t.getAttribute("x"), n = t.getAttribute("y"); null != i && (this._textX = parseFloat(i)), null != n && (this._textY = parseFloat(n)); var r = t.getAttribute("dx") || 0, a = t.getAttribute("dy") || 0, o = new $g; return cl(e, o), fl(t, o, this._defs), this._textX += r, this._textY += a, o }, path: function (t, e) { var i = t.getAttribute("d") || "", n = Hr(i); return cl(e, n), fl(t, n, this._defs), n } }, k_ = { lineargradient: function (t) { var e = parseInt(t.getAttribute("x1") || 0, 10), i = parseInt(t.getAttribute("y1") || 0, 10), n = parseInt(t.getAttribute("x2") || 10, 10), r = parseInt(t.getAttribute("y2") || 0, 10), a = new Cy(e, i, n, r); return hl(t, a), a }, radialgradient: function () { } }, P_ = { fill: "fill", stroke: "stroke", "stroke-width": "lineWidth", opacity: "opacity", "fill-opacity": "fillOpacity", "stroke-opacity": "strokeOpacity", "stroke-dasharray": "lineDash", "stroke-dashoffset": "lineDashOffset", "stroke-linecap": "lineCap", "stroke-linejoin": "lineJoin", "stroke-miterlimit": "miterLimit", "font-family": "fontFamily", "font-size": "fontSize", "font-style": "fontStyle", "font-weight": "fontWeight", "text-align": "textAlign", "alignment-baseline": "textBaseline" }, L_ = /url\(\s*#(.*?)\)/, O_ = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.e,]*)\)/g, z_ = /([^\s:;]+)\s*:\s*([^:;]+)/g, E_ = N(), B_ = { registerMap: function (t, e, i) { var n; return _(e) ? n = e : e.svg ? n = [{ type: "svg", source: e.svg, specialAreas: e.specialAreas }] : (e.geoJson && !e.features && (i = e.specialAreas, e = e.geoJson), n = [{ type: "geoJSON", source: e, specialAreas: i }]), f(n, function (t) { var e = t.type; "geoJson" === e && (e = t.type = "geoJSON"); var i = R_[e]; i(t) }), E_.set(t, n) }, retrieveMap: function (t) { return E_.get(t) } }, R_ = { geoJSON: function (t) { var e = t.source; t.geoJSON = w(e) ? "undefined" != typeof JSON && JSON.parse ? JSON.parse(e) : new Function("return (" + e + ");")() : e }, svg: function (t) { t.svgXML = ll(t.source) } }, N_ = O, F_ = f, V_ = b, G_ = S, H_ = cx.parseClassType, W_ = "4.2.1", X_ = { zrender: "4.0.6" }, U_ = 1, j_ = 1e3, Y_ = 5e3, q_ = 1e3, Z_ = 2e3, K_ = 3e3, $_ = 4e3, Q_ = 5e3, J_ = { PROCESSOR: { FILTER: j_, STATISTIC: Y_ }, VISUAL: { LAYOUT: q_, GLOBAL: Z_, CHART: K_, COMPONENT: $_, BRUSH: Q_ } }, tb = "__flagInMainProcess", eb = "__optionUpdated", ib = /^[a-zA-Z0-9_]+$/; xl.prototype.on = yl("on"), xl.prototype.off = yl("off"), xl.prototype.one = yl("one"), c(xl, ug); var nb = _l.prototype; nb._onframe = function () { if (!this._disposed) { var t = this._scheduler; if (this[eb]) { var e = this[eb].silent; this[tb] = !0, wl(this), rb.update.call(this), this[tb] = !1, this[eb] = !1, Dl.call(this, e), Tl.call(this, e) } else if (t.unfinished) { var i = U_, n = this._model, r = this._api; t.unfinished = !1; do { var a = +new Date; t.performSeriesTasks(n), t.performDataProcessorTasks(n), Ml(this, n), t.performVisualTasks(n), Ol(this, this._model, r, "remain"), i -= +new Date - a } while (i > 0 && t.unfinished); t.unfinished || this._zr.flush() } } }, nb.getDom = function () { return this._dom }, nb.getZr = function () { return this._zr }, nb.setOption = function (t, e, i) { var n; if (G_(e) && (i = e.lazyUpdate, n = e.silent, e = e.notMerge), this[tb] = !0, !this._model || e) { var r = new es(this._api), a = this._theme, o = this._model = new Ax(null, null, a, r); o.scheduler = this._scheduler, o.init(null, null, a, r) } this._model.setOption(t, ub), i ? (this[eb] = { silent: n }, this[tb] = !1) : (wl(this), rb.update.call(this), this._zr.flush(), this[eb] = !1, this[tb] = !1, Dl.call(this, n), Tl.call(this, n)) }, nb.setTheme = function () { console.error("ECharts#setTheme() is DEPRECATED in ECharts 3.0") }, nb.getModel = function () { return this._model }, nb.getOption = function () { return this._model && this._model.getOption() }, nb.getWidth = function () { return this._zr.getWidth() }, nb.getHeight = function () { return this._zr.getHeight() }, nb.getDevicePixelRatio = function () { return this._zr.painter.dpr || window.devicePixelRatio || 1 }, nb.getRenderedCanvas = function (t) { if (Gp.canvasSupported) { t = t || {}, t.pixelRatio = t.pixelRatio || 1, t.backgroundColor = t.backgroundColor || this._model.get("backgroundColor"); var e = this._zr; return e.painter.getRenderedCanvas(t) } }, nb.getSvgDataUrl = function () { if (Gp.svgSupported) { var t = this._zr, e = t.storage.getDisplayList(); return f(e, function (t) { t.stopAnimation(!0) }), t.painter.pathToDataUrl() } }, nb.getDataURL = function (t) { t = t || {}; var e = t.excludeComponents, i = this._model, n = [], r = this; F_(e, function (t) { i.eachComponent({ mainType: t }, function (t) { var e = r._componentsMap[t.__viewId]; e.group.ignore || (n.push(e), e.group.ignore = !0) }) }); var a = "svg" === this._zr.painter.getType() ? this.getSvgDataUrl() : this.getRenderedCanvas(t).toDataURL("image/" + (t && t.type || "png")); return F_(n, function (t) { t.group.ignore = !1 }), a }, nb.getConnectedDataURL = function (t) { if (Gp.canvasSupported) { var e = this.group, i = Math.min, r = Math.max, a = 1 / 0; if (gb[e]) { var o = a, s = a, l = -a, u = -a, h = [], c = t && t.pixelRatio || 1; f(pb, function (a) { if (a.group === e) { var c = a.getRenderedCanvas(n(t)), d = a.getDom().getBoundingClientRect(); o = i(d.left, o), s = i(d.top, s), l = r(d.right, l), u = r(d.bottom, u), h.push({ dom: c, left: d.left, top: d.top }) } }), o *= c, s *= c, l *= c, u *= c; var d = l - o, p = u - s, g = Qp(); g.width = d, g.height = p; var m = Pn(g); return F_(h, function (t) { var e = new xn({ style: { x: t.left * c - o, y: t.top * c - s, image: t.dom } }); m.add(e) }), m.refreshImmediately(), g.toDataURL("image/" + (t && t.type || "png")) } return this.getDataURL(t) } }, nb.convertToPixel = x(bl, "convertToPixel"), nb.convertFromPixel = x(bl, "convertFromPixel"), nb.containPixel = function (t, e) { var i, n = this._model; return t = jn(n, t), f(t, function (t, n) { n.indexOf("Models") >= 0 && f(t, function (t) { var r = t.coordinateSystem; if (r && r.containPoint) i |= !!r.containPoint(e); else if ("seriesModels" === n) { var a = this._chartsMap[t.__viewId]; a && a.containPoint && (i |= a.containPoint(e, t)) } }, this) }, this), !!i }, nb.getVisual = function (t, e) { var i = this._model; t = jn(i, t, { defaultMainType: "series" }); var n = t.seriesModel, r = n.getData(), a = t.hasOwnProperty("dataIndexInside") ? t.dataIndexInside : t.hasOwnProperty("dataIndex") ? r.indexOfRawIndex(t.dataIndex) : null; return null != a ? r.getItemVisual(a, e) : r.getVisual(e) }, nb.getViewOfComponentModel = function (t) { return this._componentsMap[t.__viewId] }, nb.getViewOfSeriesModel = function (t) { return this._chartsMap[t.__viewId] }; var rb = { prepareAndUpdate: function (t) { wl(this), rb.update.call(this, t) }, update: function (t) { var e = this._model, i = this._api, n = this._zr, r = this._coordSysMgr, a = this._scheduler; if (e) { a.restoreData(e, t), a.performSeriesTasks(e), r.create(e, i), a.performDataProcessorTasks(e, t), Ml(this, e), r.update(e, i), kl(e), a.performVisualTasks(e, t), Pl(this, e, i, t); var o = e.get("backgroundColor") || "transparent"; if (Gp.canvasSupported) n.setBackgroundColor(o); else { var s = Ue(o); o = ti(s, "rgb"), 0 === s[3] && (o = "transparent") } zl(e, i) } }, updateTransform: function (t) { var e = this._model, i = this, n = this._api; if (e) { var r = []; e.eachComponent(function (a, o) { var s = i.getViewOfComponentModel(o); if (s && s.__alive) if (s.updateTransform) { var l = s.updateTransform(o, e, n, t); l && l.update && r.push(s) } else r.push(s) }); var a = N(); e.eachSeries(function (r) { var o = i._chartsMap[r.__viewId]; if (o.updateTransform) { var s = o.updateTransform(r, e, n, t); s && s.update && a.set(r.uid, 1) } else a.set(r.uid, 1) }), kl(e), this._scheduler.performVisualTasks(e, t, { setDirty: !0, dirtyMap: a }), Ol(i, e, n, t, a), zl(e, this._api) } }, updateView: function (t) { var e = this._model; e && (Vs.markUpdateMethod(t, "updateView"), kl(e), this._scheduler.performVisualTasks(e, t, { setDirty: !0 }), Pl(this, this._model, this._api, t), zl(e, this._api)) }, updateVisual: function (t) { rb.update.call(this, t) }, updateLayout: function (t) { rb.update.call(this, t) } }; nb.resize = function (t) { this._zr.resize(t); var e = this._model; if (this._loadingFX && this._loadingFX.resize(), e) { var i = e.resetOption("media"), n = t && t.silent; this[tb] = !0, i && wl(this), rb.update.call(this), this[tb] = !1, Dl.call(this, n), Tl.call(this, n) } }, nb.showLoading = function (t, e) { if (G_(t) && (e = t, t = ""), t = t || "default", this.hideLoading(), fb[t]) { var i = fb[t](this._api, e), n = this._zr; this._loadingFX = i, n.add(i) } }, nb.hideLoading = function () { this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null }, nb.makeActionFromEvent = function (t) { var e = o({}, t); return e.type = sb[t.type], e }, nb.dispatchAction = function (t, e) { if (G_(e) || (e = { silent: !!e }), ob[t.type] && this._model) { if (this[tb]) return void this._pendingActions.push(t); Il.call(this, t, e.silent), e.flush ? this._zr.flush(!0) : e.flush !== !1 && Gp.browser.weChat && this._throttledZrFlush(), Dl.call(this, e.silent), Tl.call(this, e.silent) } }, nb.appendData = function (t) { var e = t.seriesIndex, i = this.getModel(), n = i.getSeriesByIndex(e); n.appendData(t), this._scheduler.unfinished = !0 }, nb.on = yl("on"), nb.off = yl("off"), nb.one = yl("one"); var ab = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"]; nb._initEvents = function () { F_(ab, function (t) { var e = function (e) { var i, n = this.getModel(), r = e.target, a = "globalout" === t; if (a) i = {}; else if (r && null != r.dataIndex) { var s = r.dataModel || n.getSeriesByIndex(r.seriesIndex); i = s && s.getDataParams(r.dataIndex, r.dataType, r) || {} } else r && r.eventData && (i = o({}, r.eventData)); if (i) { var l = i.componentType, u = i.componentIndex; ("markLine" === l || "markPoint" === l || "markArea" === l) && (l = "series", u = i.seriesIndex); var h = l && null != u && n.getComponent(l, u), c = h && this["series" === h.mainType ? "_chartsMap" : "_componentsMap"][h.__viewId]; i.event = e, i.type = t, this._ecEventProcessor.eventInfo = { targetEl: r, packedEvent: i, model: h, view: c }, this.trigger(t, i) } }; e.zrEventfulCallAtLast = !0, this._zr.on(t, e, this) }, this), F_(sb, function (t, e) { this._messageCenter.on(e, function (t) { this.trigger(e, t) }, this) }, this) }, nb.isDisposed = function () { return this._disposed }, nb.clear = function () { this.setOption({ series: [] }, !0) }, nb.dispose = function () { if (!this._disposed) { this._disposed = !0, qn(this.getDom(), yb, ""); var t = this._api, e = this._model; F_(this._componentsViews, function (i) { i.dispose(e, t) }), F_(this._chartsViews, function (i) { i.dispose(e, t) }), this._zr.dispose(), delete pb[this.id] } }, c(_l, ug), Fl.prototype = { constructor: Fl, normalizeQuery: function (t) { var e = {}, i = {}, n = {}; if (w(t)) { var r = H_(t); e.mainType = r.main || null, e.subType = r.sub || null } else { var a = ["Index", "Name", "Id"], o = { name: 1, dataIndex: 1, dataType: 1 }; f(t, function (t, r) { for (var s = !1, l = 0; l < a.length; l++) { var u = a[l], h = r.lastIndexOf(u); if (h > 0 && h === r.length - u.length) { var c = r.slice(0, h); "data" !== c && (e.mainType = c, e[u.toLowerCase()] = t, s = !0) } } o.hasOwnProperty(r) && (i[r] = t, s = !0), s || (n[r] = t) }) } return { cptQuery: e, dataQuery: i, otherQuery: n } }, filter: function (t, e) { function i(t, e, i, n) { return null == t[i] || e[n || i] === t[i] } var n = this.eventInfo; if (!n) return !0; var r = n.targetEl, a = n.packedEvent, o = n.model, s = n.view; if (!o || !s) return !0; var l = e.cptQuery, u = e.dataQuery; return i(l, o, "mainType") && i(l, o, "subType") && i(l, o, "index", "componentIndex") && i(l, o, "name") && i(l, o, "id") && i(u, a, "name") && i(u, a, "dataIndex") && i(u, a, "dataType") && (!s.filterForExposedEvent || s.filterForExposedEvent(t, e.otherQuery, r, a)) }, afterTrigger: function () { this.eventInfo = null } }; var ob = {}, sb = {}, lb = [], ub = [], hb = [], cb = [], db = {}, fb = {}, pb = {}, gb = {}, mb = new Date - 0, vb = new Date - 0, yb = "_echarts_instance_", xb = Wl; eu(Z_, h_), ql(Hx), Zl(Y_, Wx), nu("default", p_), $l({ type: "highlight", event: "highlight", update: "highlight" }, V), $l({ type: "downplay", event: "downplay", update: "downplay" }, V), Yl("light", w_), Yl("dark", D_); var _b = {}; du.prototype = { constructor: du, add: function (t) { return this._add = t, this }, update: function (t) { return this._update = t, this }, remove: function (t) { return this._remove = t, this }, execute: function () { var t, e = this._old, i = this._new, n = {}, r = {}, a = [], o = []; for (fu(e, n, a, "_oldKeyGetter", this), fu(i, r, o, "_newKeyGetter", this), t = 0; t < e.length; t++) { var s = a[t], l = r[s]; if (null != l) { var u = l.length; u ? (1 === u && (r[s] = null), l = l.unshift()) : r[s] = null, this._update && this._update(l, t) } else this._remove && this._remove(t) } for (var t = 0; t < o.length; t++) { var s = o[t]; if (r.hasOwnProperty(s)) { var l = r[s]; if (null == l) continue; if (l.length) for (var h = 0, u = l.length; u > h; h++)this._add && this._add(l[h]); else this._add && this._add(l) } } } }; var bb = N(["tooltip", "label", "itemName", "itemId", "seriesName"]), wb = S, Sb = "undefined", Mb = -1, Ib = "e\x00\x00", Db = { "float": typeof Float64Array === Sb ? Array : Float64Array, "int": typeof Int32Array === Sb ? Array : Int32Array, ordinal: Array, number: Array, time: Array }, Tb = typeof Uint32Array === Sb ? Array : Uint32Array, Ab = typeof Int32Array === Sb ? Array : Int32Array, Cb = typeof Uint16Array === Sb ? Array : Uint16Array, kb = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_rawData", "_chunkSize", "_chunkCount", "_dimValueGetter", "_count", "_rawCount", "_nameDimIdx", "_idDimIdx"], Pb = ["_extent", "_approximateExtent", "_rawExtent"], Lb = function (t, e) { t = t || ["x", "y"]; for (var i = {}, n = [], r = {}, a = 0; a < t.length; a++) { var o = t[a]; w(o) && (o = { name: o }); var s = o.name; o.type = o.type || "float", o.coordDim || (o.coordDim = s, o.coordDimIndex = 0), o.otherDims = o.otherDims || {}, n.push(s), i[s] = o, o.index = a, o.createInvertedIndices && (r[s] = []) } this.dimensions = n, this._dimensionInfos = i, this.hostModel = e, this.dataType, this._indices = null, this._count = 0, this._rawCount = 0, this._storage = {}, this._nameList = [], this._idList = [], this._optionModels = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this.hasItemVisual = {}, this._itemLayouts = [], this._graphicEls = [], this._chunkSize = 1e5, this._chunkCount = 0, this._rawData, this._rawExtent = {}, this._extent = {}, this._approximateExtent = {}, this._dimensionsSummary = pu(this), this._invertedIndicesMap = r, this._calculationInfo = {} }, Ob = Lb.prototype; Ob.type = "list", Ob.hasItemOption = !0, Ob.getDimension = function (t) { return isNaN(t) || (t = this.dimensions[t] || t), t }, Ob.getDimensionInfo = function (t) { return this._dimensionInfos[this.getDimension(t)] }, Ob.getDimensionsOnCoord = function () { return this._dimensionsSummary.dataDimsOnCoord.slice() }, Ob.mapDimension = function (t, e) { var i = this._dimensionsSummary; if (null == e) return i.encodeFirstDimNotExtra[t]; var n = i.encode[t]; return e === !0 ? (n || []).slice() : n && n[e] }, Ob.initData = function (t, e, i) { var n = Oo.isInstance(t) || d(t); n && (t = new xs(t, this.dimensions.length)), this._rawData = t, this._storage = {}, this._indices = null, this._nameList = e || [], this._idList = [], this._nameRepeatCount = {}, i || (this.hasItemOption = !1), this.defaultDimValueGetter = Yx[this._rawData.getSource().sourceFormat], this._dimValueGetter = i = i || this.defaultDimValueGetter, this._dimValueGetterArrayRows = Yx.arrayRows, this._rawExtent = {}, this._initDataFromProvider(0, t.count()), t.pure && (this.hasItemOption = !1) }, Ob.getProvider = function () { return this._rawData }, Ob.appendData = function (t) { var e = this._rawData, i = this.count(); e.appendData(t); var n = e.count(); e.persistent || (n += i), this._initDataFromProvider(i, n) }, Ob.appendValues = function (t, e) { for (var i = this._chunkSize, n = this._storage, r = this.dimensions, a = r.length, o = this._rawExtent, s = this.count(), l = s + Math.max(t.length, e ? e.length : 0), u = this._chunkCount, h = 0; a > h; h++) { var c = r[h]; o[c] || (o[c] = Cu()), n[c] || (n[c] = []), _u(n, this._dimensionInfos[c], i, u, l), this._chunkCount = n[c].length } for (var d = new Array(a), f = s; l > f; f++) { for (var p = f - s, g = Math.floor(f / i), m = f % i, v = 0; a > v; v++) { var c = r[v], y = this._dimValueGetterArrayRows(t[p] || d, c, p, v); n[c][g][m] = y; var x = o[c]; y < x[0] && (x[0] = y), y > x[1] && (x[1] = y) } e && (this._nameList[f] = e[p]) } this._rawCount = this._count = l, this._extent = {}, bu(this) }, Ob._initDataFromProvider = function (t, e) { if (!(t >= e)) { for (var i, n = this._chunkSize, r = this._rawData, a = this._storage, o = this.dimensions, s = o.length, l = this._dimensionInfos, u = this._nameList, h = this._idList, c = this._rawExtent, d = this._nameRepeatCount = {}, f = this._chunkCount, p = 0; s > p; p++) { var g = o[p]; c[g] || (c[g] = Cu()); var m = l[g]; 0 === m.otherDims.itemName && (i = this._nameDimIdx = p), 0 === m.otherDims.itemId && (this._idDimIdx = p), a[g] || (a[g] = []), _u(a, m, n, f, e), this._chunkCount = a[g].length } for (var v = new Array(s), y = t; e > y; y++) { v = r.getItem(y, v); for (var x = Math.floor(y / n), _ = y % n, b = 0; s > b; b++) { var g = o[b], w = a[g][x], S = this._dimValueGetter(v, g, y, b); w[_] = S; var M = c[g]; S < M[0] && (M[0] = S), S > M[1] && (M[1] = S) } if (!r.pure) { var I = u[y]; if (v && null == I) if (null != v.name) u[y] = I = v.name; else if (null != i) { var D = o[i], T = a[D][x]; if (T) { I = T[_]; var A = l[D].ordinalMeta; A && A.categories.length && (I = A.categories[I]) } } var C = null == v ? null : v.id; null == C && null != I && (d[I] = d[I] || 0, C = I, d[I] > 0 && (C += "__ec__" + d[I]), d[I]++), null != C && (h[y] = C) } } !r.persistent && r.clean && r.clean(), this._rawCount = this._count = e, this._extent = {}, bu(this) } }, Ob.count = function () { return this._count }, Ob.getIndices = function () { var t, e = this._indices; if (e) { var i = e.constructor, n = this._count; if (i === Array) { t = new i(n); for (var r = 0; n > r; r++)t[r] = e[r] } else t = new i(e.buffer, 0, n) } else for (var i = vu(this), t = new i(this.count()), r = 0; r < t.length; r++)t[r] = r; return t }, Ob.get = function (t, e) { if (!(e >= 0 && e < this._count)) return 0 / 0; var i = this._storage; if (!i[t]) return 0 / 0; e = this.getRawIndex(e); var n = Math.floor(e / this._chunkSize), r = e % this._chunkSize, a = i[t][n], o = a[r]; return o }, Ob.getByRawIndex = function (t, e) { if (!(e >= 0 && e < this._rawCount)) return 0 / 0; var i = this._storage[t]; if (!i) return 0 / 0; var n = Math.floor(e / this._chunkSize), r = e % this._chunkSize, a = i[n]; return a[r] }, Ob._getFast = function (t, e) { var i = Math.floor(e / this._chunkSize), n = e % this._chunkSize, r = this._storage[t][i]; return r[n] }, Ob.getValues = function (t, e) { var i = []; _(t) || (e = t, t = this.dimensions); for (var n = 0, r = t.length; r > n; n++)i.push(this.get(t[n], e)); return i }, Ob.hasValue = function (t) { for (var e = this._dimensionsSummary.dataDimsOnCoord, i = this._dimensionInfos, n = 0, r = e.length; r > n; n++)if ("ordinal" !== i[e[n]].type && isNaN(this.get(e[n], t))) return !1; return !0 }, Ob.getDataExtent = function (t) { t = this.getDimension(t); var e = this._storage[t], i = Cu(); if (!e) return i; var n, r = this.count(), a = !this._indices; if (a) return this._rawExtent[t].slice(); if (n = this._extent[t]) return n.slice(); n = i; for (var o = n[0], s = n[1], l = 0; r > l; l++) { var u = this._getFast(t, this.getRawIndex(l)); o > u && (o = u), u > s && (s = u) } return n = [o, s], this._extent[t] = n, n }, Ob.getApproximateExtent = function (t) { return t = this.getDimension(t), this._approximateExtent[t] || this.getDataExtent(t) }, Ob.setApproximateExtent = function (t, e) { e = this.getDimension(e), this._approximateExtent[e] = t.slice() }, Ob.getCalculationInfo = function (t) { return this._calculationInfo[t] }, Ob.setCalculationInfo = function (t, e) { wb(t) ? o(this._calculationInfo, t) : this._calculationInfo[t] = e }, Ob.getSum = function (t) { var e = this._storage[t], i = 0; if (e) for (var n = 0, r = this.count(); r > n; n++) { var a = this.get(t, n); isNaN(a) || (i += a) } return i }, Ob.getMedian = function (t) { var e = []; this.each(t, function (t) { isNaN(t) || e.push(t) }); var i = [].concat(e).sort(function (t, e) { return t - e }), n = this.count(); return 0 === n ? 0 : n % 2 === 1 ? i[(n - 1) / 2] : (i[n / 2] + i[n / 2 - 1]) / 2 }, Ob.rawIndexOf = function (t, e) { var i = t && this._invertedIndicesMap[t], n = i[e]; return null == n || isNaN(n) ? Mb : n }, Ob.indexOfName = function (t) { for (var e = 0, i = this.count(); i > e; e++)if (this.getName(e) === t) return e; return -1 }, Ob.indexOfRawIndex = function (t) { if (!this._indices) return t; if (t >= this._rawCount || 0 > t) return -1; var e = this._indices, i = e[t]; if (null != i && i < this._count && i === t) return t; for (var n = 0, r = this._count - 1; r >= n;) { var a = (n + r) / 2 | 0; if (e[a] < t) n = a + 1; else { if (!(e[a] > t)) return a; r = a - 1 } } return -1 }, Ob.indicesOfNearest = function (t, e, i) { var n = this._storage, r = n[t], a = []; if (!r) return a; null == i && (i = 1 / 0); for (var o = Number.MAX_VALUE, s = -1, l = 0, u = this.count(); u > l; l++) { var h = e - this.get(t, l), c = Math.abs(h); i >= h && o >= c && ((o > c || h >= 0 && 0 > s) && (o = c, s = h, a.length = 0), a.push(l)) } return a }, Ob.getRawIndex = Su, Ob.getRawDataItem = function (t) { if (this._rawData.persistent) return this._rawData.getItem(this.getRawIndex(t)); for (var e = [], i = 0; i < this.dimensions.length; i++) { var n = this.dimensions[i]; e.push(this.get(n, t)) } return e }, Ob.getName = function (t) { var e = this.getRawIndex(t); return this._nameList[e] || wu(this, this._nameDimIdx, e) || "" }, Ob.getId = function (t) { return Iu(this, this.getRawIndex(t)) }, Ob.each = function (t, e, i, n) { if (this._count) { "function" == typeof t && (n = i, i = e, e = t, t = []), i = i || n || this, t = p(Du(t), this.getDimension, this); for (var r = t.length, a = 0; a < this.count(); a++)switch (r) { case 0: e.call(i, a); break; case 1: e.call(i, this.get(t[0], a), a); break; case 2: e.call(i, this.get(t[0], a), this.get(t[1], a), a); break; default: for (var o = 0, s = []; r > o; o++)s[o] = this.get(t[o], a); s[o] = a, e.apply(i, s) } } }, Ob.filterSelf = function (t, e, i, n) { if (this._count) { "function" == typeof t && (n = i, i = e, e = t, t = []), i = i || n || this, t = p(Du(t), this.getDimension, this); for (var r = this.count(), a = vu(this), o = new a(r), s = [], l = t.length, u = 0, h = t[0], c = 0; r > c; c++) { var d, f = this.getRawIndex(c); if (0 === l) d = e.call(i, c); else if (1 === l) { var g = this._getFast(h, f); d = e.call(i, g, c) } else { for (var m = 0; l > m; m++)s[m] = this._getFast(h, f); s[m] = c, d = e.apply(i, s) } d && (o[u++] = f) } return r > u && (this._indices = o), this._count = u, this._extent = {}, this.getRawIndex = this._indices ? Mu : Su, this } }, Ob.selectRange = function (t) { if (this._count) { var e = []; for (var i in t) t.hasOwnProperty(i) && e.push(i); var n = e.length; if (n) { var r = this.count(), a = vu(this), o = new a(r), s = 0, l = e[0], u = t[l][0], h = t[l][1], c = !1; if (!this._indices) { var d = 0; if (1 === n) { for (var f = this._storage[e[0]], p = 0; p < this._chunkCount; p++)for (var g = f[p], m = Math.min(this._count - p * this._chunkSize, this._chunkSize), v = 0; m > v; v++) { var y = g[v]; (y >= u && h >= y || isNaN(y)) && (o[s++] = d), d++ } c = !0 } else if (2 === n) { for (var f = this._storage[l], x = this._storage[e[1]], _ = t[e[1]][0], b = t[e[1]][1], p = 0; p < this._chunkCount; p++)for (var g = f[p], w = x[p], m = Math.min(this._count - p * this._chunkSize, this._chunkSize), v = 0; m > v; v++) { var y = g[v], S = w[v]; (y >= u && h >= y || isNaN(y)) && (S >= _ && b >= S || isNaN(S)) && (o[s++] = d), d++ } c = !0 } } if (!c) if (1 === n) for (var v = 0; r > v; v++) { var M = this.getRawIndex(v), y = this._getFast(l, M); (y >= u && h >= y || isNaN(y)) && (o[s++] = M) } else for (var v = 0; r > v; v++) { for (var I = !0, M = this.getRawIndex(v), p = 0; n > p; p++) { var D = e[p], y = this._getFast(i, M); (y < t[D][0] || y > t[D][1]) && (I = !1) } I && (o[s++] = this.getRawIndex(v)) } return r > s && (this._indices = o), this._count = s, this._extent = {}, this.getRawIndex = this._indices ? Mu : Su, this } } }, Ob.mapArray = function (t, e, i, n) { "function" == typeof t && (n = i, i = e, e = t, t = []), i = i || n || this; var r = []; return this.each(t, function () { r.push(e && e.apply(this, arguments)) }, i), r }, Ob.map = function (t, e, i, n) { i = i || n || this, t = p(Du(t), this.getDimension, this); var r = Tu(this, t); r._indices = this._indices, r.getRawIndex = r._indices ? Mu : Su; for (var a = r._storage, o = [], s = this._chunkSize, l = t.length, u = this.count(), h = [], c = r._rawExtent, d = 0; u > d; d++) { for (var f = 0; l > f; f++)h[f] = this.get(t[f], d); h[l] = d; var g = e && e.apply(i, h); if (null != g) { "object" != typeof g && (o[0] = g, g = o); for (var m = this.getRawIndex(d), v = Math.floor(m / s), y = m % s, x = 0; x < g.length; x++) { var _ = t[x], b = g[x], w = c[_], S = a[_]; S && (S[v][y] = b), b < w[0] && (w[0] = b), b > w[1] && (w[1] = b) } } } return r }, Ob.downSample = function (t, e, i, n) {
    for (var r = Tu(this, [t]), a = r._storage, o = [], s = Math.floor(1 / e), l = a[t], u = this.count(), h = this._chunkSize, c = r._rawExtent[t], d = new (vu(this))(u), f = 0, p = 0; u > p; p += s) {
    s > u - p && (s = u - p, o.length = s);
      for (var g = 0; s > g; g++) { var m = this.getRawIndex(p + g), v = Math.floor(m / h), y = m % h; o[g] = l[v][y] } var x = i(o), _ = this.getRawIndex(Math.min(p + n(o, x) || 0, u - 1)), b = Math.floor(_ / h), w = _ % h; l[b][w] = x, x < c[0] && (c[0] = x), x > c[1] && (c[1] = x), d[f++] = _
    } return r._count = f, r._indices = d, r.getRawIndex = Mu, r
  }, Ob.getItemModel = function (t) { var e = this.hostModel; return new Ha(this.getRawDataItem(t), e, e && e.ecModel) }, Ob.diff = function (t) { var e = this; return new du(t ? t.getIndices() : [], this.getIndices(), function (e) { return Iu(t, e) }, function (t) { return Iu(e, t) }) }, Ob.getVisual = function (t) { var e = this._visual; return e && e[t] }, Ob.setVisual = function (t, e) { if (wb(t)) for (var i in t) t.hasOwnProperty(i) && this.setVisual(i, t[i]); else this._visual = this._visual || {}, this._visual[t] = e }, Ob.setLayout = function (t, e) { if (wb(t)) for (var i in t) t.hasOwnProperty(i) && this.setLayout(i, t[i]); else this._layout[t] = e }, Ob.getLayout = function (t) { return this._layout[t] }, Ob.getItemLayout = function (t) { return this._itemLayouts[t] }, Ob.setItemLayout = function (t, e, i) { this._itemLayouts[t] = i ? o(this._itemLayouts[t] || {}, e) : e }, Ob.clearItemLayouts = function () { this._itemLayouts.length = 0 }, Ob.getItemVisual = function (t, e, i) { var n = this._itemVisuals[t], r = n && n[e]; return null != r || i ? r : this.getVisual(e) }, Ob.setItemVisual = function (t, e, i) { var n = this._itemVisuals[t] || {}, r = this.hasItemVisual; if (this._itemVisuals[t] = n, wb(e)) for (var a in e) e.hasOwnProperty(a) && (n[a] = e[a], r[a] = !0); else n[e] = i, r[e] = !0 }, Ob.clearAllVisual = function () { this._visual = {}, this._itemVisuals = [], this.hasItemVisual = {} }; var zb = function (t) { t.seriesIndex = this.seriesIndex, t.dataIndex = this.dataIndex, t.dataType = this.dataType }; Ob.setItemGraphicEl = function (t, e) { var i = this.hostModel; e && (e.dataIndex = t, e.dataType = this.dataType, e.seriesIndex = i && i.seriesIndex, "group" === e.type && e.traverse(zb, e)), this._graphicEls[t] = e }, Ob.getItemGraphicEl = function (t) { return this._graphicEls[t] }, Ob.eachItemGraphicEl = function (t, e) { f(this._graphicEls, function (i, n) { i && t && t.call(e, i, n) }) }, Ob.cloneShallow = function (t) { if (!t) { var e = p(this.dimensions, this.getDimensionInfo, this); t = new Lb(e, this.hostModel) } if (t._storage = this._storage, xu(t, this), this._indices) { var i = this._indices.constructor; t._indices = new i(this._indices) } else t._indices = null; return t.getRawIndex = t._indices ? Mu : Su, t }, Ob.wrapMethod = function (t, e) { var i = this[t]; "function" == typeof i && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function () { var t = i.apply(this, arguments); return e.apply(this, [t].concat(P(arguments))) }) }, Ob.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "map"], Ob.CHANGABLE_METHODS = ["filterSelf", "selectRange"]; var Eb = function (t, e) { return e = e || {}, ku(e.coordDimensions || [], t, { dimsDef: e.dimensionsDefine || t.dimensionsDefine, encodeDef: e.encodeDefine || t.encodeDefine, dimCount: e.dimensionsCount, generateCoord: e.generateCoord, generateCoordCount: e.generateCoordCount }) }; Fu.prototype.parse = function (t) { return t }, Fu.prototype.getSetting = function (t) { return this._setting[t] }, Fu.prototype.contain = function (t) { var e = this._extent; return t >= e[0] && t <= e[1] }, Fu.prototype.normalize = function (t) { var e = this._extent; return e[1] === e[0] ? .5 : (t - e[0]) / (e[1] - e[0]) }, Fu.prototype.scale = function (t) { var e = this._extent; return t * (e[1] - e[0]) + e[0] }, Fu.prototype.unionExtent = function (t) { var e = this._extent; t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]) }, Fu.prototype.unionExtentFromData = function (t, e) { this.unionExtent(t.getApproximateExtent(e)) }, Fu.prototype.getExtent = function () { return this._extent.slice() }, Fu.prototype.setExtent = function (t, e) { var i = this._extent; isNaN(t) || (i[0] = t), isNaN(e) || (i[1] = e) }, Fu.prototype.isBlank = function () { return this._isBlank }, Fu.prototype.setBlank = function (t) { this._isBlank = t }, Fu.prototype.getLabel = null, tr(Fu), rr(Fu, { registerWhenExtend: !0 }), Vu.createByAxisModel = function (t) { var e = t.option, i = e.data, n = i && p(i, Hu); return new Vu({ categories: n, needCollect: !n, deduplication: e.dedplication !== !1 }) }; var Bb = Vu.prototype; Bb.getOrdinal = function (t) { return Gu(this).get(t) }, Bb.parseAndCollect = function (t) { var e, i = this._needCollect; if ("string" != typeof t && !i) return t; if (i && !this._deduplication) return e = this.categories.length, this.categories[e] = t, e; var n = Gu(this); return e = n.get(t), null == e && (i ? (e = this.categories.length, this.categories[e] = t, n.set(t, e)) : e = 0 / 0), e }; var Rb = Fu.prototype, Nb = Fu.extend({ type: "ordinal", init: function (t, e) { (!t || _(t)) && (t = new Vu({ categories: t })), this._ordinalMeta = t, this._extent = e || [0, t.categories.length - 1] }, parse: function (t) { return "string" == typeof t ? this._ordinalMeta.getOrdinal(t) : Math.round(t) }, contain: function (t) { return t = this.parse(t), Rb.contain.call(this, t) && null != this._ordinalMeta.categories[t] }, normalize: function (t) { return Rb.normalize.call(this, this.parse(t)) }, scale: function (t) { return Math.round(Rb.scale.call(this, t)) }, getTicks: function () { for (var t = [], e = this._extent, i = e[0]; i <= e[1];)t.push(i), i++; return t }, getLabel: function (t) { return this.isBlank() ? void 0 : this._ordinalMeta.categories[t] }, count: function () { return this._extent[1] - this._extent[0] + 1 }, unionExtentFromData: function (t, e) { this.unionExtent(t.getApproximateExtent(e)) }, getOrdinalMeta: function () { return this._ordinalMeta }, niceTicks: V, niceExtent: V }); Nb.create = function () { return new Nb }; var Fb = $a, Vb = $a, Gb = Fu.extend({ type: "interval", _interval: 0, _intervalPrecision: 2, setExtent: function (t, e) { var i = this._extent; isNaN(t) || (i[0] = parseFloat(t)), isNaN(e) || (i[1] = parseFloat(e)) }, unionExtent: function (t) { var e = this._extent; t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]), Gb.prototype.setExtent.call(this, e[0], e[1]) }, getInterval: function () { return this._interval }, setInterval: function (t) { this._interval = t, this._niceExtent = this._extent.slice(), this._intervalPrecision = Xu(t) }, getTicks: function () { return Yu(this._interval, this._extent, this._niceExtent, this._intervalPrecision) }, getLabel: function (t, e) { if (null == t) return ""; var i = e && e.precision; return null == i ? i = to(t) || 0 : "auto" === i && (i = this._intervalPrecision), t = Vb(t, i, !0), fo(t) }, niceTicks: function (t, e, i) { t = t || 5; var n = this._extent, r = n[1] - n[0]; if (isFinite(r)) { 0 > r && (r = -r, n.reverse()); var a = Wu(n, t, e, i); this._intervalPrecision = a.intervalPrecision, this._interval = a.interval, this._niceExtent = a.niceTickExtent } }, niceExtent: function (t) { var e = this._extent; if (e[0] === e[1]) if (0 !== e[0]) { var i = e[0]; t.fixMax ? e[0] -= i / 2 : (e[1] += i / 2, e[0] -= i / 2) } else e[1] = 1; var n = e[1] - e[0]; isFinite(n) || (e[0] = 0, e[1] = 1), this.niceTicks(t.splitNumber, t.minInterval, t.maxInterval); var r = this._interval; t.fixMin || (e[0] = Vb(Math.floor(e[0] / r) * r)), t.fixMax || (e[1] = Vb(Math.ceil(e[1] / r) * r)) } }); Gb.create = function () { return new Gb }; var Hb = "__ec_stack_", Wb = .5, Xb = "undefined" != typeof Float32Array ? Float32Array : Array, Ub = { seriesType: "bar", plan: i_(), reset: function (t) { function e(t, e) { for (var i, c = new Xb(2 * t.count), d = [], f = [], p = 0; null != (i = t.next());)f[u] = e.get(o, i), f[1 - u] = e.get(s, i), d = n.dataToPoint(f, null, d), c[p++] = d[0], c[p++] = d[1]; e.setLayout({ largePoints: c, barWidth: h, valueAxisStart: nh(r, a, !1), valueAxisHorizontal: l }) } if (eh(t) && ih(t)) { var i = t.getData(), n = t.coordinateSystem, r = n.getBaseAxis(), a = n.getOtherAxis(r), o = i.mapDimension(a.dim), s = i.mapDimension(r.dim), l = a.isHorizontal(), u = l ? 0 : 1, h = Ju($u([t]), r, t).width; return h > Wb || (h = Wb), { progress: e } } } }, jb = Gb.prototype, Yb = Math.ceil, qb = Math.floor, Zb = 1e3, Kb = 60 * Zb, $b = 60 * Kb, Qb = 24 * $b, Jb = function (t, e, i, n) { for (; n > i;) { var r = i + n >>> 1; t[r][1] < e ? i = r + 1 : n = r } return i }, tw = Gb.extend({ type: "time", getLabel: function (t) { var e = this._stepLvl, i = new Date(t); return _o(e[0], i, this.getSetting("useUTC")) }, niceExtent: function (t) { var e = this._extent; if (e[0] === e[1] && (e[0] -= Qb, e[1] += Qb), e[1] === -1 / 0 && 1 / 0 === e[0]) { var i = new Date; e[1] = +new Date(i.getFullYear(), i.getMonth(), i.getDate()), e[0] = e[1] - Qb } this.niceTicks(t.splitNumber, t.minInterval, t.maxInterval); var n = this._interval; t.fixMin || (e[0] = $a(qb(e[0] / n) * n)), t.fixMax || (e[1] = $a(Yb(e[1] / n) * n)) }, niceTicks: function (t, e, i) { t = t || 10; var n = this._extent, r = n[1] - n[0], a = r / t; null != e && e > a && (a = e), null != i && a > i && (a = i); var o = ew.length, s = Jb(ew, a, 0, o), l = ew[Math.min(s, o - 1)], u = l[1]; if ("year" === l[0]) { var h = r / u, c = lo(h / t, !0); u *= c } var d = this.getSetting("useUTC") ? 0 : 60 * new Date(+n[0] || +n[1]).getTimezoneOffset() * 1e3, f = [Math.round(Yb((n[0] - d) / u) * u + d), Math.round(qb((n[1] - d) / u) * u + d)]; ju(f, n), this._stepLvl = l, this._interval = u, this._niceExtent = f }, parse: function (t) { return +ao(t) } }); f(["contain", "normalize"], function (t) { tw.prototype[t] = function (e) { return jb[t].call(this, this.parse(e)) } }); var ew = [["hh:mm:ss", Zb], ["hh:mm:ss", 5 * Zb], ["hh:mm:ss", 10 * Zb], ["hh:mm:ss", 15 * Zb], ["hh:mm:ss", 30 * Zb], ["hh:mm\nMM-dd", Kb], ["hh:mm\nMM-dd", 5 * Kb], ["hh:mm\nMM-dd", 10 * Kb], ["hh:mm\nMM-dd", 15 * Kb], ["hh:mm\nMM-dd", 30 * Kb], ["hh:mm\nMM-dd", $b], ["hh:mm\nMM-dd", 2 * $b], ["hh:mm\nMM-dd", 6 * $b], ["hh:mm\nMM-dd", 12 * $b], ["MM-dd\nyyyy", Qb], ["MM-dd\nyyyy", 2 * Qb], ["MM-dd\nyyyy", 3 * Qb], ["MM-dd\nyyyy", 4 * Qb], ["MM-dd\nyyyy", 5 * Qb], ["MM-dd\nyyyy", 6 * Qb], ["week", 7 * Qb], ["MM-dd\nyyyy", 10 * Qb], ["week", 14 * Qb], ["week", 21 * Qb], ["month", 31 * Qb], ["week", 42 * Qb], ["month", 62 * Qb], ["week", 70 * Qb], ["quarter", 95 * Qb], ["month", 31 * Qb * 4], ["month", 31 * Qb * 5], ["half-year", 380 * Qb / 2], ["month", 31 * Qb * 8], ["month", 31 * Qb * 10], ["year", 380 * Qb]]; tw.create = function (t) { return new tw({ useUTC: t.ecModel.get("useUTC") }) }; var iw = Fu.prototype, nw = Gb.prototype, rw = to, aw = $a, ow = Math.floor, sw = Math.ceil, lw = Math.pow, uw = Math.log, hw = Fu.extend({ type: "log", base: 10, $constructor: function () { Fu.apply(this, arguments), this._originalScale = new Gb }, getTicks: function () { var t = this._originalScale, e = this._extent, i = t.getExtent(); return p(nw.getTicks.call(this), function (n) { var r = $a(lw(this.base, n)); return r = n === e[0] && t.__fixMin ? rh(r, i[0]) : r, r = n === e[1] && t.__fixMax ? rh(r, i[1]) : r }, this) }, getLabel: nw.getLabel, scale: function (t) { return t = iw.scale.call(this, t), lw(this.base, t) }, setExtent: function (t, e) { var i = this.base; t = uw(t) / uw(i), e = uw(e) / uw(i), nw.setExtent.call(this, t, e) }, getExtent: function () { var t = this.base, e = iw.getExtent.call(this); e[0] = lw(t, e[0]), e[1] = lw(t, e[1]); var i = this._originalScale, n = i.getExtent(); return i.__fixMin && (e[0] = rh(e[0], n[0])), i.__fixMax && (e[1] = rh(e[1], n[1])), e }, unionExtent: function (t) { this._originalScale.unionExtent(t); var e = this.base; t[0] = uw(t[0]) / uw(e), t[1] = uw(t[1]) / uw(e), iw.unionExtent.call(this, t) }, unionExtentFromData: function (t, e) { this.unionExtent(t.getApproximateExtent(e)) }, niceTicks: function (t) { t = t || 10; var e = this._extent, i = e[1] - e[0]; if (!(1 / 0 === i || 0 >= i)) { var n = oo(i), r = t / i * n; for (.5 >= r && (n *= 10); !isNaN(n) && Math.abs(n) < 1 && Math.abs(n) > 0;)n *= 10; var a = [$a(sw(e[0] / n) * n), $a(ow(e[1] / n) * n)]; this._interval = n, this._niceExtent = a } }, niceExtent: function (t) { nw.niceExtent.call(this, t); var e = this._originalScale; e.__fixMin = t.fixMin, e.__fixMax = t.fixMax } }); f(["contain", "normalize"], function (t) { hw.prototype[t] = function (e) { return e = uw(e) / uw(this.base), iw[t].call(this, e) } }), hw.create = function () { return new hw }; var cw = { getMin: function (t) { var e = this.option, i = t || null == e.rangeStart ? e.min : e.rangeStart; return this.axis && null != i && "dataMin" !== i && "function" != typeof i && !T(i) && (i = this.axis.scale.parse(i)), i }, getMax: function (t) { var e = this.option, i = t || null == e.rangeEnd ? e.max : e.rangeEnd; return this.axis && null != i && "dataMax" !== i && "function" != typeof i && !T(i) && (i = this.axis.scale.parse(i)), i }, getNeedCrossZero: function () { var t = this.option; return null != t.rangeStart || null != t.rangeEnd ? !1 : !t.scale }, getCoordSysModel: V, setRange: function (t, e) { this.option.rangeStart = t, this.option.rangeEnd = e }, resetRange: function () { this.option.rangeStart = this.option.rangeEnd = null } }, dw = Qr({ type: "triangle", shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath: function (t, e) { var i = e.cx, n = e.cy, r = e.width / 2, a = e.height / 2; t.moveTo(i, n - a), t.lineTo(i + r, n + a), t.lineTo(i - r, n + a), t.closePath() } }), fw = Qr({ type: "diamond", shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath: function (t, e) { var i = e.cx, n = e.cy, r = e.width / 2, a = e.height / 2; t.moveTo(i, n - a), t.lineTo(i + r, n), t.lineTo(i, n + a), t.lineTo(i - r, n), t.closePath() } }), pw = Qr({ type: "pin", shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath: function (t, e) { var i = e.x, n = e.y, r = e.width / 5 * 3, a = Math.max(r, e.height), o = r / 2, s = o * o / (a - o), l = n - a + o + s, u = Math.asin(s / o), h = Math.cos(u) * o, c = Math.sin(u), d = Math.cos(u), f = .6 * o, p = .7 * o; t.moveTo(i - h, l + s), t.arc(i, l, o, Math.PI - u, 2 * Math.PI + u), t.bezierCurveTo(i + h - c * f, l + s + d * f, i, n - p, i, n), t.bezierCurveTo(i, n - p, i - h + c * f, l + s + d * f, i - h, l + s), t.closePath() } }), gw = Qr({ type: "arrow", shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath: function (t, e) { var i = e.height, n = e.width, r = e.x, a = e.y, o = n / 3 * 2; t.moveTo(r, a), t.lineTo(r + o, a + i), t.lineTo(r, a + i / 4 * 3), t.lineTo(r - o, a + i), t.lineTo(r, a), t.closePath() } }), mw = { line: Sy, rect: by, roundRect: by, square: by, circle: hy, diamond: fw, pin: pw, arrow: gw, triangle: dw }, vw = { line: function (t, e, i, n, r) { r.x1 = t, r.y1 = e + n / 2, r.x2 = t + i, r.y2 = e + n / 2 }, rect: function (t, e, i, n, r) { r.x = t, r.y = e, r.width = i, r.height = n }, roundRect: function (t, e, i, n, r) { r.x = t, r.y = e, r.width = i, r.height = n, r.r = Math.min(i, n) / 4 }, square: function (t, e, i, n, r) { var a = Math.min(i, n); r.x = t, r.y = e, r.width = a, r.height = a }, circle: function (t, e, i, n, r) { r.cx = t + i / 2, r.cy = e + n / 2, r.r = Math.min(i, n) / 2 }, diamond: function (t, e, i, n, r) { r.cx = t + i / 2, r.cy = e + n / 2, r.width = i, r.height = n }, pin: function (t, e, i, n, r) { r.x = t + i / 2, r.y = e + n / 2, r.width = i, r.height = n }, arrow: function (t, e, i, n, r) { r.x = t + i / 2, r.y = e + n / 2, r.width = i, r.height = n }, triangle: function (t, e, i, n, r) { r.cx = t + i / 2, r.cy = e + n / 2, r.width = i, r.height = n } }, yw = {}; f(mw, function (t, e) { yw[e] = new t }); var xw = Qr({ type: "symbol", shape: { symbolType: "", x: 0, y: 0, width: 0, height: 0 }, beforeBrush: function () { var t = this.style, e = this.shape; "pin" === e.symbolType && "inside" === t.textPosition && (t.textPosition = ["50%", "40%"], t.textAlign = "center", t.textVerticalAlign = "middle") }, buildPath: function (t, e, i) { var n = e.symbolType, r = yw[n]; "none" !== e.symbolType && (r || (n = "rect", r = yw[n]), vw[n](e.x, e.y, e.width, e.height, r.shape), r.buildPath(t, r.shape, i)) } }), _w = { isDimensionStacked: zu, enableDataStack: Ou, getStackedDimension: Eu }, bw = (Object.freeze || Object)({ createList: yh, getLayoutRect: Io, dataStack: _w, createScale: xh, mixinAxisModelCommonMethods: _h, completeDimensions: ku, createDimensions: Eb, createSymbol: vh }), ww = 1e-8; Sh.prototype = { constructor: Sh, properties: null, getBoundingRect: function () { var t = this._rect; if (t) return t; for (var e = Number.MAX_VALUE, i = [e, e], n = [-e, -e], r = [], a = [], o = this.geometries, s = 0; s < o.length; s++)if ("polygon" === o[s].type) { var l = o[s].exterior; xr(l, r, a), oe(i, i, r), se(n, n, a) } return 0 === s && (i[0] = i[1] = n[0] = n[1] = 0), this._rect = new vi(i[0], i[1], n[0] - i[0], n[1] - i[1]) }, contain: function (t) { var e = this.getBoundingRect(), i = this.geometries; if (!e.contain(t[0], t[1])) return !1; t: for (var n = 0, r = i.length; r > n; n++)if ("polygon" === i[n].type) { var a = i[n].exterior, o = i[n].interiors; if (wh(a, t[0], t[1])) { for (var s = 0; s < (o ? o.length : 0); s++)if (wh(o[s])) continue t; return !0 } } return !1 }, transformTo: function (t, e, i, n) { var r = this.getBoundingRect(), a = r.width / r.height; i ? n || (n = i / a) : i = a * n; for (var o = new vi(t, e, i, n), s = r.calculateTransform(o), l = this.geometries, u = 0; u < l.length; u++)if ("polygon" === l[u].type) { for (var h = l[u].exterior, c = l[u].interiors, d = 0; d < h.length; d++)ae(h[d], h[d], s); for (var f = 0; f < (c ? c.length : 0); f++)for (var d = 0; d < c[f].length; d++)ae(c[f][d], c[f][d], s) } r = this._rect, r.copy(o), this.center = [r.x + r.width / 2, r.y + r.height / 2] }, cloneShallow: function (t) { null == t && (t = this.name); var e = new Sh(t, this.geometries, this.center); return e._rect = this._rect, e.transformTo = null, e } }; var Sw = function (t) { return Mh(t), p(m(t.features, function (t) { return t.geometry && t.properties && t.geometry.coordinates.length > 0 }), function (t) { var e = t.properties, i = t.geometry, n = i.coordinates, r = []; "Polygon" === i.type && r.push({ type: "polygon", exterior: n[0], interiors: n.slice(1) }), "MultiPolygon" === i.type && f(n, function (t) { t[0] && r.push({ type: "polygon", exterior: t[0], interiors: t.slice(1) }) }); var a = new Sh(e.name, r, e.cp); return a.properties = e, a }) }, Mw = Un(), Iw = [0, 1], Dw = function (t, e, i) { this.dim = t, this.scale = e, this._extent = i || [0, 0], this.inverse = !1, this.onBand = !1 }; Dw.prototype = { constructor: Dw, contain: function (t) { var e = this._extent, i = Math.min(e[0], e[1]), n = Math.max(e[0], e[1]); return t >= i && n >= t }, containData: function (t) { return this.contain(this.dataToCoord(t)) }, getExtent: function () { return this._extent.slice() }, getPixelPrecision: function (t) { return eo(t || this.scale.getExtent(), this._extent) }, setExtent: function (t, e) { var i = this._extent; i[0] = t, i[1] = e }, dataToCoord: function (t, e) { var i = this._extent, n = this.scale; return t = n.normalize(t), this.onBand && "ordinal" === n.type && (i = i.slice(), Vh(i, n.count())), Za(t, Iw, i, e) }, coordToData: function (t, e) { var i = this._extent, n = this.scale; this.onBand && "ordinal" === n.type && (i = i.slice(), Vh(i, n.count())); var r = Za(t, i, Iw, e); return this.scale.scale(r) }, pointToData: function () { }, getTicksCoords: function (t) { t = t || {}; var e = t.tickModel || this.getTickModel(), i = Th(this, e), n = i.ticks, r = p(n, function (t) { return { coord: this.dataToCoord(t), tickValue: t } }, this), a = e.get("alignWithLabel"); return Gh(this, r, i.tickCategoryInterval, a, t.clamp), r }, getViewLabels: function () { return Dh(this).labels }, getLabelModel: function () { return this.model.getModel("axisLabel") }, getTickModel: function () { return this.model.getModel("axisTick") }, getBandWidth: function () { var t = this._extent, e = this.scale.getExtent(), i = e[1] - e[0] + (this.onBand ? 1 : 0); 0 === i && (i = 1); var n = Math.abs(t[1] - t[0]); return Math.abs(n) / i }, isHorizontal: null, getRotate: null, calculateCategoryInterval: function () { return Bh(this) } }; var Tw = Sw, Aw = {}; f(["map", "each", "filter", "indexOf", "inherits", "reduce", "filter", "bind", "curry", "isArray", "isString", "isObject", "isFunction", "extend", "defaults", "clone", "merge"], function (t) { Aw[t] = eg[t] }); var Cw = {}; f(["extendShape", "extendPath", "makePath", "makeImage", "mergePath", "resizePath", "createIcon", "setHoverStyle", "setLabelStyle", "setTextStyle", "setText", "getFont", "updateProps", "initProps", "getTransform", "clipPointsByRect", "clipRectByRect", "Group", "Image", "Text", "Circle", "Sector", "Ring", "Polygon", "Polyline", "Rect", "Line", "BezierCurve", "Arc", "IncrementalDisplayable", "CompoundPath", "LinearGradient", "RadialGradient", "BoundingRect"], function (t) { Cw[t] = Vy[t] }); var kw = function (t) { this._axes = {}, this._dimList = [], this.name = t || "" }; kw.prototype = { constructor: kw, type: "cartesian", getAxis: function (t) { return this._axes[t] }, getAxes: function () { return p(this._dimList, Hh, this) }, getAxesByScale: function (t) { return t = t.toLowerCase(), m(this.getAxes(), function (e) { return e.scale.type === t }) }, addAxis: function (t) { var e = t.dim; this._axes[e] = t, this._dimList.push(e) }, dataToCoord: function (t) { return this._dataCoordConvert(t, "dataToCoord") }, coordToData: function (t) { return this._dataCoordConvert(t, "coordToData") }, _dataCoordConvert: function (t, e) { for (var i = this._dimList, n = t instanceof Array ? [] : {}, r = 0; r < i.length; r++) { var a = i[r], o = this._axes[a]; n[a] = o[e](t[a]) } return n } }, Wh.prototype = { constructor: Wh, type: "cartesian2d", dimensions: ["x", "y"], getBaseAxis: function () { return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x") }, containPoint: function (t) { var e = this.getAxis("x"), i = this.getAxis("y"); return e.contain(e.toLocalCoord(t[0])) && i.contain(i.toLocalCoord(t[1])) }, containData: function (t) { return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1]) }, dataToPoint: function (t, e, i) { var n = this.getAxis("x"), r = this.getAxis("y"); return i = i || [], i[0] = n.toGlobalCoord(n.dataToCoord(t[0])), i[1] = r.toGlobalCoord(r.dataToCoord(t[1])), i }, clampData: function (t, e) { var i = this.getAxis("x").scale, n = this.getAxis("y").scale, r = i.getExtent(), a = n.getExtent(), o = i.parse(t[0]), s = n.parse(t[1]); return e = e || [], e[0] = Math.min(Math.max(Math.min(r[0], r[1]), o), Math.max(r[0], r[1])), e[1] = Math.min(Math.max(Math.min(a[0], a[1]), s), Math.max(a[0], a[1])), e }, pointToData: function (t, e) { var i = this.getAxis("x"), n = this.getAxis("y"); return e = e || [], e[0] = i.coordToData(i.toLocalCoord(t[0])), e[1] = n.coordToData(n.toLocalCoord(t[1])), e }, getOtherAxis: function (t) { return this.getAxis("x" === t.dim ? "y" : "x") } }, h(Wh, kw); var Pw = function (t, e, i, n, r) { Dw.call(this, t, e, i), this.type = n || "value", this.position = r || "bottom" }; Pw.prototype = { constructor: Pw, index: 0, getAxesOnZeroOf: null, model: null, isHorizontal: function () { var t = this.position; return "top" === t || "bottom" === t }, getGlobalExtent: function (t) { var e = this.getExtent(); return e[0] = this.toGlobalCoord(e[0]), e[1] = this.toGlobalCoord(e[1]), t && e[0] > e[1] && e.reverse(), e }, getOtherAxis: function () { this.grid.getOtherAxis() }, pointToData: function (t, e) { return this.coordToData(this.toLocalCoord(t["x" === this.dim ? 0 : 1]), e) }, toLocalCoord: null, toGlobalCoord: null }, h(Pw, Dw); var Lw = { show: !0, zlevel: 0, z: 0, inverse: !1, name: "", nameLocation: "end", nameRotate: null, nameTruncate: { maxWidth: null, ellipsis: "...", placeholder: "." }, nameTextStyle: {}, nameGap: 15, silent: !1, triggerEvent: !1, tooltip: { show: !1 }, axisPointer: {}, axisLine: { show: !0, onZero: !0, onZeroAxisIndex: null, lineStyle: { color: "#333", width: 1, type: "solid" }, symbol: ["none", "none"], symbolSize: [10, 15] }, axisTick: { show: !0, inside: !1, length: 5, lineStyle: { width: 1 } }, axisLabel: { show: !0, inside: !1, rotate: 0, showMinLabel: null, showMaxLabel: null, margin: 8, fontSize: 12 }, splitLine: { show: !0, lineStyle: { color: ["#ccc"], width: 1, type: "solid" } }, splitArea: { show: !1, areaStyle: { color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"] } } }, Ow = {}; Ow.categoryAxis = r({ boundaryGap: !0, deduplication: null, splitLine: { show: !1 }, axisTick: { alignWithLabel: !1, interval: "auto" }, axisLabel: { interval: "auto" } }, Lw), Ow.valueAxis = r({ boundaryGap: [0, 0], splitNumber: 5 }, Lw), Ow.timeAxis = s({ scale: !0, min: "dataMin", max: "dataMax" }, Ow.valueAxis), Ow.logAxis = s({ scale: !0, logBase: 10 }, Ow.valueAxis); var zw = ["value", "category", "time", "log"], Ew = function (t, e, i, n) { f(zw, function (o) { e.extend({ type: t + "Axis." + o, mergeDefaultAndTheme: function (e, n) { var a = this.layoutMode, s = a ? To(e) : {}, l = n.getTheme(); r(e, l.get(o + "Axis")), r(e, this.getDefaultOption()), e.type = i(t, e), a && Do(e, s, a) }, optionUpdated: function () { var t = this.option; "category" === t.type && (this.__ordinalMeta = Vu.createByAxisModel(this)) }, getCategories: function (t) { var e = this.option; return "category" === e.type ? t ? e.data : this.__ordinalMeta.categories : void 0 }, getOrdinalMeta: function () { return this.__ordinalMeta }, defaultOption: a([{}, Ow[o + "Axis"], n], !0) }) }), cx.registerSubTypeDefaulter(t + "Axis", x(i, t)) }, Bw = cx.extend({ type: "cartesian2dAxis", axis: null, init: function () { Bw.superApply(this, "init", arguments), this.resetRange() }, mergeOption: function () { Bw.superApply(this, "mergeOption", arguments), this.resetRange() }, restoreData: function () { Bw.superApply(this, "restoreData", arguments), this.resetRange() }, getCoordSysModel: function () { return this.ecModel.queryComponents({ mainType: "grid", index: this.option.gridIndex, id: this.option.gridId })[0] } }); r(Bw.prototype, cw); var Rw = { offset: 0 }; Ew("x", Bw, Xh, Rw), Ew("y", Bw, Xh, Rw), cx.extend({ type: "grid", dependencies: ["xAxis", "yAxis"], layoutMode: "box", coordinateSystem: null, defaultOption: { show: !1, zlevel: 0, z: 0, left: "10%", top: 60, right: "10%", bottom: 60, containLabel: !1, backgroundColor: "rgba(0,0,0,0)", borderWidth: 1, borderColor: "#ccc" } }); var Nw = jh.prototype; Nw.type = "grid", Nw.axisPointerEnabled = !0, Nw.getRect = function () { return this._rect }, Nw.update = function (t, e) { var i = this._axesMap; this._updateScale(t, this.model), f(i.x, function (t) { sh(t.scale, t.model) }), f(i.y, function (t) { sh(t.scale, t.model) }); var n = {}; f(i.x, function (t) { Yh(i, "y", t, n) }), f(i.y, function (t) { Yh(i, "x", t, n) }), this.resize(this.model, e) }, Nw.resize = function (t, e, i) { function n() { f(a, function (t) { var e = t.isHorizontal(), i = e ? [0, r.width] : [0, r.height], n = t.inverse ? 1 : 0; t.setExtent(i[n], i[1 - n]), Zh(t, e ? r.x : r.y) }) } var r = Io(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }); this._rect = r; var a = this._axesList; n(), !i && t.get("containLabel") && (f(a, function (t) { if (!t.model.get("axisLabel.inside")) { var e = dh(t); if (e) { var i = t.isHorizontal() ? "height" : "width", n = t.model.get("axisLabel.margin"); r[i] -= e[i] + n, "top" === t.position ? r.y += e.height + n : "left" === t.position && (r.x += e.width + n) } } }), n()) }, Nw.getAxis = function (t, e) { var i = this._axesMap[t]; if (null != i) { if (null == e) for (var n in i) if (i.hasOwnProperty(n)) return i[n]; return i[e] } }, Nw.getAxes = function () { return this._axesList.slice() }, Nw.getCartesian = function (t, e) { if (null != t && null != e) { var i = "x" + t + "y" + e; return this._coordsMap[i] } S(t) && (e = t.yAxisIndex, t = t.xAxisIndex); for (var n = 0, r = this._coordsList; n < r.length; n++)if (r[n].getAxis("x").index === t || r[n].getAxis("y").index === e) return r[n] }, Nw.getCartesians = function () { return this._coordsList.slice() }, Nw.convertToPixel = function (t, e, i) { var n = this._findConvertTarget(t, e); return n.cartesian ? n.cartesian.dataToPoint(i) : n.axis ? n.axis.toGlobalCoord(n.axis.dataToCoord(i)) : null }, Nw.convertFromPixel = function (t, e, i) { var n = this._findConvertTarget(t, e); return n.cartesian ? n.cartesian.pointToData(i) : n.axis ? n.axis.coordToData(n.axis.toLocalCoord(i)) : null }, Nw._findConvertTarget = function (t, e) { var i, n, r = e.seriesModel, a = e.xAxisModel || r && r.getReferringComponents("xAxis")[0], o = e.yAxisModel || r && r.getReferringComponents("yAxis")[0], s = e.gridModel, l = this._coordsList; if (r) i = r.coordinateSystem, u(l, i) < 0 && (i = null); else if (a && o) i = this.getCartesian(a.componentIndex, o.componentIndex); else if (a) n = this.getAxis("x", a.componentIndex); else if (o) n = this.getAxis("y", o.componentIndex); else if (s) { var h = s.coordinateSystem; h === this && (i = this._coordsList[0]) } return { cartesian: i, axis: n } }, Nw.containPoint = function (t) { var e = this._coordsList[0]; return e ? e.containPoint(t) : void 0 }, Nw._initCartesian = function (t, e) { function i(i) { return function (o, s) { if (Uh(o, t, e)) { var l = o.get("position"); "x" === i ? "top" !== l && "bottom" !== l && (l = "bottom", n[l] && (l = "top" === l ? "bottom" : "top")) : "left" !== l && "right" !== l && (l = "left", n[l] && (l = "left" === l ? "right" : "left")), n[l] = !0; var u = new Pw(i, lh(o), [0, 0], o.get("type"), l), h = "category" === u.type; u.onBand = h && o.get("boundaryGap"), u.inverse = o.get("inverse"), o.axis = u, u.model = o, u.grid = this, u.index = s, this._axesList.push(u), r[i][s] = u, a[i]++ } } } var n = { left: !1, right: !1, top: !1, bottom: !1 }, r = { x: {}, y: {} }, a = { x: 0, y: 0 }; return e.eachComponent("xAxis", i("x"), this), e.eachComponent("yAxis", i("y"), this), a.x && a.y ? (this._axesMap = r, void f(r.x, function (e, i) { f(r.y, function (n, r) { var a = "x" + i + "y" + r, o = new Wh(a); o.grid = this, o.model = t, this._coordsMap[a] = o, this._coordsList.push(o), o.addAxis(e), o.addAxis(n) }, this) }, this)) : (this._axesMap = {}, void (this._axesList = [])) }, Nw._updateScale = function (t, e) { function i(t, e) { f(t.mapDimension(e.dim, !0), function (i) { e.scale.unionExtentFromData(t, Eu(t, i)) }) } f(this._axesList, function (t) { t.scale.setExtent(1 / 0, -1 / 0) }), t.eachSeries(function (n) { if ($h(n)) { var r = Kh(n, t), a = r[0], o = r[1]; if (!Uh(a, e, t) || !Uh(o, e, t)) return; var s = this.getCartesian(a.componentIndex, o.componentIndex), l = n.getData(), u = s.getAxis("x"), h = s.getAxis("y"); "list" === l.type && (i(l, u, n), i(l, h, n)) } }, this) }, Nw.getTooltipAxes = function (t) { var e = [], i = []; return f(this.getCartesians(), function (n) { var r = null != t && "auto" !== t ? n.getAxis(t) : n.getBaseAxis(), a = n.getOtherAxis(r); u(e, r) < 0 && e.push(r), u(i, a) < 0 && i.push(a) }), { baseAxes: e, otherAxes: i } }; var Fw = ["xAxis", "yAxis"]; jh.create = function (t, e) { var i = []; return t.eachComponent("grid", function (n, r) { var a = new jh(n, t, e); a.name = "grid_" + r, a.resize(n, e, !0), n.coordinateSystem = a, i.push(a) }), t.eachSeries(function (e) { if ($h(e)) { var i = Kh(e, t), n = i[0], r = i[1], a = n.getCoordSysModel(), o = a.coordinateSystem; e.coordinateSystem = o.getCartesian(n.componentIndex, r.componentIndex) } }), i }, jh.dimensions = jh.prototype.dimensions = Wh.prototype.dimensions, ts.register("cartesian2d", jh); var Vw = Jx.extend({ type: "series.__base_bar__", getInitialData: function () { return Bu(this.getSource(), this) }, getMarkerPosition: function (t) { var e = this.coordinateSystem; if (e) { var i = e.dataToPoint(e.clampData(t)), n = this.getData(), r = n.getLayout("offset"), a = n.getLayout("size"), o = e.getBaseAxis().isHorizontal() ? 0 : 1; return i[o] += r + a / 2, i } return [0 / 0, 0 / 0] }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "cartesian2d", legendHoverLink: !0, barMinHeight: 0, barMinAngle: 0, large: !1, largeThreshold: 400, progressive: 3e3, progressiveChunkMode: "mod", itemStyle: {}, emphasis: {} } }); Vw.extend({ type: "series.bar", dependencies: ["grid", "polar"], brushSelector: "rect", getProgressive: function () { return this.get("large") ? this.get("progressive") : !1 }, getProgressiveThreshold: function () { var t = this.get("progressiveThreshold"), e = this.get("largeThreshold"); return e > t && (t = e), t } }); var Gw = iv([["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["stroke", "barBorderColor"], ["lineWidth", "barBorderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]), Hw = { getBarItemStyle: function (t) { var e = Gw(this, t); if (this.getBorderLineDash) { var i = this.getBorderLineDash(); i && (e.lineDash = i) } return e } }, Ww = ["itemStyle", "barBorderWidth"]; o(Ha.prototype, Hw), su({ type: "bar", render: function (t, e, i) { this._updateDrawMode(t); var n = t.get("coordinateSystem"); return ("cartesian2d" === n || "polar" === n) && (this._isLargeDraw ? this._renderLarge(t, e, i) : this._renderNormal(t, e, i)), this.group }, incrementalPrepareRender: function (t) { this._clear(), this._updateDrawMode(t) }, incrementalRender: function (t, e) { this._incrementalRenderLarge(t, e) }, _updateDrawMode: function (t) { var e = t.pipelineContext.large; (null == this._isLargeDraw || e ^ this._isLargeDraw) && (this._isLargeDraw = e, this._clear()) }, _renderNormal: function (t) { var e, i = this.group, n = t.getData(), r = this._data, a = t.coordinateSystem, o = a.getBaseAxis(); "cartesian2d" === a.type ? e = o.isHorizontal() : "polar" === a.type && (e = "angle" === o.dim); var s = t.isAnimationEnabled() ? t : null; n.diff(r).add(function (r) { if (n.hasValue(r)) { var o = n.getItemModel(r), l = Uw[a.type](n, r, o), u = Xw[a.type](n, r, o, l, e, s); n.setItemGraphicEl(r, u), i.add(u), nc(u, n, r, o, l, t, e, "polar" === a.type) } }).update(function (o, l) { var u = r.getItemGraphicEl(l); if (!n.hasValue(o)) return void i.remove(u); var h = n.getItemModel(o), c = Uw[a.type](n, o, h); u ? Oa(u, { shape: c }, s, o) : u = Xw[a.type](n, o, h, c, e, s, !0), n.setItemGraphicEl(o, u), i.add(u), nc(u, n, o, h, c, t, e, "polar" === a.type) }).remove(function (t) { var e = r.getItemGraphicEl(t); "cartesian2d" === a.type ? e && ec(t, s, e) : e && ic(t, s, e) }).execute(), this._data = n }, _renderLarge: function (t) { this._clear(), ac(t, this.group) }, _incrementalRenderLarge: function (t, e) { ac(e, this.group, !0) }, dispose: V, remove: function (t) { this._clear(t) }, _clear: function (t) { var e = this.group, i = this._data; t && t.get("animation") && i && !this._isLargeDraw ? i.eachItemGraphicEl(function (e) { "sector" === e.type ? ic(e.dataIndex, t, e) : ec(e.dataIndex, t, e) }) : e.removeAll(), this._data = null } }); var Xw = { cartesian2d: function (t, e, i, n, r, a, s) { var l = new by({ shape: o({}, n) }); if (a) { var u = l.shape, h = r ? "height" : "width", c = {}; u[h] = 0, c[h] = n[h], Vy[s ? "updateProps" : "initProps"](l, { shape: c }, a, e) } return l }, polar: function (t, e, i, n, r, a, o) { var l = n.startAngle < n.endAngle, u = new fy({ shape: s({ clockwise: l }, n) }); if (a) { var h = u.shape, c = r ? "r" : "endAngle", d = {}; h[c] = r ? 0 : n.startAngle, d[c] = n[c], Vy[o ? "updateProps" : "initProps"](u, { shape: d }, a, e) } return u } }, Uw = { cartesian2d: function (t, e, i) { var n = t.getItemLayout(e), r = rc(i, n), a = n.width > 0 ? 1 : -1, o = n.height > 0 ? 1 : -1; return { x: n.x + a * r / 2, y: n.y + o * r / 2, width: n.width - a * r, height: n.height - o * r } }, polar: function (t, e) { var i = t.getItemLayout(e); return { cx: i.cx, cy: i.cy, r0: i.r0, r: i.r, startAngle: i.startAngle, endAngle: i.endAngle } } }, jw = Nr.extend({ type: "largeBar", shape: { points: [] }, buildPath: function (t, e) { for (var i = e.points, n = this.__startPoint, r = this.__valueIdx, a = 0; a < i.length; a += 2)n[this.__valueIdx] = i[a + r], t.moveTo(n[0], n[1]), t.lineTo(i[a], i[a + 1]) } }), Yw = Math.PI, qw = function (t, e) { this.opt = e, this.axisModel = t, s(e, { labelOffset: 0, nameDirection: 1, tickDirection: 1, labelDirection: 1, silent: !0 }), this.group = new $g; var i = new $g({ position: e.position.slice(), rotation: e.rotation }); i.updateTransform(), this._transform = i.transform, this._dumbGroup = i }; qw.prototype = { constructor: qw, hasBuilder: function (t) { return !!Zw[t] }, add: function (t) { Zw[t].call(this) }, getGroup: function () { return this.group } }; var Zw = {
    axisLine: function () {
      var t = this.opt, e = this.axisModel; if (e.get("axisLine.show")) {
        var i = this.axisModel.axis.getExtent(), n = this._transform, r = [i[0], 0], a = [i[1], 0]; n && (ae(r, r, n), ae(a, a, n)); var s = o({ lineCap: "round" }, e.getModel("axisLine.lineStyle").getLineStyle()); this.group.add(new Sy(ra({ anid: "line", shape: { x1: r[0], y1: r[1], x2: a[0], y2: a[1] }, style: s, strokeContainThreshold: t.strokeContainThreshold || 5, silent: !0, z2: 1 }))); var l = e.get("axisLine.symbol"), u = e.get("axisLine.symbolSize"), h = e.get("axisLine.symbolOffset") || 0; if ("number" == typeof h && (h = [h, h]), null != l) {
        "string" == typeof l && (l = [l, l]), ("string" == typeof u || "number" == typeof u) && (u = [u, u]); var c = u[0], d = u[1]; f([{ rotate: t.rotation + Math.PI / 2, offset: h[0], r: 0 }, { rotate: t.rotation - Math.PI / 2, offset: h[1], r: Math.sqrt((r[0] - a[0]) * (r[0] - a[0]) + (r[1] - a[1]) * (r[1] - a[1])) }], function (e, i) {
          if ("none" !== l[i] && null != l[i]) {
            var n = vh(l[i], -c / 2, -d / 2, c, d, s.stroke, !0), a = e.r + e.offset, o = [r[0] + a * Math.cos(t.rotation), r[1] - a * Math.sin(t.rotation)];
            n.attr({ rotation: e.rotate, position: o, silent: !0, z2: 11 }), this.group.add(n)
          }
        }, this)
        }
      }
    }, axisTickLabel: function () { var t = this.axisModel, e = this.opt, i = pc(this, t, e), n = gc(this, t, e); hc(t, n, i) }, axisName: function () { var t = this.opt, e = this.axisModel, i = A(t.axisName, e.get("name")); if (i) { var n, r = e.get("nameLocation"), a = t.nameDirection, s = e.getModel("nameTextStyle"), l = e.get("nameGap") || 0, u = this.axisModel.axis.getExtent(), h = u[0] > u[1] ? -1 : 1, c = ["start" === r ? u[0] - h * l : "end" === r ? u[1] + h * l : (u[0] + u[1]) / 2, fc(r) ? t.labelOffset + a * l : 0], d = e.get("nameRotate"); null != d && (d = d * Yw / 180); var f; fc(r) ? n = Kw(t.rotation, null != d ? d : t.rotation, a) : (n = lc(t, r, d || 0, u), f = t.axisNameAvailableWidth, null != f && (f = Math.abs(f / Math.sin(n.rotation)), !isFinite(f) && (f = null))); var p = s.getFont(), g = e.get("nameTruncate", !0) || {}, m = g.ellipsis, v = A(t.nameTruncateMaxWidth, g.maxWidth, f), y = null != m && null != v ? nx(i, v, p, m, { minChar: 2, placeholder: g.placeholder }) : i, x = e.get("tooltip", !0), _ = e.mainType, b = { componentType: _, name: i, $vars: ["name"] }; b[_ + "Index"] = e.componentIndex; var w = new uy({ anid: "name", __fullText: i, __truncatedText: y, position: c, rotation: n.rotation, silent: uc(e), z2: 1, tooltip: x && x.show ? o({ content: i, formatter: function () { return i }, formatterParams: b }, x) : null }); Sa(w.style, s, { text: y, textFont: p, textFill: s.getTextColor() || e.get("axisLine.lineStyle.color"), textAlign: n.textAlign, textVerticalAlign: n.textVerticalAlign }), e.get("triggerEvent") && (w.eventData = sc(e), w.eventData.targetType = "axisName", w.eventData.name = i), this._dumbGroup.add(w), w.updateTransform(), this.group.add(w), w.decomposeTransform() } }
  }, Kw = qw.innerTextLayout = function (t, e, i) { var n, r, a = no(e - t); return ro(a) ? (r = i > 0 ? "top" : "bottom", n = "center") : ro(a - Yw) ? (r = i > 0 ? "bottom" : "top", n = "center") : (r = "middle", n = a > 0 && Yw > a ? i > 0 ? "right" : "left" : i > 0 ? "left" : "right"), { rotation: a, textAlign: n, textVerticalAlign: r } }, $w = f, Qw = x, Jw = au({ type: "axis", _axisPointer: null, axisPointerClass: null, render: function (t, e, i, n) { this.axisPointerClass && wc(t), Jw.superApply(this, "render", arguments), Tc(this, t, e, i, n, !0) }, updateAxisPointer: function (t, e, i, n) { Tc(this, t, e, i, n, !1) }, remove: function (t, e) { var i = this._axisPointer; i && i.remove(e), Jw.superApply(this, "remove", arguments) }, dispose: function (t, e) { Ac(this, e), Jw.superApply(this, "dispose", arguments) } }), tS = []; Jw.registerAxisPointerClass = function (t, e) { tS[t] = e }, Jw.getAxisPointerClass = function (t) { return t && tS[t] }; var eS = ["axisLine", "axisTickLabel", "axisName"], iS = ["splitArea", "splitLine"], nS = Jw.extend({ type: "cartesianAxis", axisPointerClass: "CartesianAxisPointer", render: function (t, e, i, n) { this.group.removeAll(); var r = this._axisGroup; if (this._axisGroup = new $g, this.group.add(this._axisGroup), t.get("show")) { var a = t.getCoordSysModel(), o = Cc(a, t), s = new qw(t, o); f(eS, s.add, s), this._axisGroup.add(s.getGroup()), f(iS, function (e) { t.get(e + ".show") && this["_" + e](t, a) }, this), Na(r, this._axisGroup, t), nS.superCall(this, "render", t, e, i, n) } }, remove: function () { this._splitAreaColors = null }, _splitLine: function (t, e) { var i = t.axis; if (!i.scale.isBlank()) { var n = t.getModel("splitLine"), r = n.getModel("lineStyle"), a = r.get("color"); a = _(a) ? a : [a]; for (var o = e.coordinateSystem.getRect(), l = i.isHorizontal(), u = 0, h = i.getTicksCoords({ tickModel: n }), c = [], d = [], f = r.getLineStyle(), p = 0; p < h.length; p++) { var g = i.toGlobalCoord(h[p].coord); l ? (c[0] = g, c[1] = o.y, d[0] = g, d[1] = o.y + o.height) : (c[0] = o.x, c[1] = g, d[0] = o.x + o.width, d[1] = g); var m = u++ % a.length, v = h[p].tickValue; this._axisGroup.add(new Sy(ra({ anid: null != v ? "line_" + h[p].tickValue : null, shape: { x1: c[0], y1: c[1], x2: d[0], y2: d[1] }, style: s({ stroke: a[m] }, f), silent: !0 }))) } } }, _splitArea: function (t, e) { var i = t.axis; if (!i.scale.isBlank()) { var n = t.getModel("splitArea"), r = n.getModel("areaStyle"), a = r.get("color"), o = e.coordinateSystem.getRect(), l = i.getTicksCoords({ tickModel: n, clamp: !0 }); if (l.length) { var u = a.length, h = this._splitAreaColors, c = N(), d = 0; if (h) for (var f = 0; f < l.length; f++) { var p = h.get(l[f].tickValue); if (null != p) { d = (p + (u - 1) * f) % u; break } } var g = i.toGlobalCoord(l[0].coord), m = r.getAreaStyle(); a = _(a) ? a : [a]; for (var f = 1; f < l.length; f++) { var v, y, x, b, w = i.toGlobalCoord(l[f].coord); i.isHorizontal() ? (v = g, y = o.y, x = w - v, b = o.height, g = v + x) : (v = o.x, y = g, x = o.width, b = w - y, g = y + b); var S = l[f - 1].tickValue; null != S && c.set(S, d), this._axisGroup.add(new by({ anid: null != S ? "area_" + S : null, shape: { x: v, y: y, width: x, height: b }, style: s({ fill: a[d] }, m), silent: !0 })), d = (d + 1) % u } this._splitAreaColors = c } } } }); nS.extend({ type: "xAxis" }), nS.extend({ type: "yAxis" }), au({ type: "grid", render: function (t) { this.group.removeAll(), t.get("show") && this.group.add(new by({ shape: t.coordinateSystem.getRect(), style: s({ fill: t.get("backgroundColor") }, t.getItemStyle()), silent: !0, z2: -1 })) } }), ql(function (t) { t.xAxis && t.yAxis && !t.grid && (t.grid = {}) }), tu(x(th, "bar")), tu(Ub), eu({ seriesType: "bar", reset: function (t) { t.getData().setVisual("legendSymbol", "roundRect") } }), Jx.extend({ type: "series.line", dependencies: ["grid", "polar"], getInitialData: function () { return Bu(this.getSource(), this) }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "cartesian2d", legendHoverLink: !0, hoverAnimation: !0, clipOverflow: !0, label: { position: "top" }, lineStyle: { width: 2, type: "solid" }, step: !1, smooth: !1, smoothMonotone: null, symbol: "emptyCircle", symbolSize: 4, symbolRotate: null, showSymbol: !0, showAllSymbol: "auto", connectNulls: !1, sampling: "none", animationEasing: "linear", progressive: 0, hoverLayerThreshold: 1 / 0 } }); var rS = kc.prototype, aS = kc.getSymbolSize = function (t, e) { var i = t.getItemVisual(e, "symbolSize"); return i instanceof Array ? i.slice() : [+i, +i] }; rS._createSymbol = function (t, e, i, n, r) { this.removeAll(); var a = e.getItemVisual(i, "color"), o = vh(t, -1, -1, 2, 2, a, r); o.attr({ z2: 100, culling: !0, scale: Pc(n) }), o.drift = Lc, this._symbolType = t, this.add(o) }, rS.stopSymbolAnimation = function (t) { this.childAt(0).stopAnimation(t) }, rS.getSymbolPath = function () { return this.childAt(0) }, rS.getScale = function () { return this.childAt(0).scale }, rS.highlight = function () { this.childAt(0).trigger("emphasis") }, rS.downplay = function () { this.childAt(0).trigger("normal") }, rS.setZ = function (t, e) { var i = this.childAt(0); i.zlevel = t, i.z = e }, rS.setDraggable = function (t) { var e = this.childAt(0); e.draggable = t, e.cursor = t ? "move" : "pointer" }, rS.updateData = function (t, e, i) { this.silent = !1; var n = t.getItemVisual(e, "symbol") || "circle", r = t.hostModel, a = aS(t, e), o = n !== this._symbolType; if (o) { var s = t.getItemVisual(e, "symbolKeepAspect"); this._createSymbol(n, t, e, a, s) } else { var l = this.childAt(0); l.silent = !1, Oa(l, { scale: Pc(a) }, r, e) } if (this._updateCommon(t, e, a, i), o) { var l = this.childAt(0), u = i && i.fadeIn, h = { scale: l.scale.slice() }; u && (h.style = { opacity: l.style.opacity }), l.scale = [0, 0], u && (l.style.opacity = 0), za(l, h, r, e) } this._seriesModel = r }; var oS = ["itemStyle"], sS = ["emphasis", "itemStyle"], lS = ["label"], uS = ["emphasis", "label"]; rS._updateCommon = function (t, e, i, n) { function r(e) { return w ? t.getName(e) : Qh(t, e) } var a = this.childAt(0), s = t.hostModel, l = t.getItemVisual(e, "color"); "image" !== a.type && a.useStyle({ strokeNoScale: !0 }); var u = n && n.itemStyle, h = n && n.hoverItemStyle, c = n && n.symbolRotate, d = n && n.symbolOffset, f = n && n.labelModel, p = n && n.hoverLabelModel, g = n && n.hoverAnimation, m = n && n.cursorStyle; if (!n || t.hasItemOption) { var v = n && n.itemModel ? n.itemModel : t.getItemModel(e); u = v.getModel(oS).getItemStyle(["color"]), h = v.getModel(sS).getItemStyle(), c = v.getShallow("symbolRotate"), d = v.getShallow("symbolOffset"), f = v.getModel(lS), p = v.getModel(uS), g = v.getShallow("hoverAnimation"), m = v.getShallow("cursor") } else h = o({}, h); var y = a.style; a.attr("rotation", (c || 0) * Math.PI / 180 || 0), d && a.attr("position", [Ka(d[0], i[0]), Ka(d[1], i[1])]), m && a.attr("cursor", m), a.setColor(l, n && n.symbolInnerColor), a.setStyle(u); var x = t.getItemVisual(e, "opacity"); null != x && (y.opacity = x); var _ = t.getItemVisual(e, "liftZ"), b = a.__z2Origin; null != _ ? null == b && (a.__z2Origin = a.z2, a.z2 += _) : null != b && (a.z2 = b, a.__z2Origin = null); var w = n && n.useNameLabel; wa(y, h, f, p, { labelFetcher: s, labelDataIndex: e, defaultText: r, isRectText: !0, autoColor: l }), a.off("mouseover").off("mouseout").off("emphasis").off("normal"), a.hoverStyle = h, _a(a), a.__symbolOriginalScale = Pc(i), g && s.isAnimationEnabled() && a.on("mouseover", Oc).on("mouseout", zc).on("emphasis", Ec).on("normal", Bc) }, rS.fadeOut = function (t, e) { var i = this.childAt(0); this.silent = i.silent = !0, !(e && e.keepLabel) && (i.style.text = null), Oa(i, { style: { opacity: 0 }, scale: [0, 0] }, this._seriesModel, this.dataIndex, t) }, h(kc, $g); var hS = Rc.prototype; hS.updateData = function (t, e) { e = Fc(e); var i = this.group, n = t.hostModel, r = this._data, a = this._symbolCtor, o = Vc(t); r || i.removeAll(), t.diff(r).add(function (n) { var r = t.getItemLayout(n); if (Nc(t, r, n, e)) { var s = new a(t, n, o); s.attr("position", r), t.setItemGraphicEl(n, s), i.add(s) } }).update(function (s, l) { var u = r.getItemGraphicEl(l), h = t.getItemLayout(s); return Nc(t, h, s, e) ? (u ? (u.updateData(t, s, o), Oa(u, { position: h }, n)) : (u = new a(t, s), u.attr("position", h)), i.add(u), void t.setItemGraphicEl(s, u)) : void i.remove(u) }).remove(function (t) { var e = r.getItemGraphicEl(t); e && e.fadeOut(function () { i.remove(e) }) }).execute(), this._data = t }, hS.isPersistent = function () { return !0 }, hS.updateLayout = function () { var t = this._data; t && t.eachItemGraphicEl(function (e, i) { var n = t.getItemLayout(i); e.attr("position", n) }) }, hS.incrementalPrepareUpdate = function (t) { this._seriesScope = Vc(t), this._data = null, this.group.removeAll() }, hS.incrementalUpdate = function (t, e, i) { function n(t) { t.isGroup || (t.incremental = t.useHoverLayer = !0) } i = Fc(i); for (var r = t.start; r < t.end; r++) { var a = e.getItemLayout(r); if (Nc(e, a, r, i)) { var o = new this._symbolCtor(e, r, this._seriesScope); o.traverse(n), o.attr("position", a), this.group.add(o), e.setItemGraphicEl(r, o) } } }, hS.remove = function (t) { var e = this.group, i = this._data; i && t ? i.eachItemGraphicEl(function (t) { t.fadeOut(function () { e.remove(t) }) }) : e.removeAll() }; var cS = function (t, e, i, n, r, a, o, s) { for (var l = Xc(t, e), u = [], h = [], c = [], d = [], f = [], p = [], g = [], m = Gc(r, e, o), v = Gc(a, t, s), y = 0; y < l.length; y++) { var x = l[y], _ = !0; switch (x.cmd) { case "=": var b = t.getItemLayout(x.idx), w = e.getItemLayout(x.idx1); (isNaN(b[0]) || isNaN(b[1])) && (b = w.slice()), u.push(b), h.push(w), c.push(i[x.idx]), d.push(n[x.idx1]), g.push(e.getRawIndex(x.idx1)); break; case "+": var S = x.idx; u.push(r.dataToPoint([e.get(m.dataDimsForPoint[0], S), e.get(m.dataDimsForPoint[1], S)])), h.push(e.getItemLayout(S).slice()), c.push(Wc(m, r, e, S)), d.push(n[S]), g.push(e.getRawIndex(S)); break; case "-": var S = x.idx, M = t.getRawIndex(S); M !== S ? (u.push(t.getItemLayout(S)), h.push(a.dataToPoint([t.get(v.dataDimsForPoint[0], S), t.get(v.dataDimsForPoint[1], S)])), c.push(i[S]), d.push(Wc(v, a, t, S)), g.push(M)) : _ = !1 }_ && (f.push(x), p.push(p.length)) } p.sort(function (t, e) { return g[t] - g[e] }); for (var I = [], D = [], T = [], A = [], C = [], y = 0; y < p.length; y++) { var S = p[y]; I[y] = u[S], D[y] = h[S], T[y] = c[S], A[y] = d[S], C[y] = f[S] } return { current: I, next: D, stackedOnCurrent: T, stackedOnNext: A, status: C } }, dS = oe, fS = se, pS = j, gS = H, mS = [], vS = [], yS = [], xS = Nr.extend({ type: "ec-polyline", shape: { points: [], smooth: 0, smoothConstraint: !0, smoothMonotone: null, connectNulls: !1 }, style: { fill: null, stroke: "#000" }, brush: dy(Nr.prototype.brush), buildPath: function (t, e) { var i = e.points, n = 0, r = i.length, a = Zc(i, e.smoothConstraint); if (e.connectNulls) { for (; r > 0 && Uc(i[r - 1]); r--); for (; r > n && Uc(i[n]); n++); } for (; r > n;)n += jc(t, i, n, r, r, 1, a.min, a.max, e.smooth, e.smoothMonotone, e.connectNulls) + 1 } }), _S = Nr.extend({ type: "ec-polygon", shape: { points: [], stackedOnPoints: [], smooth: 0, stackedOnSmooth: 0, smoothConstraint: !0, smoothMonotone: null, connectNulls: !1 }, brush: dy(Nr.prototype.brush), buildPath: function (t, e) { var i = e.points, n = e.stackedOnPoints, r = 0, a = i.length, o = e.smoothMonotone, s = Zc(i, e.smoothConstraint), l = Zc(n, e.smoothConstraint); if (e.connectNulls) { for (; a > 0 && Uc(i[a - 1]); a--); for (; a > r && Uc(i[r]); r++); } for (; a > r;) { var u = jc(t, i, r, a, a, 1, s.min, s.max, e.smooth, o, e.connectNulls); jc(t, n, r + u - 1, u, a, -1, l.min, l.max, e.stackedOnSmooth, o, e.connectNulls), r += u + 1, t.closePath() } } }); Vs.extend({ type: "line", init: function () { var t = new $g, e = new Rc; this.group.add(e.group), this._symbolDraw = e, this._lineGroup = t }, render: function (t, e, i) { var n = t.coordinateSystem, r = this.group, a = t.getData(), o = t.getModel("lineStyle"), l = t.getModel("areaStyle"), u = a.mapArray(a.getItemLayout), h = "polar" === n.type, c = this._coordSys, d = this._symbolDraw, f = this._polyline, p = this._polygon, g = this._lineGroup, m = t.get("animation"), v = !l.isEmpty(), y = l.get("origin"), x = Gc(n, a, y), _ = Jc(n, a, x), b = t.get("showSymbol"), w = b && !h && ad(t, a, n), S = this._data; S && S.eachItemGraphicEl(function (t, e) { t.__temp && (r.remove(t), S.setItemGraphicEl(e, null)) }), b || d.remove(), r.add(g); var M = !h && t.get("step"); f && c.type === n.type && M === this._step ? (v && !p ? p = this._newPolygon(u, _, n, m) : p && !v && (g.remove(p), p = this._polygon = null), g.setClipPath(id(n, !1, !1, t)), b && d.updateData(a, { isIgnore: w, clipShape: id(n, !1, !0, t) }), a.eachItemGraphicEl(function (t) { t.stopAnimation(!0) }), Kc(this._stackedOnPoints, _) && Kc(this._points, u) || (m ? this._updateAnimation(a, _, n, i, M, y) : (M && (u = nd(u, n, M), _ = nd(_, n, M)), f.setShape({ points: u }), p && p.setShape({ points: u, stackedOnPoints: _ })))) : (b && d.updateData(a, { isIgnore: w, clipShape: id(n, !1, !0, t) }), M && (u = nd(u, n, M), _ = nd(_, n, M)), f = this._newPolyline(u, n, m), v && (p = this._newPolygon(u, _, n, m)), g.setClipPath(id(n, !0, !1, t))); var I = rd(a, n) || a.getVisual("color"); f.useStyle(s(o.getLineStyle(), { fill: "none", stroke: I, lineJoin: "bevel" })); var D = t.get("smooth"); if (D = $c(t.get("smooth")), f.setShape({ smooth: D, smoothMonotone: t.get("smoothMonotone"), connectNulls: t.get("connectNulls") }), p) { var T = a.getCalculationInfo("stackedOnSeries"), A = 0; p.useStyle(s(l.getAreaStyle(), { fill: I, opacity: .7, lineJoin: "bevel" })), T && (A = $c(T.get("smooth"))), p.setShape({ smooth: D, stackedOnSmooth: A, smoothMonotone: t.get("smoothMonotone"), connectNulls: t.get("connectNulls") }) } this._data = a, this._coordSys = n, this._stackedOnPoints = _, this._points = u, this._step = M, this._valueOrigin = y }, dispose: function () { }, highlight: function (t, e, i, n) { var r = t.getData(), a = Xn(r, n); if (!(a instanceof Array) && null != a && a >= 0) { var o = r.getItemGraphicEl(a); if (!o) { var s = r.getItemLayout(a); if (!s) return; o = new kc(r, a), o.position = s, o.setZ(t.get("zlevel"), t.get("z")), o.ignore = isNaN(s[0]) || isNaN(s[1]), o.__temp = !0, r.setItemGraphicEl(a, o), o.stopSymbolAnimation(!0), this.group.add(o) } o.highlight() } else Vs.prototype.highlight.call(this, t, e, i, n) }, downplay: function (t, e, i, n) { var r = t.getData(), a = Xn(r, n); if (null != a && a >= 0) { var o = r.getItemGraphicEl(a); o && (o.__temp ? (r.setItemGraphicEl(a, null), this.group.remove(o)) : o.downplay()) } else Vs.prototype.downplay.call(this, t, e, i, n) }, _newPolyline: function (t) { var e = this._polyline; return e && this._lineGroup.remove(e), e = new xS({ shape: { points: t }, silent: !0, z2: 10 }), this._lineGroup.add(e), this._polyline = e, e }, _newPolygon: function (t, e) { var i = this._polygon; return i && this._lineGroup.remove(i), i = new _S({ shape: { points: t, stackedOnPoints: e }, silent: !0 }), this._lineGroup.add(i), this._polygon = i, i }, _updateAnimation: function (t, e, i, n, r, a) { var o = this._polyline, s = this._polygon, l = t.hostModel, u = cS(this._data, t, this._stackedOnPoints, e, this._coordSys, i, this._valueOrigin, a), h = u.current, c = u.stackedOnCurrent, d = u.next, f = u.stackedOnNext; r && (h = nd(u.current, i, r), c = nd(u.stackedOnCurrent, i, r), d = nd(u.next, i, r), f = nd(u.stackedOnNext, i, r)), o.shape.__points = u.current, o.shape.points = h, Oa(o, { shape: { points: d } }, l), s && (s.setShape({ points: h, stackedOnPoints: c }), Oa(s, { shape: { points: d, stackedOnPoints: f } }, l)); for (var p = [], g = u.status, m = 0; m < g.length; m++) { var v = g[m].cmd; if ("=" === v) { var y = t.getItemGraphicEl(g[m].idx1); y && p.push({ el: y, ptIdx: m }) } } o.animators && o.animators.length && o.animators[0].during(function () { for (var t = 0; t < p.length; t++) { var e = p[t].el; e.attr("position", o.shape.__points[p[t].ptIdx]) } }) }, remove: function () { var t = this.group, e = this._data; this._lineGroup.removeAll(), this._symbolDraw.remove(!0), e && e.eachItemGraphicEl(function (i, n) { i.__temp && (t.remove(i), e.setItemGraphicEl(n, null)) }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null } }); var bS = function (t, e, i) { return { seriesType: t, performRawSeries: !0, reset: function (t, n) { function r(e, i) { if ("function" == typeof s) { var n = t.getRawValue(i), r = t.getDataParams(i); e.setItemVisual(i, "symbolSize", s(n, r)) } if (e.hasItemOption) { var a = e.getItemModel(i), o = a.getShallow("symbol", !0), l = a.getShallow("symbolSize", !0), u = a.getShallow("symbolKeepAspect", !0); null != o && e.setItemVisual(i, "symbol", o), null != l && e.setItemVisual(i, "symbolSize", l), null != u && e.setItemVisual(i, "symbolKeepAspect", u) } } var a = t.getData(), o = t.get("symbol") || e, s = t.get("symbolSize"), l = t.get("symbolKeepAspect"); if (a.setVisual({ legendSymbol: i || o, symbol: o, symbolSize: s, symbolKeepAspect: l }), !n.isSeriesFiltered(t)) { var u = "function" == typeof s; return { dataEach: a.hasItemOption || u ? r : null } } } } }, wS = function (t) { return { seriesType: t, plan: i_(), reset: function (t) { function e(t, e) { for (var i = t.end - t.start, r = a && new Float32Array(i * s), l = t.start, u = 0, h = [], c = []; l < t.end; l++) { var d; if (1 === s) { var f = e.get(o[0], l); d = !isNaN(f) && n.dataToPoint(f, null, c) } else { var f = h[0] = e.get(o[0], l), p = h[1] = e.get(o[1], l); d = !isNaN(f) && !isNaN(p) && n.dataToPoint(h, null, c) } a ? (r[u++] = d ? d[0] : 0 / 0, r[u++] = d ? d[1] : 0 / 0) : e.setItemLayout(l, d && d.slice() || [0 / 0, 0 / 0]) } a && e.setLayout("symbolPoints", r) } var i = t.getData(), n = t.coordinateSystem, r = t.pipelineContext, a = r.large; if (n) { var o = p(n.dimensions, function (t) { return i.mapDimension(t) }).slice(0, 2), s = o.length, l = i.getCalculationInfo("stackResultDimension"); return zu(i, o[0]) && (o[0] = l), zu(i, o[1]) && (o[1] = l), s && { progress: e } } } } }, SS = { average: function (t) { for (var e = 0, i = 0, n = 0; n < t.length; n++)isNaN(t[n]) || (e += t[n], i++); return 0 === i ? 0 / 0 : e / i }, sum: function (t) { for (var e = 0, i = 0; i < t.length; i++)e += t[i] || 0; return e }, max: function (t) { for (var e = -1 / 0, i = 0; i < t.length; i++)t[i] > e && (e = t[i]); return isFinite(e) ? e : 0 / 0 }, min: function (t) { for (var e = 1 / 0, i = 0; i < t.length; i++)t[i] < e && (e = t[i]); return isFinite(e) ? e : 0 / 0 }, nearest: function (t) { return t[0] } }, MS = function (t) { return Math.round(t.length / 2) }, IS = function (t) { return { seriesType: t, modifyOutputEnd: !0, reset: function (t) { var e = t.getData(), i = t.get("sampling"), n = t.coordinateSystem; if ("cartesian2d" === n.type && i) { var r = n.getBaseAxis(), a = n.getOtherAxis(r), o = r.getExtent(), s = o[1] - o[0], l = Math.round(e.count() / s); if (l > 1) { var u; "string" == typeof i ? u = SS[i] : "function" == typeof i && (u = i), u && t.setData(e.downSample(e.mapDimension(a.dim), 1 / l, u, MS)) } } } } }; eu(bS("line", "circle", "line")), tu(wS("line")), Zl(J_.PROCESSOR.STATISTIC, IS("line")); var DS = function (t, e, i) { e = _(e) && { coordDimensions: e } || o({}, e); var n = t.getSource(), r = Eb(n, e), a = new Lb(r, t); return a.initData(n, i), a }, TS = { updateSelectedMap: function (t) { this._targetList = _(t) ? t.slice() : [], this._selectTargetMap = g(t || [], function (t, e) { return t.set(e.name, e), t }, N()) }, select: function (t, e) { var i = null != e ? this._targetList[e] : this._selectTargetMap.get(t), n = this.get("selectedMode"); "single" === n && this._selectTargetMap.each(function (t) { t.selected = !1 }), i && (i.selected = !0) }, unSelect: function (t, e) { var i = null != e ? this._targetList[e] : this._selectTargetMap.get(t); i && (i.selected = !1) }, toggleSelected: function (t, e) { var i = null != e ? this._targetList[e] : this._selectTargetMap.get(t); return null != i ? (this[i.selected ? "unSelect" : "select"](t, e), i.selected) : void 0 }, isSelected: function (t, e) { var i = null != e ? this._targetList[e] : this._selectTargetMap.get(t); return i && i.selected } }, AS = ou({ type: "series.pie", init: function (t) { AS.superApply(this, "init", arguments), this.legendDataProvider = function () { return this.getRawData() }, this.updateSelectedMap(this._createSelectableList()), this._defaultLabelLine(t) }, mergeOption: function (t) { AS.superCall(this, "mergeOption", t), this.updateSelectedMap(this._createSelectableList()) }, getInitialData: function () { return DS(this, ["value"]) }, _createSelectableList: function () { for (var t = this.getRawData(), e = t.mapDimension("value"), i = [], n = 0, r = t.count(); r > n; n++)i.push({ name: t.getName(n), value: t.get(e, n), selected: Ts(t, n, "selected") }); return i }, getDataParams: function (t) { var e = this.getData(), i = AS.superCall(this, "getDataParams", t), n = []; return e.each(e.mapDimension("value"), function (t) { n.push(t) }), i.percent = io(n, t, e.hostModel.get("percentPrecision")), i.$vars.push("percent"), i }, _defaultLabelLine: function (t) { Rn(t, "labelLine", ["show"]); var e = t.labelLine, i = t.emphasis.labelLine; e.show = e.show && t.label.show, i.show = i.show && t.emphasis.label.show }, defaultOption: { zlevel: 0, z: 2, legendHoverLink: !0, hoverAnimation: !0, center: ["50%", "50%"], radius: [0, "75%"], clockwise: !0, startAngle: 90, minAngle: 0, selectedOffset: 10, hoverOffset: 10, avoidLabelOverlap: !0, percentPrecision: 2, stillShowZeroSum: !0, label: { rotate: !1, show: !0, position: "outer" }, labelLine: { show: !0, length: 15, length2: 15, smooth: !1, lineStyle: { width: 1, type: "solid" } }, itemStyle: { borderWidth: 1 }, animationType: "expansion", animationEasing: "cubicOut" } }); c(AS, TS); var CS = ud.prototype; CS.updateData = function (t, e, i) { function n() { a.stopAnimation(!0), a.animateTo({ shape: { r: h.r + l.get("hoverOffset") } }, 300, "elasticOut") } function r() { a.stopAnimation(!0), a.animateTo({ shape: { r: h.r } }, 300, "elasticOut") } var a = this.childAt(0), l = t.hostModel, u = t.getItemModel(e), h = t.getItemLayout(e), c = o({}, h); if (c.label = null, i) { a.setShape(c); var d = l.getShallow("animationType"); "scale" === d ? (a.shape.r = h.r0, za(a, { shape: { r: h.r } }, l, e)) : (a.shape.endAngle = h.startAngle, Oa(a, { shape: { endAngle: h.endAngle } }, l, e)) } else Oa(a, { shape: c }, l, e); var f = t.getItemVisual(e, "color"); a.useStyle(s({ lineJoin: "bevel", fill: f }, u.getModel("itemStyle").getItemStyle())), a.hoverStyle = u.getModel("emphasis.itemStyle").getItemStyle(); var p = u.getShallow("cursor"); p && a.attr("cursor", p), ld(this, t.getItemLayout(e), l.isSelected(null, e), l.get("selectedOffset"), l.get("animation")), a.off("mouseover").off("mouseout").off("emphasis").off("normal"), u.get("hoverAnimation") && l.isAnimationEnabled() && a.on("mouseover", n).on("mouseout", r).on("emphasis", n).on("normal", r), this._updateLabel(t, e), _a(this) }, CS._updateLabel = function (t, e) { var i = this.childAt(1), n = this.childAt(2), r = t.hostModel, a = t.getItemModel(e), o = t.getItemLayout(e), s = o.label, l = t.getItemVisual(e, "color"); Oa(i, { shape: { points: s.linePoints || [[s.x, s.y], [s.x, s.y], [s.x, s.y]] } }, r, e), Oa(n, { style: { x: s.x, y: s.y } }, r, e), n.attr({ rotation: s.rotation, origin: [s.x, s.y], z2: 10 }); var u = a.getModel("label"), h = a.getModel("emphasis.label"), c = a.getModel("labelLine"), d = a.getModel("emphasis.labelLine"), l = t.getItemVisual(e, "color"); wa(n.style, n.hoverStyle = {}, u, h, { labelFetcher: t.hostModel, labelDataIndex: e, defaultText: t.getName(e), autoColor: l, useInsideStyle: !!s.inside }, { textAlign: s.textAlign, textVerticalAlign: s.verticalAlign, opacity: t.getItemVisual(e, "opacity") }), n.ignore = n.normalIgnore = !u.get("show"), n.hoverIgnore = !h.get("show"), i.ignore = i.normalIgnore = !c.get("show"), i.hoverIgnore = !d.get("show"), i.setStyle({ stroke: l, opacity: t.getItemVisual(e, "opacity") }), i.setStyle(c.getModel("lineStyle").getLineStyle()), i.hoverStyle = d.getModel("lineStyle").getLineStyle(); var f = c.get("smooth"); f && f === !0 && (f = .4), i.setShape({ smooth: f }) }, h(ud, $g); var kS = (Vs.extend({ type: "pie", init: function () { var t = new $g; this._sectorGroup = t }, render: function (t, e, i, n) { if (!n || n.from !== this.uid) { var r = t.getData(), a = this._data, o = this.group, s = e.get("animation"), l = !a, u = t.get("animationType"), h = x(sd, this.uid, t, s, i), c = t.get("selectedMode"); if (r.diff(a).add(function (t) { var e = new ud(r, t); l && "scale" !== u && e.eachChild(function (t) { t.stopAnimation(!0) }), c && e.on("click", h), r.setItemGraphicEl(t, e), o.add(e) }).update(function (t, e) { var i = a.getItemGraphicEl(e); i.updateData(r, t), i.off("click"), c && i.on("click", h), o.add(i), r.setItemGraphicEl(t, i) }).remove(function (t) { var e = a.getItemGraphicEl(t); o.remove(e) }).execute(), s && l && r.count() > 0 && "scale" !== u) { var d = r.getItemLayout(0), f = Math.max(i.getWidth(), i.getHeight()) / 2, p = y(o.removeClipPath, o); o.setClipPath(this._createClipPath(d.cx, d.cy, f, d.startAngle, d.clockwise, p, t)) } else o.removeClipPath(); this._data = r } }, dispose: function () { }, _createClipPath: function (t, e, i, n, r, a, o) { var s = new fy({ shape: { cx: t, cy: e, r0: 0, r: i, startAngle: n, endAngle: n, clockwise: r } }); return za(s, { shape: { endAngle: n + (r ? 1 : -1) * Math.PI * 2 } }, o, a), s }, containPoint: function (t, e) { var i = e.getData(), n = i.getItemLayout(0); if (n) { var r = t[0] - n.cx, a = t[1] - n.cy, o = Math.sqrt(r * r + a * a); return o <= n.r && o >= n.r0 } } }), function (t, e) { f(e, function (e) { e.update = "updateView", $l(e, function (i, n) { var r = {}; return n.eachComponent({ mainType: "series", subType: t, query: i }, function (t) { t[e.method] && t[e.method](i.name, i.dataIndex); var n = t.getData(); n.each(function (e) { var i = n.getName(e); r[i] = t.isSelected(i) || !1 }) }), { name: i.name, selected: r } }) }) }), PS = function (t) { return { getTargetSeries: function (e) { var i = {}, n = N(); return e.eachSeriesByType(t, function (t) { t.__paletteScope = i, n.set(t.uid, t) }), n }, reset: function (t) { var e = t.getRawData(), i = {}, n = t.getData(); n.each(function (t) { var e = n.getRawIndex(t); i[e] = t }), e.each(function (r) { var a = i[r], o = null != a && n.getItemVisual(a, "color", !0); if (o) e.setItemVisual(r, "color", o); else { var s = e.getItemModel(r), l = s.get("itemStyle.color") || t.getColorFromPalette(e.getName(r) || r + "", t.__paletteScope, e.count()); e.setItemVisual(r, "color", l), null != a && n.setItemVisual(a, "color", l) } }) } } }, LS = function (t, e, i, n) { var r, a, o = t.getData(), s = [], l = !1; o.each(function (i) { var n, u, h, c, d = o.getItemLayout(i), f = o.getItemModel(i), p = f.getModel("label"), g = p.get("position") || f.get("emphasis.label.position"), m = f.getModel("labelLine"), v = m.get("length"), y = m.get("length2"), x = (d.startAngle + d.endAngle) / 2, _ = Math.cos(x), b = Math.sin(x); r = d.cx, a = d.cy; var w = "inside" === g || "inner" === g; if ("center" === g) n = d.cx, u = d.cy, c = "center"; else { var S = (w ? (d.r + d.r0) / 2 * _ : d.r * _) + r, M = (w ? (d.r + d.r0) / 2 * b : d.r * b) + a; if (n = S + 3 * _, u = M + 3 * b, !w) { var I = S + _ * (v + e - d.r), D = M + b * (v + e - d.r), T = I + (0 > _ ? -1 : 1) * y, A = D; n = T + (0 > _ ? -5 : 5), u = A, h = [[S, M], [I, D], [T, A]] } c = w ? "center" : _ > 0 ? "left" : "right" } var C = p.getFont(), k = p.get("rotate") ? 0 > _ ? -x + Math.PI : -x : 0, P = t.getFormattedLabel(i, "normal") || o.getName(i), L = Bi(P, C, c, "top"); l = !!k, d.label = { x: n, y: u, position: g, height: L.height, len: v, len2: y, linePoints: h, textAlign: c, verticalAlign: "middle", rotation: k, inside: w }, w || s.push(d.label) }), !l && t.get("avoidLabelOverlap") && cd(s, r, a, e, i, n) }, OS = 2 * Math.PI, zS = Math.PI / 180, ES = function (t, e, i) { e.eachSeriesByType(t, function (t) { var e = t.getData(), n = e.mapDimension("value"), r = t.get("center"), a = t.get("radius"); _(a) || (a = [0, a]), _(r) || (r = [r, r]); var o = i.getWidth(), s = i.getHeight(), l = Math.min(o, s), u = Ka(r[0], o), h = Ka(r[1], s), c = Ka(a[0], l / 2), d = Ka(a[1], l / 2), f = -t.get("startAngle") * zS, p = t.get("minAngle") * zS, g = 0; e.each(n, function (t) { !isNaN(t) && g++ }); var m = e.getSum(n), v = Math.PI / (m || g) * 2, y = t.get("clockwise"), x = t.get("roseType"), b = t.get("stillShowZeroSum"), w = e.getDataExtent(n); w[0] = 0; var S = OS, M = 0, I = f, D = y ? 1 : -1; if (e.each(n, function (t, i) { var n; if (isNaN(t)) return void e.setItemLayout(i, { angle: 0 / 0, startAngle: 0 / 0, endAngle: 0 / 0, clockwise: y, cx: u, cy: h, r0: c, r: x ? 0 / 0 : d }); n = "area" !== x ? 0 === m && b ? v : t * v : OS / g, p > n ? (n = p, S -= p) : M += t; var r = I + D * n; e.setItemLayout(i, { angle: n, startAngle: I, endAngle: r, clockwise: y, cx: u, cy: h, r0: c, r: x ? Za(t, w, [c, d]) : d }), I = r }), OS > S && g) if (.001 >= S) { var T = OS / g; e.each(n, function (t, i) { if (!isNaN(t)) { var n = e.getItemLayout(i); n.angle = T, n.startAngle = f + D * i * T, n.endAngle = f + D * (i + 1) * T } }) } else v = S / M, I = f, e.each(n, function (t, i) { if (!isNaN(t)) { var n = e.getItemLayout(i), r = n.angle === p ? p : t * v; n.startAngle = I, n.endAngle = I + D * r, I += D * r } }); LS(t, d, o, s) }) }, BS = function (t) { return { seriesType: t, reset: function (t, e) { var i = e.findComponents({ mainType: "legend" }); if (i && i.length) { var n = t.getData(); n.filterSelf(function (t) { for (var e = n.getName(t), r = 0; r < i.length; r++)if (!i[r].isSelected(e)) return !1; return !0 }) } } } }; kS("pie", [{ type: "pieToggleSelect", event: "pieselectchanged", method: "toggleSelected" }, { type: "pieSelect", event: "pieselected", method: "select" }, { type: "pieUnSelect", event: "pieunselected", method: "unSelect" }]), eu(PS("pie")), tu(x(ES, "pie")), Zl(BS("pie")), Jx.extend({ type: "series.scatter", dependencies: ["grid", "polar", "geo", "singleAxis", "calendar"], getInitialData: function () { return Bu(this.getSource(), this) }, brushSelector: "point", getProgressive: function () { var t = this.option.progressive; return null == t ? this.option.large ? 5e3 : this.get("progressive") : t }, getProgressiveThreshold: function () { var t = this.option.progressiveThreshold; return null == t ? this.option.large ? 1e4 : this.get("progressiveThreshold") : t }, defaultOption: { coordinateSystem: "cartesian2d", zlevel: 0, z: 2, legendHoverLink: !0, hoverAnimation: !0, symbolSize: 10, large: !1, largeThreshold: 2e3, itemStyle: { opacity: .8 } } }); var RS = 4, NS = Qr({ shape: { points: null }, symbolProxy: null, buildPath: function (t, e) { var i = e.points, n = e.size, r = this.symbolProxy, a = r.shape, o = t.getContext ? t.getContext() : t, s = o && n[0] < RS; if (!s) for (var l = 0; l < i.length;) { var u = i[l++], h = i[l++]; isNaN(u) || isNaN(h) || (a.x = u - n[0] / 2, a.y = h - n[1] / 2, a.width = n[0], a.height = n[1], r.buildPath(t, a, !0)) } }, afterBrush: function (t) { var e = this.shape, i = e.points, n = e.size, r = n[0] < RS; if (r) { this.setTransform(t); for (var a = 0; a < i.length;) { var o = i[a++], s = i[a++]; isNaN(o) || isNaN(s) || t.fillRect(o - n[0] / 2, s - n[1] / 2, n[0], n[1]) } this.restoreTransform(t) } }, findDataIndex: function (t, e) { for (var i = this.shape, n = i.points, r = i.size, a = Math.max(r[0], 4), o = Math.max(r[1], 4), s = n.length / 2 - 1; s >= 0; s--) { var l = 2 * s, u = n[l] - a / 2, h = n[l + 1] - o / 2; if (t >= u && e >= h && u + a >= t && h + o >= e) return s } return -1 } }), FS = fd.prototype; FS.isPersistent = function () { return !this._incremental }, FS.updateData = function (t) { this.group.removeAll(); var e = new NS({ rectHover: !0, cursor: "default" }); e.setShape({ points: t.getLayout("symbolPoints") }), this._setCommon(e, t), this.group.add(e), this._incremental = null }, FS.updateLayout = function (t) { if (!this._incremental) { var e = t.getLayout("symbolPoints"); this.group.eachChild(function (t) { if (null != t.startIndex) { var i = 2 * (t.endIndex - t.startIndex), n = 4 * t.startIndex * 2; e = new Float32Array(e.buffer, n, i) } t.setShape("points", e) }) } }, FS.incrementalPrepareUpdate = function (t) { this.group.removeAll(), this._clearIncremental(), t.count() > 2e6 ? (this._incremental || (this._incremental = new $r({ silent: !0 })), this.group.add(this._incremental)) : this._incremental = null }, FS.incrementalUpdate = function (t, e) { var i; this._incremental ? (i = new NS, this._incremental.addDisplayable(i, !0)) : (i = new NS({ rectHover: !0, cursor: "default", startIndex: t.start, endIndex: t.end }), i.incremental = !0, this.group.add(i)), i.setShape({ points: e.getLayout("symbolPoints") }), this._setCommon(i, e, !!this._incremental) }, FS._setCommon = function (t, e, i) { var n = e.hostModel, r = e.getVisual("symbolSize"); t.setShape("size", r instanceof Array ? r : [r, r]), t.symbolProxy = vh(e.getVisual("symbol"), 0, 0, 0, 0), t.setColor = t.symbolProxy.setColor; var a = t.shape.size[0] < RS; t.useStyle(n.getModel("itemStyle").getItemStyle(a ? ["color", "shadowBlur", "shadowColor"] : ["color"])); var o = e.getVisual("color"); o && t.setColor(o), i || (t.seriesIndex = n.seriesIndex, t.on("mousemove", function (e) { t.dataIndex = null; var i = t.findDataIndex(e.offsetX, e.offsetY); i >= 0 && (t.dataIndex = i + (t.startIndex || 0)) })) }, FS.remove = function () { this._clearIncremental(), this._incremental = null, this.group.removeAll() }, FS._clearIncremental = function () { var t = this._incremental; t && t.clearDisplaybles() }, su({ type: "scatter", render: function (t) { var e = t.getData(), i = this._updateSymbolDraw(e, t); i.updateData(e), this._finished = !0 }, incrementalPrepareRender: function (t) { var e = t.getData(), i = this._updateSymbolDraw(e, t); i.incrementalPrepareUpdate(e), this._finished = !1 }, incrementalRender: function (t, e) { this._symbolDraw.incrementalUpdate(t, e.getData()), this._finished = t.end === e.getData().count() }, updateTransform: function (t) { var e = t.getData(); if (this.group.dirty(), !this._finished || e.count() > 1e4 || !this._symbolDraw.isPersistent()) return { update: !0 }; var i = wS().reset(t); i.progress && i.progress({ start: 0, end: e.count() }, e), this._symbolDraw.updateLayout(e) }, _updateSymbolDraw: function (t, e) { var i = this._symbolDraw, n = e.pipelineContext, r = n.large; return i && r === this._isLargeDraw || (i && i.remove(), i = this._symbolDraw = r ? new fd : new Rc, this._isLargeDraw = r, this.group.removeAll()), this.group.add(i.group), i }, remove: function () { this._symbolDraw && this._symbolDraw.remove(!0), this._symbolDraw = null }, dispose: function () { } }), eu(bS("scatter", "circle")), tu(wS("scatter")), Jx.extend({ type: "series.effectScatter", dependencies: ["grid", "polar"], getInitialData: function () { return Bu(this.getSource(), this) }, brushSelector: "point", defaultOption: { coordinateSystem: "cartesian2d", zlevel: 0, z: 2, legendHoverLink: !0, effectType: "ripple", progressive: 0, showEffectOn: "render", rippleEffect: { period: 4, scale: 2.5, brushType: "fill" }, symbolSize: 10 } }); var VS = 3, GS = md.prototype; GS.stopEffectAnimation = function () { this.childAt(1).removeAll() }, GS.startEffectAnimation = function (t) {
    for (var e = t.symbolType, i = t.color, n = this.childAt(1), r = 0; VS > r; r++) {
      var a = vh(e, -1, -1, 2, 2, i); a.attr({ style: { strokeNoScale: !0 }, z2: 99, silent: !0, scale: [.5, .5] }); var o = -r / VS * t.period + t.effectOffset; a.animate("", !0).when(t.period, { scale: [t.rippleScale / 2, t.rippleScale / 2] }).delay(o).start(), a.animateStyle(!0).when(t.period, { opacity: 0 }).delay(o).start(), n.add(a)
    } gd(n, t)
  }, GS.updateEffectAnimation = function (t) { for (var e = this._effectCfg, i = this.childAt(1), n = ["symbolType", "period", "rippleScale"], r = 0; r < n.length; r++) { var a = n[r]; if (e[a] !== t[a]) return this.stopEffectAnimation(), void this.startEffectAnimation(t) } gd(i, t) }, GS.highlight = function () { this.trigger("emphasis") }, GS.downplay = function () { this.trigger("normal") }, GS.updateData = function (t, e) { var i = t.hostModel; this.childAt(0).updateData(t, e); var n = this.childAt(1), r = t.getItemModel(e), a = t.getItemVisual(e, "symbol"), o = pd(t.getItemVisual(e, "symbolSize")), s = t.getItemVisual(e, "color"); n.attr("scale", o), n.traverse(function (t) { t.attr({ fill: s }) }); var l = r.getShallow("symbolOffset"); if (l) { var u = n.position; u[0] = Ka(l[0], o[0]), u[1] = Ka(l[1], o[1]) } n.rotation = (r.getShallow("symbolRotate") || 0) * Math.PI / 180 || 0; var h = {}; if (h.showEffectOn = i.get("showEffectOn"), h.rippleScale = r.get("rippleEffect.scale"), h.brushType = r.get("rippleEffect.brushType"), h.period = 1e3 * r.get("rippleEffect.period"), h.effectOffset = e / t.count(), h.z = r.getShallow("z") || 0, h.zlevel = r.getShallow("zlevel") || 0, h.symbolType = a, h.color = s, this.off("mouseover").off("mouseout").off("emphasis").off("normal"), "render" === h.showEffectOn) this._effectCfg ? this.updateEffectAnimation(h) : this.startEffectAnimation(h), this._effectCfg = h; else { this._effectCfg = null, this.stopEffectAnimation(); var c = this.childAt(0), d = function () { c.highlight(), "render" !== h.showEffectOn && this.startEffectAnimation(h) }, f = function () { c.downplay(), "render" !== h.showEffectOn && this.stopEffectAnimation() }; this.on("mouseover", d, this).on("mouseout", f, this).on("emphasis", d, this).on("normal", f, this) } this._effectCfg = h }, GS.fadeOut = function (t) { this.off("mouseover").off("mouseout").off("emphasis").off("normal"), t && t() }, h(md, $g), su({ type: "effectScatter", init: function () { this._symbolDraw = new Rc(md) }, render: function (t) { var e = t.getData(), i = this._symbolDraw; i.updateData(e), this.group.add(i.group) }, updateTransform: function (t) { var e = t.getData(); this.group.dirty(); var i = wS().reset(t); i.progress && i.progress({ start: 0, end: e.count() }, e), this._symbolDraw.updateLayout(e) }, _updateGroupTransform: function (t) { var e = t.coordinateSystem; e && e.getRoamTransform && (this.group.transform = Le(e.getRoamTransform()), this.group.decomposeTransform()) }, remove: function (t, e) { this._symbolDraw && this._symbolDraw.remove(e) }, dispose: function () { } }), eu(bS("effectScatter", "circle")), tu(wS("effectScatter")); var HS = { _baseAxisDim: null, getInitialData: function (t, e) { var i, n, r = e.getComponent("xAxis", this.get("xAxisIndex")), a = e.getComponent("yAxis", this.get("yAxisIndex")), o = r.get("type"), s = a.get("type"); "category" === o ? (t.layout = "horizontal", i = r.getOrdinalMeta(), n = !0) : "category" === s ? (t.layout = "vertical", i = a.getOrdinalMeta(), n = !0) : t.layout = t.layout || "horizontal"; var l = ["x", "y"], u = "horizontal" === t.layout ? 0 : 1, h = this._baseAxisDim = l[u], c = l[1 - u], d = [r, a], p = d[u].get("type"), g = d[1 - u].get("type"), m = t.data; if (m && n) { var v = []; f(m, function (t, e) { var i; t.value && _(t.value) ? (i = t.value.slice(), t.value.unshift(e)) : _(t) ? (i = t.slice(), t.unshift(e)) : i = t, v.push(i) }), t.data = v } var y = this.defaultValueDimensions; return DS(this, { coordDimensions: [{ name: h, type: gu(p), ordinalMeta: i, otherDims: { tooltip: !1, itemName: 0 }, dimsDef: ["base"] }, { name: c, type: gu(g), dimsDef: y.slice() }], dimensionsCount: y.length + 1 }) }, getBaseAxis: function () { var t = this._baseAxisDim; return this.ecModel.getComponent(t + "Axis", this.get(t + "AxisIndex")).axis } }, WS = Jx.extend({ type: "series.candlestick", dependencies: ["xAxis", "yAxis", "grid"], defaultValueDimensions: [{ name: "open", defaultTooltip: !0 }, { name: "close", defaultTooltip: !0 }, { name: "lowest", defaultTooltip: !0 }, { name: "highest", defaultTooltip: !0 }], dimensions: null, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "cartesian2d", legendHoverLink: !0, hoverAnimation: !0, layout: null, itemStyle: { color: "#c23531", color0: "#314656", borderWidth: 1, borderColor: "#c23531", borderColor0: "#314656" }, emphasis: { itemStyle: { borderWidth: 2 } }, barMaxWidth: null, barMinWidth: null, barWidth: null, large: !0, largeThreshold: 600, progressive: 3e3, progressiveThreshold: 1e4, progressiveChunkMode: "mod", animationUpdate: !1, animationEasing: "linear", animationDuration: 300 }, getShadowDim: function () { return "open" }, brushSelector: function (t, e, i) { var n = e.getItemLayout(t); return n && i.rect(n.brushRect) } }); c(WS, HS, !0); var XS = ["itemStyle"], US = ["emphasis", "itemStyle"], jS = ["color", "color0", "borderColor", "borderColor0"], YS = (Vs.extend({ type: "candlestick", render: function (t) { this._updateDrawMode(t), this._isLargeDraw ? this._renderLarge(t) : this._renderNormal(t) }, incrementalPrepareRender: function (t) { this._clear(), this._updateDrawMode(t) }, incrementalRender: function (t, e) { this._isLargeDraw ? this._incrementalRenderLarge(t, e) : this._incrementalRenderNormal(t, e) }, _updateDrawMode: function (t) { var e = t.pipelineContext.large; (null == this._isLargeDraw || e ^ this._isLargeDraw) && (this._isLargeDraw = e, this._clear()) }, _renderNormal: function (t) { var e = t.getData(), i = this._data, n = this.group, r = e.getLayout("isSimpleBox"); this._data || n.removeAll(), e.diff(i).add(function (i) { if (e.hasValue(i)) { var a, o = e.getItemLayout(i); a = vd(o, i, !0), za(a, { shape: { points: o.ends } }, t, i), yd(a, e, i, r), n.add(a), e.setItemGraphicEl(i, a) } }).update(function (a, o) { var s = i.getItemGraphicEl(o); if (!e.hasValue(a)) return void n.remove(s); var l = e.getItemLayout(a); s ? Oa(s, { shape: { points: l.ends } }, t, a) : s = vd(l, a), yd(s, e, a, r), n.add(s), e.setItemGraphicEl(a, s) }).remove(function (t) { var e = i.getItemGraphicEl(t); e && n.remove(e) }).execute(), this._data = e }, _renderLarge: function (t) { this._clear(), _d(t, this.group) }, _incrementalRenderNormal: function (t, e) { for (var i, n = e.getData(), r = n.getLayout("isSimpleBox"); null != (i = t.next());) { var a, o = n.getItemLayout(i); a = vd(o, i), yd(a, n, i, r), a.incremental = !0, this.group.add(a) } }, _incrementalRenderLarge: function (t, e) { _d(e, this.group, !0) }, remove: function () { this._clear() }, _clear: function () { this.group.removeAll(), this._data = null }, dispose: V }), Nr.extend({ type: "normalCandlestickBox", shape: {}, buildPath: function (t, e) { var i = e.points; this.__simpleBox ? (t.moveTo(i[4][0], i[4][1]), t.lineTo(i[6][0], i[6][1])) : (t.moveTo(i[0][0], i[0][1]), t.lineTo(i[1][0], i[1][1]), t.lineTo(i[2][0], i[2][1]), t.lineTo(i[3][0], i[3][1]), t.closePath(), t.moveTo(i[4][0], i[4][1]), t.lineTo(i[5][0], i[5][1]), t.moveTo(i[6][0], i[6][1]), t.lineTo(i[7][0], i[7][1])) } })), qS = Nr.extend({ type: "largeCandlestickBox", shape: {}, buildPath: function (t, e) { for (var i = e.points, n = 0; n < i.length;)if (this.__sign === i[n++]) { var r = i[n++]; t.moveTo(r, i[n++]), t.lineTo(r, i[n++]) } else n += 3 } }), ZS = function (t) { t && _(t.series) && f(t.series, function (t) { S(t) && "k" === t.type && (t.type = "candlestick") }) }, KS = ["itemStyle", "borderColor"], $S = ["itemStyle", "borderColor0"], QS = ["itemStyle", "color"], JS = ["itemStyle", "color0"], tM = { seriesType: "candlestick", plan: i_(), performRawSeries: !0, reset: function (t, e) { function i(t, e) { for (var i; null != (i = t.next());) { var a = e.getItemModel(i), o = e.getItemLayout(i).sign; e.setItemVisual(i, { color: n(o, a), borderColor: r(o, a) }) } } function n(t, e) { return e.get(t > 0 ? QS : JS) } function r(t, e) { return e.get(t > 0 ? KS : $S) } var a = t.getData(), o = t.pipelineContext.large; return a.setVisual({ legendSymbol: "roundRect", colorP: n(1, t), colorN: n(-1, t), borderColorP: r(1, t), borderColorN: r(-1, t) }), e.isSeriesFiltered(t) ? void 0 : !o && { progress: i } } }, eM = "undefined" != typeof Float32Array ? Float32Array : Array, iM = { seriesType: "candlestick", plan: i_(), reset: function (t) { function e(t, e) { function i(t, e) { var i = []; return i[o] = e, i[s] = t, isNaN(e) || isNaN(t) ? [0 / 0, 0 / 0] : n.dataToPoint(i) } function r(t, e, i) { var n = e.slice(), r = e.slice(); n[o] = oa(n[o] + a / 2, 1, !1), r[o] = oa(r[o] - a / 2, 1, !0), i ? t.push(n, r) : t.push(r, n) } function l(t, e, n) { var r = i(t, n), l = i(e, n); return r[o] -= a / 2, l[o] -= a / 2, { x: r[0], y: r[1], width: s ? a : l[0] - r[0], height: s ? l[1] - r[1] : a } } function h(t) { return t[o] = oa(t[o], 1), t } for (var g; null != (g = t.next());) { var m = e.get(u, g), v = e.get(c, g), y = e.get(d, g), x = e.get(f, g), _ = e.get(p, g), b = Math.min(v, y), w = Math.max(v, y), S = i(b, m), M = i(w, m), I = i(x, m), D = i(_, m), T = []; r(T, M, 0), r(T, S, 1), T.push(h(D), h(M), h(I), h(S)), e.setItemLayout(g, { sign: wd(e, g, v, y, d), initBaseline: v > y ? M[s] : S[s], ends: T, brushRect: l(x, _, m) }) } } function i(t, e) { for (var i, r, a = new eM(5 * t.count), l = 0, h = [], g = []; null != (r = t.next());) { var m = e.get(u, r), v = e.get(c, r), y = e.get(d, r), x = e.get(f, r), _ = e.get(p, r); isNaN(m) || isNaN(x) || isNaN(_) ? (a[l++] = 0 / 0, l += 4) : (a[l++] = wd(e, r, v, y, d), h[o] = m, h[s] = x, i = n.dataToPoint(h, null, g), a[l++] = i ? i[0] : 0 / 0, a[l++] = i ? i[1] : 0 / 0, h[s] = _, i = n.dataToPoint(h, null, g), a[l++] = i ? i[1] : 0 / 0) } e.setLayout("largePoints", a) } var n = t.coordinateSystem, r = t.getData(), a = Sd(t, r), o = 0, s = 1, l = ["x", "y"], u = r.mapDimension(l[o]), h = r.mapDimension(l[s], !0), c = h[0], d = h[1], f = h[2], p = h[3]; return r.setLayout({ candleWidth: a, isSimpleBox: 1.3 >= a }), null == u || h.length < 4 ? void 0 : { progress: t.pipelineContext.large ? i : e } } }; ql(ZS), eu(tM), tu(iM), h(Md, Dw), Id.prototype.getIndicatorAxes = function () { return this._indicatorAxes }, Id.prototype.dataToPoint = function (t, e) { var i = this._indicatorAxes[e]; return this.coordToPoint(i.dataToCoord(t), e) }, Id.prototype.coordToPoint = function (t, e) { var i = this._indicatorAxes[e], n = i.angle, r = this.cx + t * Math.cos(n), a = this.cy - t * Math.sin(n); return [r, a] }, Id.prototype.pointToData = function (t) { var e = t[0] - this.cx, i = t[1] - this.cy, n = Math.sqrt(e * e + i * i); e /= n, i /= n; for (var r, a = Math.atan2(-i, e), o = 1 / 0, s = -1, l = 0; l < this._indicatorAxes.length; l++) { var u = this._indicatorAxes[l], h = Math.abs(a - u.angle); o > h && (r = u, s = l, o = h) } return [s, +(r && r.coodToData(n))] }, Id.prototype.resize = function (t, e) { var i = t.get("center"), n = e.getWidth(), r = e.getHeight(), a = Math.min(n, r) / 2; this.cx = Ka(i[0], n), this.cy = Ka(i[1], r), this.startAngle = t.get("startAngle") * Math.PI / 180; var o = t.get("radius"); ("string" == typeof o || "number" == typeof o) && (o = [0, o]), this.r0 = Ka(o[0], a), this.r = Ka(o[1], a), f(this._indicatorAxes, function (t, e) { t.setExtent(this.r0, this.r); var i = this.startAngle + e * Math.PI * 2 / this._indicatorAxes.length; i = Math.atan2(Math.sin(i), Math.cos(i)), t.angle = i }, this) }, Id.prototype.update = function (t) { function e(t) { var e = Math.pow(10, Math.floor(Math.log(t) / Math.LN10)), i = t / e; return 2 === i ? i = 5 : i *= 2, i * e } var i = this._indicatorAxes, n = this._model; f(i, function (t) { t.scale.setExtent(1 / 0, -1 / 0) }), t.eachSeriesByType("radar", function (e) { if ("radar" === e.get("coordinateSystem") && t.getComponent("radar", e.get("radarIndex")) === n) { var r = e.getData(); f(i, function (t) { t.scale.unionExtentFromData(r, r.mapDimension(t.dim)) }) } }, this); var r = n.get("splitNumber"); f(i, function (t) { var i = ah(t.scale, t.model); sh(t.scale, t.model); var n = t.model, a = t.scale, o = n.getMin(), s = n.getMax(), l = a.getInterval(); if (null != o && null != s) a.setExtent(+o, +s), a.setInterval((s - o) / r); else if (null != o) { var u; do u = o + l * r, a.setExtent(+o, u), a.setInterval(l), l = e(l); while (u < i[1] && isFinite(u) && isFinite(i[1])) } else if (null != s) { var h; do h = s - l * r, a.setExtent(h, +s), a.setInterval(l), l = e(l); while (h > i[0] && isFinite(h) && isFinite(i[0])) } else { var c = a.getTicks().length - 1; c > r && (l = e(l)); var d = Math.round((i[0] + i[1]) / 2 / l) * l, f = Math.round(r / 2); a.setExtent($a(d - f * l), $a(d + (r - f) * l)), a.setInterval(l) } }) }, Id.dimensions = [], Id.create = function (t, e) { var i = []; return t.eachComponent("radar", function (n) { var r = new Id(n, t, e); i.push(r), n.coordinateSystem = r }), t.eachSeriesByType("radar", function (t) { "radar" === t.get("coordinateSystem") && (t.coordinateSystem = i[t.get("radarIndex") || 0]) }), i }, ts.register("radar", Id); var nM = Ow.valueAxis, rM = (ru({ type: "radar", optionUpdated: function () { var t = this.get("boundaryGap"), e = this.get("splitNumber"), i = this.get("scale"), a = this.get("axisLine"), l = this.get("axisTick"), u = this.get("axisLabel"), h = this.get("name"), c = this.get("name.show"), d = this.get("name.formatter"), f = this.get("nameGap"), g = this.get("triggerEvent"), m = p(this.get("indicator") || [], function (p) { null != p.max && p.max > 0 && !p.min ? p.min = 0 : null != p.min && p.min < 0 && !p.max && (p.max = 0); var m = h; if (null != p.color && (m = s({ color: p.color }, h)), p = r(n(p), { boundaryGap: t, splitNumber: e, scale: i, axisLine: a, axisTick: l, axisLabel: u, name: p.text, nameLocation: "end", nameGap: f, nameTextStyle: m, triggerEvent: g }, !1), c || (p.name = ""), "string" == typeof d) { var v = p.name; p.name = d.replace("{value}", null != v ? v : "") } else "function" == typeof d && (p.name = d(p.name, p)); var y = o(new Ha(p, null, this.ecModel), cw); return y.mainType = "radar", y.componentIndex = this.componentIndex, y }, this); this.getIndicatorModels = function () { return m } }, defaultOption: { zlevel: 0, z: 0, center: ["50%", "50%"], radius: "75%", startAngle: 90, name: { show: !0 }, boundaryGap: [0, 0], splitNumber: 5, nameGap: 15, scale: !1, shape: "polygon", axisLine: r({ lineStyle: { color: "#bbb" } }, nM.axisLine), axisLabel: Dd(nM.axisLabel, !1), axisTick: Dd(nM.axisTick, !1), splitLine: Dd(nM.splitLine, !0), splitArea: Dd(nM.splitArea, !0), indicator: [] } }), ["axisLine", "axisTickLabel", "axisName"]); au({ type: "radar", render: function (t) { var e = this.group; e.removeAll(), this._buildAxes(t), this._buildSplitLineAndArea(t) }, _buildAxes: function (t) { var e = t.coordinateSystem, i = e.getIndicatorAxes(), n = p(i, function (t) { var i = new qw(t.model, { position: [e.cx, e.cy], rotation: t.angle, labelDirection: -1, tickDirection: -1, nameDirection: 1 }); return i }); f(n, function (t) { f(rM, t.add, t), this.group.add(t.getGroup()) }, this) }, _buildSplitLineAndArea: function (t) { function e(t, e, i) { var n = i % e.length; return t[n] = t[n] || [], n } var i = t.coordinateSystem, n = i.getIndicatorAxes(); if (n.length) { var r = t.get("shape"), a = t.getModel("splitLine"), o = t.getModel("splitArea"), l = a.getModel("lineStyle"), u = o.getModel("areaStyle"), h = a.get("show"), c = o.get("show"), d = l.get("color"), g = u.get("color"); d = _(d) ? d : [d], g = _(g) ? g : [g]; var m = [], v = []; if ("circle" === r) for (var y = n[0].getTicksCoords(), x = i.cx, b = i.cy, w = 0; w < y.length; w++) { if (h) { var S = e(m, d, w); m[S].push(new hy({ shape: { cx: x, cy: b, r: y[w].coord } })) } if (c && w < y.length - 1) { var S = e(v, g, w); v[S].push(new py({ shape: { cx: x, cy: b, r0: y[w].coord, r: y[w + 1].coord } })) } } else for (var M, I = p(n, function (t, e) { var n = t.getTicksCoords(); return M = null == M ? n.length - 1 : Math.min(n.length - 1, M), p(n, function (t) { return i.coordToPoint(t.coord, e) }) }), D = [], w = 0; M >= w; w++) { for (var T = [], A = 0; A < n.length; A++)T.push(I[A][w]); if (T[0] && T.push(T[0].slice()), h) { var S = e(m, d, w); m[S].push(new yy({ shape: { points: T } })) } if (c && D) { var S = e(v, g, w - 1); v[S].push(new vy({ shape: { points: T.concat(D) } })) } D = T.slice().reverse() } var C = l.getLineStyle(), k = u.getAreaStyle(); f(v, function (t, e) { this.group.add(Ry(t, { style: s({ stroke: "none", fill: g[e % g.length] }, k), silent: !0 })) }, this), f(m, function (t, e) { this.group.add(Ry(t, { style: s({ fill: "none", stroke: d[e % d.length] }, C), silent: !0 })) }, this) } } }); var aM = Jx.extend({ type: "series.radar", dependencies: ["radar"], init: function () { aM.superApply(this, "init", arguments), this.legendDataProvider = function () { return this.getRawData() } }, getInitialData: function () { return DS(this, { generateCoord: "indicator_", generateCoordCount: 1 / 0 }) }, formatTooltip: function (t) { var e = this.getData(), i = this.coordinateSystem, n = i.getIndicatorAxes(), r = this.getData().getName(t); return go("" === r ? this.name : r) + "<br/>" + p(n, function (i) { var n = e.get(e.mapDimension(i.dim), t); return go(i.name + " : " + n) }).join("<br />") }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "radar", legendHoverLink: !0, radarIndex: 0, lineStyle: { width: 2, type: "solid" }, label: { position: "top" }, symbol: "emptyCircle", symbolSize: 4 } }); su({ type: "radar", render: function (t) { function e(t, e) { var i = t.getItemVisual(e, "symbol") || "circle", n = t.getItemVisual(e, "color"); if ("none" !== i) { var r = Td(t.getItemVisual(e, "symbolSize")), a = vh(i, -1, -1, 2, 2, n); return a.attr({ style: { strokeNoScale: !0 }, z2: 100, scale: [r[0] / 2, r[1] / 2] }), a } } function i(i, n, r, a, o, s) { r.removeAll(); for (var l = 0; l < n.length - 1; l++) { var u = e(a, o); u && (u.__dimIdx = l, i[l] ? (u.attr("position", i[l]), Vy[s ? "initProps" : "updateProps"](u, { position: n[l] }, t, o)) : u.attr("position", n[l]), r.add(u)) } } function r(t) { return p(t, function () { return [a.cx, a.cy] }) } var a = t.coordinateSystem, o = this.group, l = t.getData(), u = this._data; l.diff(u).add(function (e) { var n = l.getItemLayout(e); if (n) { var a = new vy, o = new yy, s = { shape: { points: n } }; a.shape.points = r(n), o.shape.points = r(n), za(a, s, t, e), za(o, s, t, e); var u = new $g, h = new $g; u.add(o), u.add(a), u.add(h), i(o.shape.points, n, h, l, e, !0), l.setItemGraphicEl(e, u) } }).update(function (e, n) { var r = u.getItemGraphicEl(n), a = r.childAt(0), o = r.childAt(1), s = r.childAt(2), h = { shape: { points: l.getItemLayout(e) } }; h.shape.points && (i(a.shape.points, h.shape.points, s, l, e, !1), Oa(a, h, t), Oa(o, h, t), l.setItemGraphicEl(e, r)) }).remove(function (t) { o.remove(u.getItemGraphicEl(t)) }).execute(), l.eachItemGraphicEl(function (t, e) { function i() { h.attr("ignore", m) } function r() { h.attr("ignore", g) } var a = l.getItemModel(e), u = t.childAt(0), h = t.childAt(1), c = t.childAt(2), d = l.getItemVisual(e, "color"); o.add(t), u.useStyle(s(a.getModel("lineStyle").getLineStyle(), { fill: "none", stroke: d })), u.hoverStyle = a.getModel("emphasis.lineStyle").getLineStyle(); var f = a.getModel("areaStyle"), p = a.getModel("emphasis.areaStyle"), g = f.isEmpty() && f.parentModel.isEmpty(), m = p.isEmpty() && p.parentModel.isEmpty(); m = m && g, h.ignore = g, h.useStyle(s(f.getAreaStyle(), { fill: d, opacity: .7 })), h.hoverStyle = p.getAreaStyle(); var v = a.getModel("itemStyle").getItemStyle(["color"]), y = a.getModel("emphasis.itemStyle").getItemStyle(), x = a.getModel("label"), _ = a.getModel("emphasis.label"); c.eachChild(function (t) { t.setStyle(v), t.hoverStyle = n(y), wa(t.style, t.hoverStyle, x, _, { labelFetcher: l.hostModel, labelDataIndex: e, labelDimIndex: t.__dimIdx, defaultText: l.get(l.dimensions[t.__dimIdx], e), autoColor: d, isRectText: !0 }) }), t.off("mouseover").off("mouseout").off("normal").off("emphasis"), t.on("emphasis", i).on("mouseover", i).on("normal", r).on("mouseout", r), _a(t) }), this._data = l }, remove: function () { this.group.removeAll(), this._data = null }, dispose: function () { } }); var oM = function (t) { t.eachSeriesByType("radar", function (t) { function e(t, e) { n[e] = n[e] || [], n[e][o] = r.dataToPoint(t, o) } var i = t.getData(), n = [], r = t.coordinateSystem; if (r) { for (var a = r.getIndicatorAxes(), o = 0; o < a.length; o++)i.each(i.mapDimension(a[o].dim), e); i.each(function (t) { n[t][0] && n[t].push(n[t][0].slice()), i.setItemLayout(t, n[t]) }) } }) }, sM = function (t) { var e = t.polar; if (e) { _(e) || (e = [e]); var i = []; f(e, function (e) { e.indicator ? (e.type && !e.shape && (e.shape = e.type), t.radar = t.radar || [], _(t.radar) || (t.radar = [t.radar]), t.radar.push(e)) : i.push(e) }), t.polar = i } f(t.series, function (t) { t && "radar" === t.type && t.polarIndex && (t.radarIndex = t.polarIndex) }) }; eu(PS("radar")), eu(bS("radar", "circle")), tu(oM), Zl(BS("radar")), ql(sM); var lM = function (t, e, i, n, r) { Dw.call(this, t, e, i), this.type = n || "value", this.position = r || "bottom", this.orient = null }; lM.prototype = { constructor: lM, model: null, isHorizontal: function () { var t = this.position; return "top" === t || "bottom" === t }, pointToData: function (t, e) { return this.coordinateSystem.pointToData(t, e)[0] }, toGlobalCoord: null, toLocalCoord: null }, h(lM, Dw), Ad.prototype = { type: "singleAxis", axisPointerEnabled: !0, constructor: Ad, _init: function (t) { var e = this.dimension, i = new lM(e, lh(t), [0, 0], t.get("type"), t.get("position")), n = "category" === i.type; i.onBand = n && t.get("boundaryGap"), i.inverse = t.get("inverse"), i.orient = t.get("orient"), t.axis = i, i.model = t, i.coordinateSystem = this, this._axis = i }, update: function (t) { t.eachSeries(function (t) { if (t.coordinateSystem === this) { var e = t.getData(); f(e.mapDimension(this.dimension, !0), function (t) { this._axis.scale.unionExtentFromData(e, t) }, this), sh(this._axis.scale, this._axis.model) } }, this) }, resize: function (t, e) { this._rect = Io({ left: t.get("left"), top: t.get("top"), right: t.get("right"), bottom: t.get("bottom"), width: t.get("width"), height: t.get("height") }, { width: e.getWidth(), height: e.getHeight() }), this._adjustAxis() }, getRect: function () { return this._rect }, _adjustAxis: function () { var t = this._rect, e = this._axis, i = e.isHorizontal(), n = i ? [0, t.width] : [0, t.height], r = e.reverse ? 1 : 0; e.setExtent(n[r], n[1 - r]), this._updateAxisTransform(e, i ? t.x : t.y) }, _updateAxisTransform: function (t, e) { var i = t.getExtent(), n = i[0] + i[1], r = t.isHorizontal(); t.toGlobalCoord = r ? function (t) { return t + e } : function (t) { return n - t + e }, t.toLocalCoord = r ? function (t) { return t - e } : function (t) { return n - t + e } }, getAxis: function () { return this._axis }, getBaseAxis: function () { return this._axis }, getAxes: function () { return [this._axis] }, getTooltipAxes: function () { return { baseAxes: [this.getAxis()] } }, containPoint: function (t) { var e = this.getRect(), i = this.getAxis(), n = i.orient; return "horizontal" === n ? i.contain(i.toLocalCoord(t[0])) && t[1] >= e.y && t[1] <= e.y + e.height : i.contain(i.toLocalCoord(t[1])) && t[0] >= e.y && t[0] <= e.y + e.height }, pointToData: function (t) { var e = this.getAxis(); return [e.coordToData(e.toLocalCoord(t["horizontal" === e.orient ? 0 : 1]))] }, dataToPoint: function (t) { var e = this.getAxis(), i = this.getRect(), n = [], r = "horizontal" === e.orient ? 0 : 1; return t instanceof Array && (t = t[0]), n[r] = e.toGlobalCoord(e.dataToCoord(+t)), n[1 - r] = 0 === r ? i.y + i.height / 2 : i.x + i.width / 2, n } }, ts.register("single", { create: Cd, dimensions: Ad.prototype.dimensions }); var uM = ["axisLine", "axisTickLabel", "axisName"], hM = "splitLine", cM = Jw.extend({ type: "singleAxis", axisPointerClass: "SingleAxisPointer", render: function (t, e, i, n) { var r = this.group; r.removeAll(); var a = kd(t), o = new qw(t, a); f(uM, o.add, o), r.add(o.getGroup()), t.get(hM + ".show") && this["_" + hM](t), cM.superCall(this, "render", t, e, i, n) }, _splitLine: function (t) { var e = t.axis; if (!e.scale.isBlank()) { var i = t.getModel("splitLine"), n = i.getModel("lineStyle"), r = n.get("width"), a = n.get("color"); a = a instanceof Array ? a : [a]; for (var o = t.coordinateSystem.getRect(), s = e.isHorizontal(), l = [], u = 0, h = e.getTicksCoords({ tickModel: i }), c = [], d = [], f = 0; f < h.length; ++f) { var p = e.toGlobalCoord(h[f].coord); s ? (c[0] = p, c[1] = o.y, d[0] = p, d[1] = o.y + o.height) : (c[0] = o.x, c[1] = p, d[0] = o.x + o.width, d[1] = p); var g = u++ % a.length; l[g] = l[g] || [], l[g].push(new Sy(ra({ shape: { x1: c[0], y1: c[1], x2: d[0], y2: d[1] }, style: { lineWidth: r }, silent: !0 }))) } for (var f = 0; f < l.length; ++f)this.group.add(Ry(l[f], { style: { stroke: a[f % a.length], lineDash: n.getLineDash(r), lineWidth: r }, silent: !0 })) } } }), dM = cx.extend({ type: "singleAxis", layoutMode: "box", axis: null, coordinateSystem: null, getCoordSysModel: function () { return this } }), fM = { left: "5%", top: "5%", right: "5%", bottom: "5%", type: "value", position: "bottom", orient: "horizontal", axisLine: { show: !0, lineStyle: { width: 2, type: "solid" } }, tooltip: { show: !0 }, axisTick: { show: !0, length: 6, lineStyle: { width: 2 } }, axisLabel: { show: !0, interval: "auto" }, splitLine: { show: !0, lineStyle: { type: "dashed", opacity: .2 } } }; r(dM.prototype, cw), Ew("single", dM, Pd, fM); var pM = function (t, e) { var i, n = [], r = t.seriesIndex; if (null == r || !(i = e.getSeriesByIndex(r))) return { point: [] }; var a = i.getData(), o = Xn(a, t); if (null == o || 0 > o || _(o)) return { point: [] }; var s = a.getItemGraphicEl(o), l = i.coordinateSystem; if (i.getTooltipPosition) n = i.getTooltipPosition(o) || []; else if (l && l.dataToPoint) n = l.dataToPoint(a.getValues(p(l.dimensions, function (t) { return a.mapDimension(t) }), o, !0)) || []; else if (s) { var u = s.getBoundingRect().clone(); u.applyTransform(s.transform), n = [u.x + u.width / 2, u.y + u.height / 2] } return { point: n, el: s } }, gM = f, mM = x, vM = Un(), yM = function (t, e, i) { var n = t.currTrigger, r = [t.x, t.y], a = t, o = t.dispatchAction || y(i.dispatchAction, i), s = e.getComponent("axisPointer").coordSysAxesInfo; if (s) { Gd(r) && (r = pM({ seriesIndex: a.seriesIndex, dataIndex: a.dataIndex }, e).point); var l = Gd(r), u = a.axesInfo, h = s.axesInfo, c = "leave" === n || Gd(r), d = {}, f = {}, p = { list: [], map: {} }, g = { showPointer: mM(zd, f), showTooltip: mM(Ed, p) }; gM(s.coordSysMap, function (t, e) { var i = l || t.containPoint(r); gM(s.coordSysAxesInfo[e], function (t) { var e = t.axis, n = Fd(u, t); if (!c && i && (!u || n)) { var a = n && n.value; null != a || l || (a = e.pointToData(r)), null != a && Ld(t, a, g, !1, d) } }) }); var m = {}; return gM(h, function (t, e) { var i = t.linkGroup; i && !f[e] && gM(i.axesInfo, function (e, n) { var r = f[n]; if (e !== t && r) { var a = r.value; i.mapper && (a = t.axis.scale.parse(i.mapper(a, Vd(e), Vd(t)))), m[t.key] = a } }) }), gM(m, function (t, e) { Ld(h[e], t, g, !0, d) }), Bd(f, h, d), Rd(p, r, t, o), Nd(h, o, i), d } }, xM = (ru({ type: "axisPointer", coordSysAxesInfo: null, defaultOption: { show: "auto", triggerOn: null, zlevel: 0, z: 50, type: "line", snap: !1, triggerTooltip: !0, value: null, status: null, link: [], animation: null, animationDurationUpdate: 200, lineStyle: { color: "#aaa", width: 1, type: "solid" }, shadowStyle: { color: "rgba(150,150,150,0.3)" }, label: { show: !0, formatter: null, precision: "auto", margin: 3, color: "#fff", padding: [5, 7, 5, 7], backgroundColor: "auto", borderColor: null, borderWidth: 0, shadowBlur: 3, shadowColor: "#aaa" }, handle: { show: !1, icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z", size: 45, margin: 50, color: "#333", shadowBlur: 3, shadowColor: "#aaa", shadowOffsetX: 0, shadowOffsetY: 2, throttle: 40 } } }), Un()), _M = f, bM = au({ type: "axisPointer", render: function (t, e, i) { var n = e.getComponent("tooltip"), r = t.get("triggerOn") || n && n.get("triggerOn") || "mousemove|click"; Hd("axisPointer", i, function (t, e, i) { "none" !== r && ("leave" === t || r.indexOf(t) >= 0) && i({ type: "updateAxisPointer", currTrigger: t, x: e && e.offsetX, y: e && e.offsetY }) }) }, remove: function (t, e) { qd(e.getZr(), "axisPointer"), bM.superApply(this._model, "remove", arguments) }, dispose: function (t, e) { qd("axisPointer", e), bM.superApply(this._model, "dispose", arguments) } }), wM = Un(), SM = n, MM = y; Zd.prototype = { _group: null, _lastGraphicKey: null, _handle: null, _dragging: !1, _lastValue: null, _lastStatus: null, _payloadInfo: null, animationThreshold: 15, render: function (t, e, i, n) { var r = e.get("value"), a = e.get("status"); if (this._axisModel = t, this._axisPointerModel = e, this._api = i, n || this._lastValue !== r || this._lastStatus !== a) { this._lastValue = r, this._lastStatus = a; var o = this._group, s = this._handle; if (!a || "hide" === a) return o && o.hide(), void (s && s.hide()); o && o.show(), s && s.show(); var l = {}; this.makeElOption(l, r, t, e, i); var u = l.graphicKey; u !== this._lastGraphicKey && this.clear(i), this._lastGraphicKey = u; var h = this._moveAnimation = this.determineAnimation(t, e); if (o) { var c = x(Kd, e, h); this.updatePointerEl(o, l, c, e), this.updateLabelEl(o, l, c, e) } else o = this._group = new $g, this.createPointerEl(o, l, t, e), this.createLabelEl(o, l, t, e), i.getZr().add(o); tf(o, e, !0), this._renderHandle(r) } }, remove: function (t) { this.clear(t) }, dispose: function (t) { this.clear(t) }, determineAnimation: function (t, e) { var i = e.get("animation"), n = t.axis, r = "category" === n.type, a = e.get("snap"); if (!a && !r) return !1; if ("auto" === i || null == i) { var o = this.animationThreshold; if (r && n.getBandWidth() > o) return !0; if (a) { var s = Sc(t).seriesDataCount, l = n.getExtent(); return Math.abs(l[0] - l[1]) / s > o } return !1 } return i === !0 }, makeElOption: function () { }, createPointerEl: function (t, e) { var i = e.pointer; if (i) { var n = wM(t).pointerEl = new Vy[i.type](SM(e.pointer)); t.add(n) } }, createLabelEl: function (t, e, i, n) { if (e.label) { var r = wM(t).labelEl = new by(SM(e.label)); t.add(r), Qd(r, n) } }, updatePointerEl: function (t, e, i) { var n = wM(t).pointerEl; n && (n.setStyle(e.pointer.style), i(n, { shape: e.pointer.shape })) }, updateLabelEl: function (t, e, i, n) { var r = wM(t).labelEl; r && (r.setStyle(e.label.style), i(r, { shape: e.label.shape, position: e.label.position }), Qd(r, n)) }, _renderHandle: function (t) { if (!this._dragging && this.updateHandleTransform) { var e = this._axisPointerModel, i = this._api.getZr(), n = this._handle, r = e.getModel("handle"), a = e.get("status"); if (!r.get("show") || !a || "hide" === a) return n && i.remove(n), void (this._handle = null); var o; this._handle || (o = !0, n = this._handle = Ga(r.get("icon"), { cursor: "move", draggable: !0, onmousemove: function (t) { dg(t.event) }, onmousedown: MM(this._onHandleDragMove, this, 0, 0), drift: MM(this._onHandleDragMove, this), ondragend: MM(this._onHandleDragEnd, this) }), i.add(n)), tf(n, e, !1); var s = ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]; n.setStyle(r.getItemStyle(null, s)); var l = r.get("size"); _(l) || (l = [l, l]), n.attr("scale", [l[0] / 2, l[1] / 2]), js(this, "_doDispatchAxisPointer", r.get("throttle") || 0, "fixRate"), this._moveHandleToValue(t, o) } }, _moveHandleToValue: function (t, e) { Kd(this._axisPointerModel, !e && this._moveAnimation, this._handle, Jd(this.getHandleTransform(t, this._axisModel, this._axisPointerModel))) }, _onHandleDragMove: function (t, e) { var i = this._handle; if (i) { this._dragging = !0; var n = this.updateHandleTransform(Jd(i), [t, e], this._axisModel, this._axisPointerModel); this._payloadInfo = n, i.stopAnimation(), i.attr(Jd(n)), wM(i).lastProp = null, this._doDispatchAxisPointer() } }, _doDispatchAxisPointer: function () { var t = this._handle; if (t) { var e = this._payloadInfo, i = this._axisModel; this._api.dispatchAction({ type: "updateAxisPointer", x: e.cursorPoint[0], y: e.cursorPoint[1], tooltipOption: e.tooltipOption, axesInfo: [{ axisDim: i.axis.dim, axisIndex: i.componentIndex }] }) } }, _onHandleDragEnd: function () { this._dragging = !1; var t = this._handle; if (t) { var e = this._axisPointerModel.get("value"); this._moveHandleToValue(e), this._api.dispatchAction({ type: "hideTip" }) } }, getHandleTransform: null, updateHandleTransform: null, clear: function (t) { this._lastValue = null, this._lastStatus = null; var e = t.getZr(), i = this._group, n = this._handle; e && i && (this._lastGraphicKey = null, i && e.remove(i), n && e.remove(n), this._group = null, this._handle = null, this._payloadInfo = null) }, doClear: function () { }, buildLabel: function (t, e, i) { return i = i || 0, { x: t[i], y: t[1 - i], width: e[i], height: e[1 - i] } } }, Zd.prototype.constructor = Zd, tr(Zd); var IM = Zd.extend({ makeElOption: function (t, e, i, n, r) { var a = i.axis, o = a.grid, s = n.get("type"), l = hf(o, a).getOtherAxis(a).getGlobalExtent(), u = a.toGlobalCoord(a.dataToCoord(e, !0)); if (s && "none" !== s) { var h = ef(n), c = DM[s](a, u, l, h); c.style = h, t.graphicKey = c.type, t.pointer = c } var d = Cc(o.model, i); sf(e, t, d, i, n, r) }, getHandleTransform: function (t, e, i) { var n = Cc(e.axis.grid.model, e, { labelInside: !1 }); return n.labelMargin = i.get("handle.margin"), { position: of(e.axis, t, n), rotation: n.rotation + (n.labelDirection < 0 ? Math.PI : 0) } }, updateHandleTransform: function (t, e, i) { var n = i.axis, r = n.grid, a = n.getGlobalExtent(!0), o = hf(r, n).getOtherAxis(n).getGlobalExtent(), s = "x" === n.dim ? 0 : 1, l = t.position; l[s] += e[s], l[s] = Math.min(a[1], l[s]), l[s] = Math.max(a[0], l[s]); var u = (o[1] + o[0]) / 2, h = [u, u]; h[s] = l[s]; var c = [{ verticalAlign: "middle" }, { align: "center" }]; return { position: l, rotation: t.rotation, cursorPoint: h, tooltipOption: c[s] } } }), DM = { line: function (t, e, i, n) { var r = lf([e, i[0]], [e, i[1]], cf(t)); return ra({ shape: r, style: n }), { type: "Line", shape: r } }, shadow: function (t, e, i) { var n = Math.max(1, t.getBandWidth()), r = i[1] - i[0]; return { type: "Rect", shape: uf([e - n / 2, i[0]], [n, r], cf(t)) } } }; Jw.registerAxisPointerClass("CartesianAxisPointer", IM), ql(function (t) { if (t) { (!t.axisPointer || 0 === t.axisPointer.length) && (t.axisPointer = {}); var e = t.axisPointer.link; e && !_(e) && (t.axisPointer.link = [e]) } }), Zl(J_.PROCESSOR.STATISTIC, function (t, e) { t.getComponent("axisPointer").coordSysAxesInfo = mc(t, e) }), $l({ type: "updateAxisPointer", event: "updateAxisPointer", update: ":updateAxisPointer" }, yM); var TM = ["x", "y"], AM = ["width", "height"], CM = Zd.extend({ makeElOption: function (t, e, i, n, r) { var a = i.axis, o = a.coordinateSystem, s = ff(o, 1 - df(a)), l = o.dataToPoint(e)[0], u = n.get("type"); if (u && "none" !== u) { var h = ef(n), c = kM[u](a, l, s, h); c.style = h, t.graphicKey = c.type, t.pointer = c } var d = kd(i); sf(e, t, d, i, n, r) }, getHandleTransform: function (t, e, i) { var n = kd(e, { labelInside: !1 }); return n.labelMargin = i.get("handle.margin"), { position: of(e.axis, t, n), rotation: n.rotation + (n.labelDirection < 0 ? Math.PI : 0) } }, updateHandleTransform: function (t, e, i) { var n = i.axis, r = n.coordinateSystem, a = df(n), o = ff(r, a), s = t.position; s[a] += e[a], s[a] = Math.min(o[1], s[a]), s[a] = Math.max(o[0], s[a]); var l = ff(r, 1 - a), u = (l[1] + l[0]) / 2, h = [u, u]; return h[a] = s[a], { position: s, rotation: t.rotation, cursorPoint: h, tooltipOption: { verticalAlign: "middle" } } } }), kM = { line: function (t, e, i, n) { var r = lf([e, i[0]], [e, i[1]], df(t)); return ra({ shape: r, style: n }), { type: "Line", shape: r } }, shadow: function (t, e, i) { var n = t.getBandWidth(), r = i[1] - i[0]; return { type: "Rect", shape: uf([e - n / 2, i[0]], [n, r], df(t)) } } }; Jw.registerAxisPointerClass("SingleAxisPointer", CM), au({ type: "single" }); var PM = 2, LM = Jx.extend({
    type: "series.themeRiver", dependencies: ["singleAxis"], nameMap: null, init: function () { LM.superApply(this, "init", arguments), this.legendDataProvider = function () { return this.getRawData() } }, fixData: function (t) { var e = t.length, i = $n(t, function (t) { return t[2] }), n = []; i.buckets.each(function (t, e) { n.push({ name: e, dataList: t }) }); for (var r = n.length, a = -1, o = -1, s = 0; r > s; ++s) { var l = n[s].dataList.length; l > a && (a = l, o = s) } for (var u = 0; r > u; ++u)if (u !== o) for (var h = n[u].name, c = 0; a > c; ++c) { for (var d = n[o].dataList[c][0], f = n[u].dataList.length, p = -1, g = 0; f > g; ++g) { var m = n[u].dataList[g][0]; if (m === d) { p = g; break } } -1 === p && (t[e] = [], t[e][0] = d, t[e][1] = 0, t[e][2] = h, e++) } return t }, getInitialData: function (t, e) {
      for (var i = e.queryComponents({ mainType: "singleAxis", index: this.get("singleAxisIndex"), id: this.get("singleAxisId") })[0], n = i.get("type"), r = m(t.data, function (t) { return void 0 !== t[2] }), a = this.fixData(r || []), o = [], s = this.nameMap = N(), l = 0, u = 0; u < a.length; ++u)o.push(a[u][PM]), s.get(a[u][PM]) || (s.set(a[u][PM], l), l++);
      var h = Eb(a, { coordDimensions: ["single"], dimensionsDefine: [{ name: "time", type: gu(n) }, { name: "value", type: "float" }, { name: "name", type: "ordinal" }], encodeDefine: { single: 0, value: 1, itemName: 2 } }), c = new Lb(h, this); return c.initData(a), c
    }, getLayerSeries: function () { for (var t = this.getData(), e = t.count(), i = [], n = 0; e > n; ++n)i[n] = n; var r = t.mapDimension("single"), a = $n(i, function (e) { return t.get("name", e) }), o = []; return a.buckets.each(function (e, i) { e.sort(function (e, i) { return t.get(r, e) - t.get(r, i) }), o.push({ name: i, indices: e }) }), o }, getAxisTooltipData: function (t, e) { _(t) || (t = t ? [t] : []); for (var i, n = this.getData(), r = this.getLayerSeries(), a = [], o = r.length, s = 0; o > s; ++s) { for (var l = Number.MAX_VALUE, u = -1, h = r[s].indices.length, c = 0; h > c; ++c) { var d = n.get(t[0], r[s].indices[c]), f = Math.abs(d - e); l >= f && (i = d, l = f, u = r[s].indices[c]) } a.push(u) } return { dataIndices: a, nestestValue: i } }, formatTooltip: function (t) { var e = this.getData(), i = e.getName(t), n = e.get(e.mapDimension("value"), t); return (isNaN(n) || null == n) && (n = "-"), go(i + " : " + n) }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "singleAxis", boundaryGap: ["10%", "10%"], singleAxisIndex: 0, animationEasing: "linear", label: { margin: 4, show: !0, position: "left", color: "#000", fontSize: 11 }, emphasis: { label: { show: !0 } } }
  }); su({ type: "themeRiver", init: function () { this._layers = [] }, render: function (t) { function e(t) { return t.name } function i(e, i, s) { var l = this._layers; if ("remove" === e) return void r.remove(l[i]); for (var u, h = [], d = [], f = a[i].indices, p = 0; p < f.length; p++) { var g = n.getItemLayout(f[p]), m = g.x, v = g.y0, y = g.y; h.push([m, v]), d.push([m, v + y]), u = n.getItemVisual(f[p], "color") } var x, _, b = n.getItemLayout(f[0]), w = n.getItemModel(f[p - 1]), S = w.getModel("label"), M = S.get("margin"); if ("add" === e) { var I = c[i] = new $g; x = new _S({ shape: { points: h, stackedOnPoints: d, smooth: .4, stackedOnSmooth: .4, smoothConstraint: !1 }, z2: 0 }), _ = new uy({ style: { x: b.x - M, y: b.y0 + b.y / 2 } }), I.add(x), I.add(_), r.add(I), x.setClipPath(pf(x.getBoundingRect(), t, function () { x.removeClipPath() })) } else { var I = l[s]; x = I.childAt(0), _ = I.childAt(1), r.add(I), c[i] = I, Oa(x, { shape: { points: h, stackedOnPoints: d } }, t), Oa(_, { style: { x: b.x - M, y: b.y0 + b.y / 2 } }, t) } var D = w.getModel("emphasis.itemStyle"), T = w.getModel("itemStyle"); Sa(_.style, S, { text: S.get("show") ? t.getFormattedLabel(f[p - 1], "normal") || n.getName(f[p - 1]) : null, textVerticalAlign: "middle" }), x.setStyle(o({ fill: u }, T.getItemStyle(["color"]))), _a(x, D.getItemStyle()) } var n = t.getData(), r = this.group, a = t.getLayerSeries(), s = n.getLayout("layoutInfo"), l = s.rect, u = s.boundaryGap; r.attr("position", [0, l.y + u[0]]); var h = new du(this._layersSeries || [], a, e, e), c = {}; h.add(y(i, this, "add")).update(y(i, this, "update")).remove(y(i, this, "remove")).execute(), this._layersSeries = a, this._layers = c }, dispose: function () { } }); var OM = function (t) { t.eachSeriesByType("themeRiver", function (t) { var e = t.getData(), i = t.coordinateSystem, n = {}, r = i.getRect(); n.rect = r; var a = t.get("boundaryGap"), o = i.getAxis(); if (n.boundaryGap = a, "horizontal" === o.orient) { a[0] = Ka(a[0], r.height), a[1] = Ka(a[1], r.height); var s = r.height - a[0] - a[1]; gf(e, t, s) } else { a[0] = Ka(a[0], r.width), a[1] = Ka(a[1], r.width); var l = r.width - a[0] - a[1]; gf(e, t, l) } e.setLayout("layoutInfo", n) }) }, zM = function (t) { t.eachSeriesByType("themeRiver", function (t) { var e = t.getData(), i = t.getRawData(), n = t.get("color"), r = N(); e.each(function (t) { r.set(e.getRawIndex(t), t) }), i.each(function (a) { var o = i.getName(a), s = n[(t.nameMap.get(o) - 1) % n.length]; i.setItemVisual(a, "color", s); var l = r.get(a); null != l && e.setItemVisual(l, "color", s) }) }) }; tu(OM), eu(zM), Zl(BS("themeRiver")); { var EM = Vw.extend({ type: "series.pictorialBar", dependencies: ["grid"], defaultOption: { symbol: "circle", symbolSize: null, symbolRotate: null, symbolPosition: null, symbolOffset: null, symbolMargin: null, symbolRepeat: !1, symbolRepeatDirection: "end", symbolClip: !1, symbolBoundingData: null, symbolPatternSize: 400, barGap: "-100%", progressive: 0, hoverAnimation: !1 }, getInitialData: function (t) { return t.stack = null, EM.superApply(this, "getInitialData", arguments) } }), BM = ["itemStyle", "borderWidth"], RM = [{ xy: "x", wh: "width", index: 0, posDesc: ["left", "right"] }, { xy: "y", wh: "height", index: 1, posDesc: ["top", "bottom"] }], NM = new hy; su({ type: "pictorialBar", render: function (t, e, i) { var n = this.group, r = t.getData(), a = this._data, o = t.coordinateSystem, s = o.getBaseAxis(), l = !!s.isHorizontal(), u = o.grid.getRect(), h = { ecSize: { width: i.getWidth(), height: i.getHeight() }, seriesModel: t, coordSys: o, coordSysExtent: [[u.x, u.x + u.width], [u.y, u.y + u.height]], isHorizontal: l, valueDim: RM[+l], categoryDim: RM[1 - l] }; return r.diff(a).add(function (t) { if (r.hasValue(t)) { var e = Af(r, t), i = vf(r, t, e, h), a = Lf(r, h, i); r.setItemGraphicEl(t, a), n.add(a), Nf(a, h, i) } }).update(function (t, e) { var i = a.getItemGraphicEl(e); if (!r.hasValue(t)) return void n.remove(i); var o = Af(r, t), s = vf(r, t, o, h), l = Ef(r, s); i && l !== i.__pictorialShapeStr && (n.remove(i), r.setItemGraphicEl(t, null), i = null), i ? Of(i, h, s) : i = Lf(r, h, s, !0), r.setItemGraphicEl(t, i), i.__pictorialSymbolMeta = s, n.add(i), Nf(i, h, s) }).remove(function (t) { var e = a.getItemGraphicEl(t); e && zf(a, t, e.__pictorialSymbolMeta.animationModel, e) }).execute(), this._data = r, this.group }, dispose: V, remove: function (t) { var e = this.group, i = this._data; t.get("animation") ? i && i.eachItemGraphicEl(function (e) { zf(i, e.dataIndex, t, e) }) : e.removeAll() } }) } tu(x(th, "pictorialBar")), eu(bS("pictorialBar", "roundRect")), ru({ type: "title", layoutMode: { type: "box", ignoreSize: !0 }, defaultOption: { zlevel: 0, z: 6, show: !0, text: "", target: "blank", subtext: "", subtarget: "blank", left: 0, top: 0, backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderWidth: 0, padding: 5, itemGap: 10, textStyle: { fontSize: 18, fontWeight: "bolder", color: "#333" }, subtextStyle: { color: "#aaa" } } }), au({ type: "title", render: function (t, e, i) { if (this.group.removeAll(), t.get("show")) { var n = this.group, r = t.getModel("textStyle"), a = t.getModel("subtextStyle"), o = t.get("textAlign"), s = t.get("textBaseline"), l = new uy({ style: Sa({}, r, { text: t.get("text"), textFill: r.getTextColor() }, { disableBox: !0 }), z2: 10 }), u = l.getBoundingRect(), h = t.get("subtext"), c = new uy({ style: Sa({}, a, { text: h, textFill: a.getTextColor(), y: u.height + t.get("itemGap"), textVerticalAlign: "top" }, { disableBox: !0 }), z2: 10 }), d = t.get("link"), f = t.get("sublink"), p = t.get("triggerEvent", !0); l.silent = !d && !p, c.silent = !f && !p, d && l.on("click", function () { window.open(d, "_" + t.get("target")) }), f && c.on("click", function () { window.open(f, "_" + t.get("subtarget")) }), l.eventData = c.eventData = p ? { componentType: "title", componentIndex: t.componentIndex } : null, n.add(l), h && n.add(c); var g = n.getBoundingRect(), m = t.getBoxLayoutParams(); m.width = g.width, m.height = g.height; var v = Io(m, { width: i.getWidth(), height: i.getHeight() }, t.get("padding")); o || (o = t.get("left") || t.get("right"), "middle" === o && (o = "center"), "right" === o ? v.x += v.width : "center" === o && (v.x += v.width / 2)), s || (s = t.get("top") || t.get("bottom"), "center" === s && (s = "middle"), "bottom" === s ? v.y += v.height : "middle" === s && (v.y += v.height / 2), s = s || "top"), n.attr("position", [v.x, v.y]); var y = { textAlign: o, textVerticalAlign: s }; l.setStyle(y), c.setStyle(y), g = n.getBoundingRect(); var x = v.margin, _ = t.getItemStyle(["color", "opacity"]); _.fill = t.get("backgroundColor"); var b = new by({ shape: { x: g.x - x[3], y: g.y - x[0], width: g.width + x[1] + x[3], height: g.height + x[0] + x[2], r: t.get("borderRadius") }, style: _, silent: !0 }); aa(b), n.add(b) } } }); var FM = ru({ type: "legend.plain", dependencies: ["series"], layoutMode: { type: "box", ignoreSize: !0 }, init: function (t, e, i) { this.mergeDefaultAndTheme(t, i), t.selected = t.selected || {} }, mergeOption: function (t) { FM.superCall(this, "mergeOption", t) }, optionUpdated: function () { this._updateData(this.ecModel); var t = this._data; if (t[0] && "single" === this.get("selectedMode")) { for (var e = !1, i = 0; i < t.length; i++) { var n = t[i].get("name"); if (this.isSelected(n)) { this.select(n), e = !0; break } } !e && this.select(t[0].get("name")) } }, _updateData: function (t) { var e = [], i = []; t.eachRawSeries(function (n) { var r = n.name; i.push(r); var a; if (n.legendDataProvider) { var o = n.legendDataProvider(), s = o.mapArray(o.getName); t.isSeriesFiltered(n) || (i = i.concat(s)), s.length ? e = e.concat(s) : a = !0 } else a = !0; a && Hn(n) && e.push(n.name) }), this._availableNames = i; var n = this.get("data") || e, r = p(n, function (t) { return ("string" == typeof t || "number" == typeof t) && (t = { name: t }), new Ha(t, this, this.ecModel) }, this); this._data = r }, getData: function () { return this._data }, select: function (t) { var e = this.option.selected, i = this.get("selectedMode"); if ("single" === i) { var n = this._data; f(n, function (t) { e[t.get("name")] = !1 }) } e[t] = !0 }, unSelect: function (t) { "single" !== this.get("selectedMode") && (this.option.selected[t] = !1) }, toggleSelected: function (t) { var e = this.option.selected; e.hasOwnProperty(t) || (e[t] = !0), this[e[t] ? "unSelect" : "select"](t) }, isSelected: function (t) { var e = this.option.selected; return !(e.hasOwnProperty(t) && !e[t]) && u(this._availableNames, t) >= 0 }, defaultOption: { zlevel: 0, z: 4, show: !0, orient: "horizontal", left: "center", top: 0, align: "auto", backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderRadius: 0, borderWidth: 0, padding: 5, itemGap: 10, itemWidth: 25, itemHeight: 14, inactiveColor: "#ccc", textStyle: { color: "#333" }, selectedMode: !0, tooltip: { show: !1 } } }); $l("legendToggleSelect", "legendselectchanged", x(Vf, "toggleSelected")), $l("legendSelect", "legendselected", x(Vf, "select")), $l("legendUnSelect", "legendunselected", x(Vf, "unSelect")); var VM = x, GM = f, HM = $g, WM = au({ type: "legend.plain", newlineDisabled: !1, init: function () { this.group.add(this._contentGroup = new HM), this._backgroundEl, this._isFirstRender = !0 }, getContentGroup: function () { return this._contentGroup }, render: function (t, e, i) { var n = this._isFirstRender; if (this._isFirstRender = !1, this.resetInner(), t.get("show", !0)) { var r = t.get("align"); r && "auto" !== r || (r = "right" === t.get("left") && "vertical" === t.get("orient") ? "right" : "left"), this.renderInner(r, t, e, i); var a = t.getBoxLayoutParams(), o = { width: i.getWidth(), height: i.getHeight() }, l = t.get("padding"), u = Io(a, o, l), h = this.layoutInner(t, r, u, n), c = Io(s({ width: h.width, height: h.height }, a), o, l); this.group.attr("position", [c.x - h.x, c.y - h.y]), this.group.add(this._backgroundEl = Gf(h, t)) } }, resetInner: function () { this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl) }, renderInner: function (t, e, i, n) { var r = this.getContentGroup(), a = N(), o = e.get("selectedMode"), s = []; i.eachRawSeries(function (t) { !t.get("legendHoverLink") && s.push(t.id) }), GM(e.getData(), function (l, u) { var h = l.get("name"); if (!this.newlineDisabled && ("" === h || "\n" === h)) return void r.add(new HM({ newline: !0 })); var c = i.getSeriesByName(h)[0]; if (!a.get(h)) if (c) { var d = c.getData(), f = d.getVisual("color"); "function" == typeof f && (f = f(c.getDataParams(0))); var p = d.getVisual("legendSymbol") || "roundRect", g = d.getVisual("symbol"), m = this._createItem(h, u, l, e, p, g, t, f, o); m.on("click", VM(Hf, h, n)).on("mouseover", VM(Wf, c.name, null, n, s)).on("mouseout", VM(Xf, c.name, null, n, s)), a.set(h, !0) } else i.eachRawSeries(function (i) { if (!a.get(h) && i.legendDataProvider) { var r = i.legendDataProvider(), c = r.indexOfName(h); if (0 > c) return; var d = r.getItemVisual(c, "color"), f = "roundRect", p = this._createItem(h, u, l, e, f, null, t, d, o); p.on("click", VM(Hf, h, n)).on("mouseover", VM(Wf, null, h, n, s)).on("mouseout", VM(Xf, null, h, n, s)), a.set(h, !0) } }, this) }, this) }, _createItem: function (t, e, i, n, r, a, s, l, u) { var h = n.get("itemWidth"), c = n.get("itemHeight"), d = n.get("inactiveColor"), f = n.get("symbolKeepAspect"), p = n.isSelected(t), g = new HM, m = i.getModel("textStyle"), v = i.get("icon"), y = i.getModel("tooltip"), x = y.parentModel; if (r = v || r, g.add(vh(r, 0, 0, h, c, p ? l : d, null == f ? !0 : f)), !v && a && (a !== r || "none" === a)) { var _ = .8 * c; "none" === a && (a = "circle"), g.add(vh(a, (h - _) / 2, (c - _) / 2, _, _, p ? l : d, null == f ? !0 : f)) } var b = "left" === s ? h + 5 : -5, w = s, S = n.get("formatter"), M = t; "string" == typeof S && S ? M = S.replace("{name}", null != t ? t : "") : "function" == typeof S && (M = S(t)), g.add(new uy({ style: Sa({}, m, { text: M, x: b, y: c / 2, textFill: p ? m.getTextColor() : d, textAlign: w, textVerticalAlign: "middle" }) })); var I = new by({ shape: g.getBoundingRect(), invisible: !0, tooltip: y.get("show") ? o({ content: t, formatter: x.get("formatter", !0) || function () { return t }, formatterParams: { componentType: "legend", legendIndex: n.componentIndex, name: t, $vars: ["name"] } }, y.option) : null }); return g.add(I), g.eachChild(function (t) { t.silent = !0 }), I.silent = !u, this.getContentGroup().add(g), _a(g), g.__legendDataIndex = e, g }, layoutInner: function (t, e, i) { var n = this.getContentGroup(); lx(t.get("orient"), n, t.get("itemGap"), i.width, i.height); var r = n.getBoundingRect(); return n.attr("position", [-r.x, -r.y]), this.group.getBoundingRect() }, remove: function () { this.getContentGroup().removeAll(), this._isFirstRender = !0 } }), XM = function (t) { var e = t.findComponents({ mainType: "legend" }); e && e.length && t.filterSeries(function (t) { for (var i = 0; i < e.length; i++)if (!e[i].isSelected(t.name)) return !1; return !0 }) }; Zl(XM), cx.registerSubTypeDefaulter("legend", function () { return "plain" }); var UM = FM.extend({ type: "legend.scroll", setScrollDataIndex: function (t) { this.option.scrollDataIndex = t }, defaultOption: { scrollDataIndex: 0, pageButtonItemGap: 5, pageButtonGap: null, pageButtonPosition: "end", pageFormatter: "{current}/{total}", pageIcons: { horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"], vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"] }, pageIconColor: "#2f4554", pageIconInactiveColor: "#aaa", pageIconSize: 15, pageTextStyle: { color: "#333" }, animationDurationUpdate: 800 }, init: function (t, e, i, n) { var r = To(t); UM.superCall(this, "init", t, e, i, n), Uf(this, t, r) }, mergeOption: function (t, e) { UM.superCall(this, "mergeOption", t, e), Uf(this, this.option, t) }, getOrient: function () { return "vertical" === this.get("orient") ? { index: 1, name: "vertical" } : { index: 0, name: "horizontal" } } }), jM = $g, YM = ["width", "height"], qM = ["x", "y"], ZM = WM.extend({ type: "legend.scroll", newlineDisabled: !0, init: function () { ZM.superCall(this, "init"), this._currentIndex = 0, this.group.add(this._containerGroup = new jM), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new jM), this._showController }, resetInner: function () { ZM.superCall(this, "resetInner"), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null }, renderInner: function (t, e, i, n) { function r(t, i) { var r = t + "DataIndex", l = Ga(e.get("pageIcons", !0)[e.getOrient().name][i], { onclick: y(a._pageGo, a, r, e, n) }, { x: -s[0] / 2, y: -s[1] / 2, width: s[0], height: s[1] }); l.name = t, o.add(l) } var a = this; ZM.superCall(this, "renderInner", t, e, i, n); var o = this._controllerGroup, s = e.get("pageIconSize", !0); _(s) || (s = [s, s]), r("pagePrev", 0); var l = e.getModel("pageTextStyle"); o.add(new uy({ name: "pageText", style: { textFill: l.getTextColor(), font: l.getFont(), textVerticalAlign: "middle", textAlign: "center" }, silent: !0 })), r("pageNext", 1) }, layoutInner: function (t, e, i, n) { var r = this.getContentGroup(), a = this._containerGroup, o = this._controllerGroup, s = t.getOrient().index, l = YM[s], u = YM[1 - s], h = qM[1 - s]; lx(t.get("orient"), r, t.get("itemGap"), s ? i.width : null, s ? null : i.height), lx("horizontal", o, t.get("pageButtonItemGap", !0)); var c = r.getBoundingRect(), d = o.getBoundingRect(), f = this._showController = c[l] > i[l], p = [-c.x, -c.y]; n || (p[s] = r.position[s]); var g = [0, 0], m = [-d.x, -d.y], v = C(t.get("pageButtonGap", !0), t.get("itemGap", !0)); if (f) { var y = t.get("pageButtonPosition", !0); "end" === y ? m[s] += i[l] - d[l] : g[s] += d[l] + v } m[1 - s] += c[u] / 2 - d[u] / 2, r.attr("position", p), a.attr("position", g), o.attr("position", m); var x = this.group.getBoundingRect(), x = { x: 0, y: 0 }; if (x[l] = f ? i[l] : c[l], x[u] = Math.max(c[u], d[u]), x[h] = Math.min(0, d[h] + m[1 - s]), a.__rectSize = i[l], f) { var _ = { x: 0, y: 0 }; _[l] = Math.max(i[l] - d[l] - v, 0), _[u] = x[u], a.setClipPath(new by({ shape: _ })), a.__rectSize = _[l] } else o.eachChild(function (t) { t.attr({ invisible: !0, silent: !0 }) }); var b = this._getPageInfo(t); return null != b.pageIndex && Oa(r, { position: b.contentPosition }, f ? t : !1), this._updatePageInfoView(t, b), x }, _pageGo: function (t, e, i) { var n = this._getPageInfo(e)[t]; null != n && i.dispatchAction({ type: "legendScroll", scrollDataIndex: n, legendId: e.id }) }, _updatePageInfoView: function (t, e) { var i = this._controllerGroup; f(["pagePrev", "pageNext"], function (n) { var r = null != e[n + "DataIndex"], a = i.childOfName(n); a && (a.setStyle("fill", r ? t.get("pageIconColor", !0) : t.get("pageIconInactiveColor", !0)), a.cursor = r ? "pointer" : "default") }); var n = i.childOfName("pageText"), r = t.get("pageFormatter"), a = e.pageIndex, o = null != a ? a + 1 : 0, s = e.pageCount; n && r && n.setStyle("text", w(r) ? r.replace("{current}", o).replace("{total}", s) : r({ current: o, total: s })) }, _getPageInfo: function (t) { function e(t) { if (t) { var e = t.getBoundingRect(), i = e[l] + t.position[o]; return { s: i, e: i + e[s], i: t.__legendDataIndex } } } function i(t, e) { return t.e >= e && t.s <= e + a } var n = t.get("scrollDataIndex", !0), r = this.getContentGroup(), a = this._containerGroup.__rectSize, o = t.getOrient().index, s = YM[o], l = qM[o], u = this._findTargetItemIndex(n), h = r.children(), c = h[u], d = h.length, f = d ? 1 : 0, p = { contentPosition: r.position.slice(), pageCount: f, pageIndex: f - 1, pagePrevDataIndex: null, pageNextDataIndex: null }; if (!c) return p; var g = e(c); p.contentPosition[o] = -g.s; for (var m = u + 1, v = g, y = g, x = null; d >= m; ++m)x = e(h[m]), (!x && y.e > v.s + a || x && !i(x, v.s)) && (v = y.i > v.i ? y : x, v && (null == p.pageNextDataIndex && (p.pageNextDataIndex = v.i), ++p.pageCount)), y = x; for (var m = u - 1, v = g, y = g, x = null; m >= -1; --m)x = e(h[m]), x && i(y, x.s) || !(v.i < y.i) || (y = v, null == p.pagePrevDataIndex && (p.pagePrevDataIndex = v.i), ++p.pageCount, ++p.pageIndex), v = x; return p }, _findTargetItemIndex: function (t) { var e, i = this.getContentGroup(); return this._showController ? i.eachChild(function (i, n) { i.__legendDataIndex === t && (e = n) }) : e = 0, e } }); $l("legendScroll", "legendscroll", function (t, e) { var i = t.scrollDataIndex; null != i && e.eachComponent({ mainType: "legend", subType: "scroll", query: t }, function (t) { t.setScrollDataIndex(i) }) }), ru({ type: "tooltip", dependencies: ["axisPointer"], defaultOption: { zlevel: 0, z: 60, show: !0, showContent: !0, trigger: "item", triggerOn: "mousemove|click", alwaysShowContent: !1, displayMode: "single", renderMode: "auto", confine: !1, showDelay: 0, hideDelay: 100, transitionDuration: .4, enterable: !1, backgroundColor: "rgba(50,50,50,0.7)", borderColor: "#333", borderRadius: 4, borderWidth: 0, padding: 5, extraCssText: "", axisPointer: { type: "line", axis: "auto", animation: "auto", animationDurationUpdate: 200, animationEasingUpdate: "exponentialOut", crossStyle: { color: "#999", width: 1, type: "dashed", textStyle: {} } }, textStyle: { color: "#fff", fontSize: 14 } } }); var KM = f, $M = po, QM = ["", "-webkit-", "-moz-", "-o-"], JM = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;"; Zf.prototype = { constructor: Zf, _enterable: !0, update: function () { var t = this._container, e = t.currentStyle || document.defaultView.getComputedStyle(t), i = t.style; "absolute" !== i.position && "absolute" !== e.position && (i.position = "relative") }, show: function (t) { clearTimeout(this._hideTimeout); var e = this.el; e.style.cssText = JM + qf(t) + ";left:" + this._x + "px;top:" + this._y + "px;" + (t.get("extraCssText") || ""), e.style.display = e.innerHTML ? "block" : "none", e.style.pointerEvents = this._enterable ? "auto" : "none", this._show = !0 }, setContent: function (t) { this.el.innerHTML = null == t ? "" : t }, setEnterable: function (t) { this._enterable = t }, getSize: function () { var t = this.el; return [t.clientWidth, t.clientHeight] }, moveTo: function (t, e) { var i, n = this._zr; n && n.painter && (i = n.painter.getViewportRootOffset()) && (t += i.offsetLeft, e += i.offsetTop); var r = this.el.style; r.left = t + "px", r.top = e + "px", this._x = t, this._y = e }, hide: function () { this.el.style.display = "none", this._show = !1 }, hideLater: function (t) { !this._show || this._inContent && this._enterable || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(y(this.hide, this), t)) : this.hide()) }, isShow: function () { return this._show }, getOuterSize: function () { var t = this.el.clientWidth, e = this.el.clientHeight; if (document.defaultView && document.defaultView.getComputedStyle) { var i = document.defaultView.getComputedStyle(this.el); i && (t += parseInt(i.paddingLeft, 10) + parseInt(i.paddingRight, 10) + parseInt(i.borderLeftWidth, 10) + parseInt(i.borderRightWidth, 10), e += parseInt(i.paddingTop, 10) + parseInt(i.paddingBottom, 10) + parseInt(i.borderTopWidth, 10) + parseInt(i.borderBottomWidth, 10)) } return { width: t, height: e } } }, Kf.prototype = { constructor: Kf, _enterable: !0, update: function () { }, show: function () { this._hideTimeout && clearTimeout(this._hideTimeout), this.el.attr("show", !0), this._show = !0 }, setContent: function (t, e, i) { this.el && this._zr.remove(this.el); for (var n = {}, r = t, a = "{marker", o = "|}", s = r.indexOf(a); s >= 0;) { var l = r.indexOf(o), u = r.substr(s + a.length, l - s - a.length); n["marker" + u] = u.indexOf("sub") > -1 ? { textWidth: 4, textHeight: 4, textBorderRadius: 2, textBackgroundColor: e[u], textOffset: [3, 0] } : { textWidth: 10, textHeight: 10, textBorderRadius: 5, textBackgroundColor: e[u] }, r = r.substr(l + 1), s = r.indexOf("{marker") } this.el = new uy({ style: { rich: n, text: t, textLineHeight: 20, textBackgroundColor: i.get("backgroundColor"), textBorderRadius: i.get("borderRadius"), textFill: i.get("textStyle.color"), textPadding: i.get("padding") }, z: i.get("z") }), this._zr.add(this.el); var h = this; this.el.on("mouseover", function () { h._enterable && (clearTimeout(h._hideTimeout), h._show = !0), h._inContent = !0 }), this.el.on("mouseout", function () { h._enterable && h._show && h.hideLater(h._hideDelay), h._inContent = !1 }) }, setEnterable: function (t) { this._enterable = t }, getSize: function () { var t = this.el.getBoundingRect(); return [t.width, t.height] }, moveTo: function (t, e) { this.el && this.el.attr("position", [t, e]) }, hide: function () { this.el.hide(), this._show = !1 }, hideLater: function (t) { !this._show || this._inContent && this._enterable || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(y(this.hide, this), t)) : this.hide()) }, isShow: function () { return this._show }, getOuterSize: function () { return this.getSize() } }; var tI = y, eI = f, iI = Ka, nI = new by({ shape: { x: -1, y: -1, width: 2, height: 2 } }); au({ type: "tooltip", init: function (t, e) { if (!Gp.node) { var i = t.getComponent("tooltip"), n = i.get("renderMode"); this._renderMode = Kn(n); var r; "html" === this._renderMode ? (r = new Zf(e.getDom(), e), this._newLine = "<br/>") : (r = new Kf(e), this._newLine = "\n"), this._tooltipContent = r } }, render: function (t, e, i) { if (!Gp.node) { this.group.removeAll(), this._tooltipModel = t, this._ecModel = e, this._api = i, this._lastDataByCoordSys = null, this._alwaysShowContent = t.get("alwaysShowContent"); var n = this._tooltipContent; n.update(), n.setEnterable(t.get("enterable")), this._initGlobalListener(), this._keepShow() } }, _initGlobalListener: function () { var t = this._tooltipModel, e = t.get("triggerOn"); Hd("itemTooltip", this._api, tI(function (t, i, n) { "none" !== e && (e.indexOf(t) >= 0 ? this._tryShow(i, n) : "leave" === t && this._hide(n)) }, this)) }, _keepShow: function () { var t = this._tooltipModel, e = this._ecModel, i = this._api; if (null != this._lastX && null != this._lastY && "none" !== t.get("triggerOn")) { var n = this; clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function () { n.manuallyShowTip(t, e, i, { x: n._lastX, y: n._lastY }) }) } }, manuallyShowTip: function (t, e, i, n) { if (n.from !== this.uid && !Gp.node) { var r = Qf(n, i); this._ticket = ""; var a = n.dataByCoordSys; if (n.tooltip && null != n.x && null != n.y) { var o = nI; o.position = [n.x, n.y], o.update(), o.tooltip = n.tooltip, this._tryShow({ offsetX: n.x, offsetY: n.y, target: o }, r) } else if (a) this._tryShow({ offsetX: n.x, offsetY: n.y, position: n.position, event: {}, dataByCoordSys: n.dataByCoordSys, tooltipOption: n.tooltipOption }, r); else if (null != n.seriesIndex) { if (this._manuallyAxisShowTip(t, e, i, n)) return; var s = pM(n, e), l = s.point[0], u = s.point[1]; null != l && null != u && this._tryShow({ offsetX: l, offsetY: u, position: n.position, target: s.el, event: {} }, r) } else null != n.x && null != n.y && (i.dispatchAction({ type: "updateAxisPointer", x: n.x, y: n.y }), this._tryShow({ offsetX: n.x, offsetY: n.y, position: n.position, target: i.getZr().findHover(n.x, n.y).target, event: {} }, r)) } }, manuallyHideTip: function (t, e, i, n) { var r = this._tooltipContent; !this._alwaysShowContent && this._tooltipModel && r.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = null, n.from !== this.uid && this._hide(Qf(n, i)) }, _manuallyAxisShowTip: function (t, e, i, n) { var r = n.seriesIndex, a = n.dataIndex, o = e.getComponent("axisPointer").coordSysAxesInfo; if (null != r && null != a && null != o) { var s = e.getSeriesByIndex(r); if (s) { var l = s.getData(), t = $f([l.getItemModel(a), s, (s.coordinateSystem || {}).model, t]); if ("axis" === t.get("trigger")) return i.dispatchAction({ type: "updateAxisPointer", seriesIndex: r, dataIndex: a, position: n.position }), !0 } } }, _tryShow: function (t, e) { var i = t.target, n = this._tooltipModel; if (n) { this._lastX = t.offsetX, this._lastY = t.offsetY; var r = t.dataByCoordSys; r && r.length ? this._showAxisTooltip(r, t) : i && null != i.dataIndex ? (this._lastDataByCoordSys = null, this._showSeriesItemTooltip(t, i, e)) : i && i.tooltip ? (this._lastDataByCoordSys = null, this._showComponentItemTooltip(t, i, e)) : (this._lastDataByCoordSys = null, this._hide(e)) } }, _showOrMove: function (t, e) { var i = t.get("showDelay"); e = y(e, this), clearTimeout(this._showTimout), i > 0 ? this._showTimout = setTimeout(e, i) : e() }, _showAxisTooltip: function (t, e) { var i = this._ecModel, n = this._tooltipModel, a = [e.offsetX, e.offsetY], o = [], s = [], l = $f([e.tooltipOption, n]), u = this._renderMode, h = this._newLine, c = {}; eI(t, function (t) { eI(t.dataByAxis, function (t) { var e = i.getComponent(t.axisDim + "Axis", t.axisIndex), n = t.value, a = []; if (e && null != n) { var l = af(n, e.axis, i, t.seriesDataIndices, t.valueLabelOpt); f(t.seriesDataIndices, function (o) { var h = i.getSeriesByIndex(o.seriesIndex), d = o.dataIndexInside, f = h && h.getDataParams(d); if (f.axisDim = t.axisDim, f.axisIndex = t.axisIndex, f.axisType = t.axisType, f.axisId = t.axisId, f.axisValue = ch(e.axis, n), f.axisValueLabel = l, f) { s.push(f); var p, g = h.formatTooltip(d, !0, null, u); if (S(g)) { p = g.html; var m = g.markers; r(c, m) } else p = g; a.push(p) } }); var d = l; o.push("html" !== u ? a.join(h) : (d ? go(d) + h : "") + a.join(h)) } }) }, this), o.reverse(), o = o.join(this._newLine + this._newLine); var d = e.position; this._showOrMove(l, function () { this._updateContentNotChangedOnAxis(t) ? this._updatePosition(l, d, a[0], a[1], this._tooltipContent, s) : this._showTooltipContent(l, o, s, Math.random(), a[0], a[1], d, void 0, c) }) }, _showSeriesItemTooltip: function (t, e, i) { var n = this._ecModel, r = e.seriesIndex, a = n.getSeriesByIndex(r), o = e.dataModel || a, s = e.dataIndex, l = e.dataType, u = o.getData(), h = $f([u.getItemModel(s), o, a && (a.coordinateSystem || {}).model, this._tooltipModel]), c = h.get("trigger"); if (null == c || "item" === c) { var d, f, p = o.getDataParams(s, l), g = o.formatTooltip(s, !1, l, this._renderMode); S(g) ? (d = g.html, f = g.markers) : (d = g, f = null); var m = "item_" + o.name + "_" + s; this._showOrMove(h, function () { this._showTooltipContent(h, d, p, m, t.offsetX, t.offsetY, t.position, t.target, f) }), i({ type: "showTip", dataIndexInside: s, dataIndex: u.getRawIndex(s), seriesIndex: r, from: this.uid }) } }, _showComponentItemTooltip: function (t, e, i) { var n = e.tooltip; if ("string" == typeof n) { var r = n; n = { content: r, formatter: r } } var a = new Ha(n, this._tooltipModel, this._ecModel), o = a.get("content"), s = Math.random(); this._showOrMove(a, function () { this._showTooltipContent(a, o, a.get("formatterParams") || {}, s, t.offsetX, t.offsetY, t.position, e) }), i({ type: "showTip", from: this.uid }) }, _showTooltipContent: function (t, e, i, n, r, a, o, s, l) { if (this._ticket = "", t.get("showContent") && t.get("show")) { var u = this._tooltipContent, h = t.get("formatter"); o = o || t.get("position"); var c = e; if (h && "string" == typeof h) c = mo(h, i, !0); else if ("function" == typeof h) { var d = tI(function (e, n) { e === this._ticket && (u.setContent(n, l, t), this._updatePosition(t, o, r, a, u, i, s)) }, this); this._ticket = n, c = h(i, n, d) } u.setContent(c, l, t), u.show(t), this._updatePosition(t, o, r, a, u, i, s) } }, _updatePosition: function (t, e, i, n, r, a, o) { var s = this._api.getWidth(), l = this._api.getHeight(); e = e || t.get("position"); var u = r.getSize(), h = t.get("align"), c = t.get("verticalAlign"), d = o && o.getBoundingRect().clone(); if (o && d.applyTransform(o.transform), "function" == typeof e && (e = e([i, n], a, r.el, d, { viewSize: [s, l], contentSize: u.slice() })), _(e)) i = iI(e[0], s), n = iI(e[1], l); else if (S(e)) { e.width = u[0], e.height = u[1]; var f = Io(e, { width: s, height: l }); i = f.x, n = f.y, h = null, c = null } else if ("string" == typeof e && o) { var p = ep(e, d, u); i = p[0], n = p[1] } else { var p = Jf(i, n, r, s, l, h ? null : 20, c ? null : 20); i = p[0], n = p[1] } if (h && (i -= ip(h) ? u[0] / 2 : "right" === h ? u[0] : 0), c && (n -= ip(c) ? u[1] / 2 : "bottom" === c ? u[1] : 0), t.get("confine")) { var p = tp(i, n, r, s, l); i = p[0], n = p[1] } r.moveTo(i, n) }, _updateContentNotChangedOnAxis: function (t) { var e = this._lastDataByCoordSys, i = !!e && e.length === t.length; return i && eI(e, function (e, n) { var r = e.dataByAxis || {}, a = t[n] || {}, o = a.dataByAxis || []; i &= r.length === o.length, i && eI(r, function (t, e) { var n = o[e] || {}, r = t.seriesDataIndices || [], a = n.seriesDataIndices || []; i &= t.value === n.value && t.axisType === n.axisType && t.axisId === n.axisId && r.length === a.length, i && eI(r, function (t, e) { var n = a[e]; i &= t.seriesIndex === n.seriesIndex && t.dataIndex === n.dataIndex }) }) }), this._lastDataByCoordSys = t, !!i }, _hide: function (t) { this._lastDataByCoordSys = null, t({ type: "hideTip", from: this.uid }) }, dispose: function (t, e) { Gp.node || (this._tooltipContent.hide(), qd("itemTooltip", e)) } }), $l({ type: "showTip", event: "showTip", update: "tooltip:manuallyShowTip" }, function () { }), $l({ type: "hideTip", event: "hideTip", update: "tooltip:manuallyHideTip" }, function () { }); var rI = fo, aI = go, oI = ru({ type: "marker", dependencies: ["series", "grid", "polar", "geo"], init: function (t, e, i, n) { this.mergeDefaultAndTheme(t, i), this.mergeOption(t, i, n.createdBySelf, !0) }, isAnimationEnabled: function () { if (Gp.node) return !1; var t = this.__hostSeries; return this.getShallow("animation") && t && t.isAnimationEnabled() }, mergeOption: function (t, e, i, n) { var r = this.constructor, a = this.mainType + "Model"; i || e.eachSeries(function (t) { var i = t.get(this.mainType, !0), s = t[a]; return i && i.data ? (s ? s.mergeOption(i, e, !0) : (n && np(i), f(i.data, function (t) { t instanceof Array ? (np(t[0]), np(t[1])) : np(t) }), s = new r(i, this, e), o(s, { mainType: this.mainType, seriesIndex: t.seriesIndex, name: t.name, createdBySelf: !0 }), s.__hostSeries = t), void (t[a] = s)) : void (t[a] = null) }, this) }, formatTooltip: function (t) { var e = this.getData(), i = this.getRawValue(t), n = _(i) ? p(i, rI).join(", ") : rI(i), r = e.getName(t), a = aI(this.name); return (null != i || r) && (a += "<br />"), r && (a += aI(r), null != i && (a += " : ")), null != i && (a += aI(n)), a }, getData: function () { return this._data }, setData: function (t) { this._data = t } }); c(oI, Zx), oI.extend({ type: "markPoint", defaultOption: { zlevel: 0, z: 5, symbol: "pin", symbolSize: 50, tooltip: { trigger: "item" }, label: { show: !0, position: "inside" }, itemStyle: { borderWidth: 2 }, emphasis: { label: { show: !0 } } } }); var sI = u, lI = x, uI = { min: lI(op, "min"), max: lI(op, "max"), average: lI(op, "average") }, hI = au({ type: "marker", init: function () { this.markerGroupMap = N() }, render: function (t, e, i) { var n = this.markerGroupMap; n.each(function (t) { t.__keep = !1 }); var r = this.type + "Model"; e.eachSeries(function (t) { var n = t[r]; n && this.renderSeries(t, n, e, i) }, this), n.each(function (t) { !t.__keep && this.group.remove(t.group) }, this) }, renderSeries: function () { } }); hI.extend({ type: "markPoint", updateTransform: function (t, e, i) { e.eachSeries(function (t) { var e = t.markPointModel; e && (fp(e.getData(), t, i), this.markerGroupMap.get(t.id).updateLayout(e)) }, this) }, renderSeries: function (t, e, i, n) { var r = t.coordinateSystem, a = t.id, o = t.getData(), s = this.markerGroupMap, l = s.get(a) || s.set(a, new Rc), u = pp(r, t, e); e.setData(u), fp(e.getData(), t, n), u.each(function (t) { var i = u.getItemModel(t), n = i.getShallow("symbolSize"); "function" == typeof n && (n = n(e.getRawValue(t), e.getDataParams(t))), u.setItemVisual(t, { symbolSize: n, color: i.get("itemStyle.color") || o.getVisual("color"), symbol: i.getShallow("symbol") }) }), l.updateData(u), this.group.add(l.group), u.eachItemGraphicEl(function (t) { t.traverse(function (t) { t.dataModel = e }) }), l.__keep = !0, l.group.silent = e.get("silent") || t.get("silent") } }), ql(function (t) { t.markPoint = t.markPoint || {} }), oI.extend({ type: "markLine", defaultOption: { zlevel: 0, z: 5, symbol: ["circle", "arrow"], symbolSize: [8, 16], precision: 2, tooltip: { trigger: "item" }, label: { show: !0, position: "end" }, lineStyle: { type: "dashed" }, emphasis: { label: { show: !0 }, lineStyle: { width: 3 } }, animationEasing: "linear" } }); var cI = Sy.prototype, dI = Iy.prototype, fI = Qr({ type: "ec-line", style: { stroke: "#000", fill: null }, shape: { x1: 0, y1: 0, x2: 0, y2: 0, percent: 1, cpx1: null, cpy1: null }, buildPath: function (t, e) { (gp(e) ? cI : dI).buildPath(t, e) }, pointAt: function (t) { return gp(this.shape) ? cI.pointAt.call(this, t) : dI.pointAt.call(this, t) }, tangentAt: function (t) { var e = this.shape, i = gp(e) ? [e.x2 - e.x1, e.y2 - e.y1] : dI.tangentAt.call(this, t); return te(i, i) } }), pI = ["fromSymbol", "toSymbol"], gI = bp.prototype; gI.beforeUpdate = _p, gI._createLine = function (t, e, i) { var n = t.hostModel, r = t.getItemLayout(e), a = yp(r); a.shape.percent = 0, za(a, { shape: { percent: 1 } }, n, e), this.add(a); var o = new uy({ name: "label", lineLabelOriginalOpacity: 1 }); this.add(o), f(pI, function (i) { var n = vp(i, t, e); this.add(n), this[mp(i)] = t.getItemVisual(e, i) }, this), this._updateCommonStl(t, e, i) }, gI.updateData = function (t, e, i) {
    var n = t.hostModel, r = this.childOfName("line"), a = t.getItemLayout(e), o = { shape: {} }; xp(o.shape, a), Oa(r, o, n, e), f(pI, function (i) {
      var n = t.getItemVisual(e, i), r = mp(i); if (this[r] !== n) {
        this.remove(this.childOfName(i)); var a = vp(i, t, e);
        this.add(a)
      } this[r] = n
    }, this), this._updateCommonStl(t, e, i)
  }, gI._updateCommonStl = function (t, e, i) { var n = t.hostModel, r = this.childOfName("line"), a = i && i.lineStyle, o = i && i.hoverLineStyle, l = i && i.labelModel, u = i && i.hoverLabelModel; if (!i || t.hasItemOption) { var h = t.getItemModel(e); a = h.getModel("lineStyle").getLineStyle(), o = h.getModel("emphasis.lineStyle").getLineStyle(), l = h.getModel("label"), u = h.getModel("emphasis.label") } var c = t.getItemVisual(e, "color"), d = k(t.getItemVisual(e, "opacity"), a.opacity, 1); r.useStyle(s({ strokeNoScale: !0, fill: "none", stroke: c, opacity: d }, a)), r.hoverStyle = o, f(pI, function (t) { var e = this.childOfName(t); e && (e.setColor(c), e.setStyle({ opacity: d })) }, this); var p, g, m = l.getShallow("show"), v = u.getShallow("show"), y = this.childOfName("label"); if ((m || v) && (p = c || "#000", g = n.getFormattedLabel(e, "normal", t.dataType), null == g)) { var x = n.getRawValue(e); g = null == x ? t.getName(e) : isFinite(x) ? $a(x) : x } var _ = m ? g : null, b = v ? C(n.getFormattedLabel(e, "emphasis", t.dataType), g) : null, w = y.style; (null != _ || null != b) && (Sa(y.style, l, { text: _ }, { autoColor: p }), y.__textAlign = w.textAlign, y.__verticalAlign = w.textVerticalAlign, y.__position = l.get("position") || "middle"), y.hoverStyle = null != b ? { text: b, textFill: u.getTextColor(!0), fontStyle: u.getShallow("fontStyle"), fontWeight: u.getShallow("fontWeight"), fontSize: u.getShallow("fontSize"), fontFamily: u.getShallow("fontFamily") } : { text: null }, y.ignore = !m && !v, _a(this) }, gI.highlight = function () { this.trigger("emphasis") }, gI.downplay = function () { this.trigger("normal") }, gI.updateLayout = function (t, e) { this.setLinePoints(t.getItemLayout(e)) }, gI.setLinePoints = function (t) { var e = this.childOfName("line"); xp(e.shape, t), e.dirty() }, h(bp, $g); var mI = wp.prototype; mI.isPersistent = function () { return !0 }, mI.updateData = function (t) { var e = this, i = e.group, n = e._lineData; e._lineData = t, n || i.removeAll(); var r = Ip(t); t.diff(n).add(function (i) { Sp(e, t, i, r) }).update(function (i, a) { Mp(e, n, t, a, i, r) }).remove(function (t) { i.remove(n.getItemGraphicEl(t)) }).execute() }, mI.updateLayout = function () { var t = this._lineData; t && t.eachItemGraphicEl(function (e, i) { e.updateLayout(t, i) }, this) }, mI.incrementalPrepareUpdate = function (t) { this._seriesScope = Ip(t), this._lineData = null, this.group.removeAll() }, mI.incrementalUpdate = function (t, e) { function i(t) { t.isGroup || (t.incremental = t.useHoverLayer = !0) } for (var n = t.start; n < t.end; n++) { var r = e.getItemLayout(n); if (Tp(r)) { var a = new this._ctor(e, n, this._seriesScope); a.traverse(i), this.group.add(a), e.setItemGraphicEl(n, a) } } }, mI.remove = function () { this._clearIncremental(), this._incremental = null, this.group.removeAll() }, mI._clearIncremental = function () { var t = this._incremental; t && t.clearDisplaybles() }; var vI = function (t, e, i, a) { var s = t.getData(), l = a.type; if (!_(a) && ("min" === l || "max" === l || "average" === l || "median" === l || null != a.xAxis || null != a.yAxis)) { var u, h, c; if (null != a.yAxis || null != a.xAxis) h = null != a.yAxis ? "y" : "x", u = e.getAxis(h), c = A(a.yAxis, a.xAxis); else { var d = lp(a, s, e, t); h = d.valueDataDim, u = d.valueAxis, c = dp(s, h, l) } var f = "x" === h ? 0 : 1, p = 1 - f, g = n(a), m = {}; g.type = null, g.coord = [], m.coord = [], g.coord[p] = -1 / 0, m.coord[p] = 1 / 0; var v = i.get("precision"); v >= 0 && "number" == typeof c && (c = +c.toFixed(Math.min(v, 20))), g.coord[f] = m.coord[f] = c, a = [g, m, { type: l, valueIndex: a.valueIndex, value: c }] } return a = [sp(t, a[0]), sp(t, a[1]), o({}, a[2])], a[2].type = a[2].type || "", r(a[2], a[0]), r(a[2], a[1]), a }; hI.extend({ type: "markLine", updateTransform: function (t, e, i) { e.eachSeries(function (t) { var e = t.markLineModel; if (e) { var n = e.getData(), r = e.__from, a = e.__to; r.each(function (e) { Pp(r, e, !0, t, i), Pp(a, e, !1, t, i) }), n.each(function (t) { n.setItemLayout(t, [r.getItemLayout(t), a.getItemLayout(t)]) }), this.markerGroupMap.get(t.id).updateLayout() } }, this) }, renderSeries: function (t, e, i, n) { function r(e, i, r) { var a = e.getItemModel(i); Pp(e, i, r, t, n), e.setItemVisual(i, { symbolSize: a.get("symbolSize") || g[r ? 0 : 1], symbol: a.get("symbol", !0) || p[r ? 0 : 1], color: a.get("itemStyle.color") || s.getVisual("color") }) } var a = t.coordinateSystem, o = t.id, s = t.getData(), l = this.markerGroupMap, u = l.get(o) || l.set(o, new wp); this.group.add(u.group); var h = Lp(a, t, e), c = h.from, d = h.to, f = h.line; e.__from = c, e.__to = d, e.setData(f); var p = e.get("symbol"), g = e.get("symbolSize"); _(p) || (p = [p, p]), "number" == typeof g && (g = [g, g]), h.from.each(function (t) { r(c, t, !0), r(d, t, !1) }), f.each(function (t) { var e = f.getItemModel(t).get("lineStyle.color"); f.setItemVisual(t, { color: e || c.getItemVisual(t, "color") }), f.setItemLayout(t, [c.getItemLayout(t), d.getItemLayout(t)]), f.setItemVisual(t, { fromSymbolSize: c.getItemVisual(t, "symbolSize"), fromSymbol: c.getItemVisual(t, "symbol"), toSymbolSize: d.getItemVisual(t, "symbolSize"), toSymbol: d.getItemVisual(t, "symbol") }) }), u.updateData(f), h.line.eachItemGraphicEl(function (t) { t.traverse(function (t) { t.dataModel = e }) }), u.__keep = !0, u.group.silent = e.get("silent") || t.get("silent") } }), ql(function (t) { t.markLine = t.markLine || {} }), oI.extend({ type: "markArea", defaultOption: { zlevel: 0, z: 1, tooltip: { trigger: "item" }, animation: !1, label: { show: !0, position: "top" }, itemStyle: { borderWidth: 0 }, emphasis: { label: { show: !0, position: "top" } } } }); var yI = function (t, e, i, n) { var r = sp(t, n[0]), o = sp(t, n[1]), s = A, l = r.coord, u = o.coord; l[0] = s(l[0], -1 / 0), l[1] = s(l[1], -1 / 0), u[0] = s(u[0], 1 / 0), u[1] = s(u[1], 1 / 0); var h = a([{}, r, o]); return h.coord = [r.coord, o.coord], h.x0 = r.x, h.y0 = r.y, h.x1 = o.x, h.y1 = o.y, h }, xI = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]]; hI.extend({ type: "markArea", updateTransform: function (t, e, i) { e.eachSeries(function (t) { var e = t.markAreaModel; if (e) { var n = e.getData(); n.each(function (e) { var r = p(xI, function (r) { return Bp(n, e, r, t, i) }); n.setItemLayout(e, r); var a = n.getItemGraphicEl(e); a.setShape("points", r) }) } }, this) }, renderSeries: function (t, e, i, n) { var r = t.coordinateSystem, a = t.id, o = t.getData(), l = this.markerGroupMap, u = l.get(a) || l.set(a, { group: new $g }); this.group.add(u.group), u.__keep = !0; var h = Rp(r, t, e); e.setData(h), h.each(function (e) { h.setItemLayout(e, p(xI, function (i) { return Bp(h, e, i, t, n) })), h.setItemVisual(e, { color: o.getVisual("color") }) }), h.diff(u.__data).add(function (t) { var e = new vy({ shape: { points: h.getItemLayout(t) } }); h.setItemGraphicEl(t, e), u.group.add(e) }).update(function (t, i) { var n = u.__data.getItemGraphicEl(i); Oa(n, { shape: { points: h.getItemLayout(t) } }, e, t), u.group.add(n), h.setItemGraphicEl(t, n) }).remove(function (t) { var e = u.__data.getItemGraphicEl(t); u.group.remove(e) }).execute(), h.eachItemGraphicEl(function (t, i) { var n = h.getItemModel(i), r = n.getModel("label"), a = n.getModel("emphasis.label"), o = h.getItemVisual(i, "color"); t.useStyle(s(n.getModel("itemStyle").getItemStyle(), { fill: Je(o, .4), stroke: o })), t.hoverStyle = n.getModel("emphasis.itemStyle").getItemStyle(), wa(t.style, t.hoverStyle, r, a, { labelFetcher: e, labelDataIndex: i, defaultText: h.getName(i) || "", isRectText: !0, autoColor: o }), _a(t, {}), t.dataModel = e }), u.__data = h, u.group.silent = e.get("silent") || t.get("silent") } }), ql(function (t) { t.markArea = t.markArea || {} }), t.version = W_, t.dependencies = X_, t.PRIORITY = J_, t.init = Gl, t.connect = Hl, t.disConnect = Wl, t.disconnect = xb, t.dispose = Xl, t.getInstanceByDom = Ul, t.getInstanceById = jl, t.registerTheme = Yl, t.registerPreprocessor = ql, t.registerProcessor = Zl, t.registerPostUpdate = Kl, t.registerAction = $l, t.registerCoordinateSystem = Ql, t.getCoordinateSystemDimensions = Jl, t.registerLayout = tu, t.registerVisual = eu, t.registerLoading = nu, t.extendComponentModel = ru, t.extendComponentView = au, t.extendSeriesModel = ou, t.extendChartView = su, t.setCanvasCreator = lu, t.registerMap = uu, t.getMap = hu, t.dataTool = _b, t.zrender = jm, t.number = $y, t.format = rx, t.throttle = Us, t.helper = bw, t.matrix = xg, t.vector = sg, t.color = Ng, t.parseGeoJSON = Sw, t.parseGeoJson = Tw, t.util = Aw, t.graphic = Cw, t.List = Lb, t.Model = Ha, t.Axis = Dw, t.env = Gp
});